[{"categories":["科研学习"],"content":"简单介绍 这一篇是讲PoW基础的论文,没有具体说明PoW是什么,但给出了与PoW相关的一些定义和例子, 用于理解PoW还可. 整篇文章看完还是云里雾里的, 但大概理解了PoW其实相当于一个证明, 对于给定的一个hash函数, V知道这个函数的计算结果, 而P要做的是向V证明它知道这个计算结果所对应的原象. 因为hash算逆几乎不可能, 因此若原象是n位, P随便猜的几率为1/2^n. ","date":"2022-11-26","objectID":"/posts/org_15_pow/:1:0","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#简单介绍"},{"categories":["科研学习"],"content":"定义: POW即是交互性的,又是非交互性的证明协议. 在协议执行期间P和V要进行 一个私密硬币翻转的随机数, 最终由V决定是否接收. 使用C_V来标记V的私密硬币翻转, 要保证有效的证明,就要保证C_V的生成不会被P控制. 在非交互性的PoW中, 证明者模拟与验证者的通信, 并将结果发给验证者. 隐性PoW: 一种非交互性的协议, 证明者在证明时不需要验证者的主动参与. 假设没有通信延迟, 定义开始时间\\(t_s\\)为V初始化它的第一轮通信；完成时间\\(t_c\\)为协议的最后一轮通信完成, PoW的目标即为P证明它在时间\\([t_s, t_c]\\)中进行了确定数量的计算. 令l为安全参数, poly为任何给定的多项式变量, 本定义在假设P可以在\\([-\\infty, t_c]\\)的时间内进行计算. 作者对PoW的hardness进行特征化, 定义1为hardness的下界, 定义2为其上界. 定义1: PoW为(w,p)-hard: P有内存m, 若p在[t_s, t_c]时间内最多进行了w步, 则V接受它的概率至多为: \\(p + o(\\frac{m}{poly(l)})\\). 定义2: PoW为(w,p,m)-feasible: P有内存m, 若p在\\([t_s, t_c]\\)时间内最多进行了w步, 且P能使V接收的概率至少为p. 定义3: 完备的PoW: 对于某个w, PoW 是(w,1,w)-feasible的. 若V的计算量大大少于P,则PoW为高效的, 且这种证明有很大的advantage. 定义4: 对于完备的PoW, w为满足 (w, 1, w)-feasible的最小值, z为V要进行的最大验证数量, 则PoW的 advantage 等于 w/z. 定义5: 两个PoW独立性的定义,略 定义6: 假设PoW1为(w,p)-hard, P1, V1分别为它的证明者了验证者. 假设P1同时也是PoW2的验证者(P1=V2), 若以下为真则PoW2为PoW1的bread pudding protocol: P1(V2) 接收PoW2, P1 可在PoW1中进行w个计算步骤并使V1接收PoW1的概率至少为: \\(p+1/poly(l)\\) ","date":"2022-11-26","objectID":"/posts/org_15_pow/:2:0","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#定义"},{"categories":["科研学习"],"content":"PoW例子 PIPOW: h为单向函数, V 生成长为l的随机二进制字符串x, x’为x的l-k位. V计算出y=h(x). V发送(x’, y)给P, 若要使PoW成功, P正确要计算出y的前向x. ","date":"2022-11-26","objectID":"/posts/org_15_pow/:2:1","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#pow例子"},{"categories":["科研学习"],"content":"Bread Pudding For MicroMint (这个是作者的一个例子, 将它提出的Bread Pudding应用在MicroMint中. Mint 在这里的意思为铸币的意思.) ","date":"2022-11-26","objectID":"/posts/org_15_pow/:3:0","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#bread-pudding-for-micromint"},{"categories":["科研学习"],"content":"MicroMint MicroMint是一个微支付系统, 铸币操作需要的边际成本较小,即铸币需要大量的基础硬件投资.假设hash函数h 将n位前象映射到n位的象中, 则要找到冲突即为将一个球随机地扔到2^n 个箱子中, 即给了h(x)找到x的概率为1/2^n. 若n太大,则维护2^n个箱子就需要太大的存储成本. 一个变体方案: 没大明白它的方案. ","date":"2022-11-26","objectID":"/posts/org_15_pow/:3:1","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#micromint"},{"categories":["科研学习"],"content":"Bread Pudding Minting 令h 为hash函数, || 为字符串连接操作, 将球定义为三元组: (i,x,y), y=h(r||i), r为secret value. 一个有效的ball为一个三元组,且当h(x||y) 中至少有t个重要位与s相等. 在该方案中, 验证者初始化PoW时发送(i,y)给证明者, 其中y=h(r||i), 并发送参数对(s,t)给证明者. 客户的任务为找到一个值x, 让它h(x||y) 的前t位与s相等, 即(i,x,y)是一个有效ball. ","date":"2022-11-26","objectID":"/posts/org_15_pow/:3:2","series":null,"tags":["论文阅读"],"title":"PROOFS OF WORK AND BREAD PUDDING PROTOCOLS (EXTENDED ABSTRACT)","uri":"/posts/org_15_pow/#bread-pudding-minting"},{"categories":["科研学习"],"content":"简单介绍 这是一篇最近NSDI上路径验证相关的论文.看了好几遍但还是没进脑子,因此在此总结一遍. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:1:0","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#简单介绍"},{"categories":["科研学习"],"content":"路径构建 终端主机如何根据AS的信息构造包的传输: 终端主机\\(H_S\\)首先从路径服务器中找到路径path(文中有个beacon的词,翻译为信标,估计跟路径差不多), 并将路径嵌入到数据包中,如下: \\[PACKET := (PATH || VALHD || P) \\tag{1}\\] \\[PATH := (TS_{path} || SRC || DEST || HI_1 || … || HI_l) \\] \\[VALHD := (ts_{pkt} || S_1 || V_1 || … || S_l || V_l || V_{SD})\\] 其中P表示数据包的负载, \\(SRC := (A_1 : H_S), DEST:=(A_l: H_D)\\). VALHD中为验证数据包所需要的一些域, \\(ts_{pkt}\\)为时间戳, \\(S_i\\) 为每一跳的验证加密码. \\(V_i\\) (HVF)为由源填充的加密标签,用于让中间路径验证数据包. 术语 hop field 指由跳信息 HI, 段识别 S 和跳验证域组成的三元组. 术语packet origin为h同源,路径时间戳,数据包时间戳组成的三元组: \\[PO:=(SRC, TS_{path}, ts_{pkt})\\] ","date":"2022-11-26","objectID":"/posts/org_14_epic/:1:1","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#路径构建"},{"categories":["科研学习"],"content":"TODO 文中的一些标记 ","date":"2022-11-26","objectID":"/posts/org_14_epic/:1:2","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#文中的一些标记"},{"categories":["科研学习"],"content":"TODO 全局对称密钥分布 每个AS怎么分配密钥的. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:1:3","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#全局对称密钥分布"},{"categories":["科研学习"],"content":"EPIC 协议 分为1-3级,安全性依次升高. 并使用0级作为最基础的方法. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:0","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#epic-协议"},{"categories":["科研学习"],"content":"L0: 路径授权 L0阶段使用静态消息验证码MAC作为跳验证HVF. 在路径探索阶段, AS A 首先计算跳验证器\\(\\sigma^{(0)}\\)作为MAC. 当前跳验证器与前一跳验证器\\(\\sigma^{(0)’}\\)的关系为(截断到\\(l_{val}\\)位): \\[\\sigma_A ^{(0)} := MAC_{K_A}(TS_{path} || HI_A || \\sigma^{(0)’})[0:l_{val}] \\tag{5}\\] 这个跳验证器直接用作HVF, 即\\(V_i^{(0)} = \\sigma_i^{(0)}\\), 初始化时没有前一跳,因此式中就不包函\\(\\sigma^{(0)’}\\). 数据包的创建与交付过程为: 源: HS 获得 path后, 按式(1) 构造包. 传输: 每一个\\(A_i\\), 它的边缘路由节点先检查HIi检查是否来自正确的接口并检查hop域是否过期，然后再重新计Vi并检查它是否与数据包头HVF中的相同。 ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:1","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#l0-路径授权"},{"categories":["科研学习"],"content":"L1: improved 路径授权 L0的不安全性分析: 假设每一跳的验证位长度为3字节, 则攻击者最多要发送 \\(2^{24} \\approx 1.6 \\cdot 10^7\\) 个数据包就可以找到这一跳的一个正确的MAC,这在一个Gb链路上大概要10s即可. 这种静态的MAC一旦被猜到后就可被利用来发送额外的数据包. L1中将静态跳验证替换为 per-packet HVFs, 这样它就无法被其他数据包重用了. 这时跳验证器的计算公式为: \\[\\sigma_A^{(1)}:=MAC_{K_A}(TS_{path}||HI_A||S^{(1)’}) \\tag{6}\\] 其中, \\(S^{(1)’}\\)为前一跳的段识别器, 通过截断跳验器来获得: \\[S^{(1)}:=\\sigma^{(1)}[0:l_{set}] \\tag{7}\\] 跳验证器会被源主机用于计算每个数据包的HVF: \\[V_i^{(1)} :=MAC_{\\sigma_i^{(1)}}(ts_{pkt}||SRC)[0:l_{val}] \\tag{8}\\] HVF通过式（8）计算，这使得每个包的HVF都是不相同的。S首先根据式（7）和式（8）计算构造HVF。当中间路由节点接收到包时先和L0一样验首接口和过期时间，它首先用式（6）计算跳数authenticator，再用式（7）计算它自己的段识别，再使用式（8）计算HVF，将算得的结果与包中的对比相同则交付包。 这里与L0不同的: L0中 每个数据包的HVF都是\\(\\sigma\\), 是相同的, 而这里的HVF在计算时使用了每个数据包的时间戳, 所以每个数据包验证时HVF都是不同的. 虽然每个HVF只能被一个包使用，但攻击者仍可利用它所知道的一些PVF或重用时间戳进行DoS攻击，但可以使用[29]中的方法解决这个问题。 ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:2","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#l1-improved-路径授权"},{"categories":["科研学习"],"content":"L2: 授权 相较于L1添加了由中间路由验证数据包的源和目的机制. 提出了主机密钥机制,计算方法为: 主机密钥: \\(K_i ^S:=K_{A_i \\rightarrow A_1:H_S}\\) 每一个中间AS \\(A_i\\)的额外密钥: \\(K_{SD}:=K_{A_l:H_D \\rightarrow A_1 : H_S}\\) 上面这两个密钥可以被用于计算带有源验证的HVF: \\[V_i^{(2)}:=MAC_{K_i^S}(ts_{pkt}||SRC||\\sigma_i)[0:l_{val}] \\tag{10}\\] 目的主机可授权数据包的源并对数据包的路径和负载的验证域: \\[V_{SD}^{(2)}:=MAC_{K_{SD}}(ts_{pkt}||PATH||P) \\tag{11}\\] 源需要获取所有host的key，在计算HVF时与L0和L1不同的是，它使用了主机key，见式（10），另外还计算了Vsd见式（11）。中间路由节点除要验证L1中验证的外，还需计算主机key并验证包头中的HVF是否与式（10）中的相符。目的主机获得Ksd并验证Vsd是否符合式（11）。 (这个L2相较于L1添加了源和目的验证, 本质上与L1区别不大,就是在验证域HVF的计算过程中添加了源和目的主机的key) ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:3","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#l2-授权"},{"categories":["科研学习"],"content":"L3: 终端主机路径验证 相较于L2: 允许数据包的源和目的进行路径验证. 每个中间AS接收到数据包后都对数据包的HVF进行了修改,当目的接收到包后便可基于验证域内容进行验证. 定义(其实就是未截断的式(10)): \\[C_i := MAC_{K_i^S}(ts_{pkt}||SRC||\\sigma_i) \\tag{12}\\] 我们可以将这个分成多块: \\[C_i^{[1]}:=C_i[0:l_{val}], C_i^{[2]}:=C_i[l_{val}:2l_{val}] \\tag{13}\\] 源为每个数据包的HVF设定:\\(V_{i;0}^{(3)}:=C_i^{[1]}\\). 当中间交换机\\(A_i\\)收到数据包后先计算\\(C_i\\),并验证HVF对不对,然后再更新HVF的验证域: \\(V_{i;i}^{(3)}:=C_i^{[2]}\\). 为使目的主机也能参与验证, 作者将最终值\\(V_{i;l}^{(3)}\\)放到目的验证域: \\[V_{SD}^{(3)}:=MAC_{K_{SD}}(ts_{pkt}||PATH||V_{1;l}^{(3)}||\\cdots ||V_{l;l}^{(3)}||P) \\tag{14}\\] ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:4","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#l3-终端主机路径验证"},{"categories":["科研学习"],"content":"L4: 在附录部分加了个L4. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:2:5","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#l4"},{"categories":["科研学习"],"content":"安全性分析 ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:0","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#安全性分析"},{"categories":["科研学习"],"content":"basic and strong attacker models basic-attacker model: Strong-Attacker Model: 定义一个神喻函数\\(\\mathcal{O}^{(l)}\\), 它可以从给定的PO和HI中产出有效的HVF \\(V_i\\)有段识别\\(S_i\\): \\(\\mathcal{O}(PO,HI_1,…,HI_l)=(V_1^{(l)},…,V_l^{(l)}, s_1^{(l)},…,S_l^{(l)}\\) 攻击者可以查询这个神喻函数并学习到\\(V_i,S_i\\).(\\(\\sigma_i,V_{SD}\\)不行). 这使得攻击者可以构造已有的数据包(无法构造不同的数据包). 这么作的攻击效果有限. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:1","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#basic-and-strong-attacker-models"},{"categories":["科研学习"],"content":"Low Risk of Forging Individual Packets 对前面攻击危害性不强一顿解释. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:2","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#low-risk-of-forging-individual-packets"},{"categories":["科研学习"],"content":"Path Authorization P1: 路径授权: 数据包在网络中传输只会沿着被路径上的诚实AS授权的路径进行. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:3","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#path-authorization"},{"categories":["科研学习"],"content":"Freshness P2: Freshness: 数据包被独一无二的识别, 无法被重放. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:4","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#freshness"},{"categories":["科研学习"],"content":"Packet and Source Authentication P3: Packet authentication for \\(H_D\\): 目的主机与源对数据包的源,路径,负载达成一致. P4: Source authenticaiton for router: 路径上的AS与源对packet origin达到一致. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:5","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#packet-and-source-authentication"},{"categories":["科研学习"],"content":"TODO Path Validation 这个先不管了, 这些分析不知道到底有啥用. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:3:6","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#path-validation"},{"categories":["科研学习"],"content":"实验部分 吞吐量: 图1:单核,不同负载尺寸下,源的吞吐量与路径长度的关系； 图7:不同的包负载尺寸,不同的核数时,源的性能(吞吐量,产量) 图8:单核,不同的包负载尺寸,不同的路径长度,源的处理时间. 图2: 路径长度为8时,不同的核心数的交付性能,可见当负载尺寸\u003e=500B时,4核,可以使40Gbps的链路饱和. 使用16核时可在负载尺寸为100B时使链路饱和. 图4:不同的交付任务,在不同的跳数情况下,路由的处理时间 图5: 在不同的跳数时,负载尺寸增加时路由的处理时间 图6:交付性能随核数的变化(由图4,5知交付性能与跳数和尺寸无关). 图3: 不同协议,不同的路径长度下,goodput ratio的变化； 表4: 不同协议 以及本方法不同等级时,所需要的额外不同头域大小. ","date":"2022-11-26","objectID":"/posts/org_14_epic/:4:0","series":null,"tags":["论文阅读"],"title":"EPIC: Every packet is checked in the data plane of a path-aware internet","uri":"/posts/org_14_epic/#实验部分"},{"categories":["额外学习"],"content":"马尔可夫过程 参考自这里 ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:0","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#马尔可夫过程"},{"categories":["额外学习"],"content":"性质(Markov Property) 马尔可夫性质指的是: 未来只与当前状态有关，与过去无关。可以使用以下定义: 可以从这个式子里面看到, 下一个状态为\\(S_{t+1}\\)的概率只于当前状态\\(S_t\\)有关, 而与更前的状态\\(S_1, S_2, …, S_{t-1}\\)都无关. 我们对当前状态和后续状态分别记为\\(s, s’\\), 从当前状态转移到后续状态的转移概率定义为: 对于一个马尔可夫过程如果有n个状态, 那这些状态互相转换则共有\\(n^2\\)种转移, 将这些转移过程记为一个转q称矩阵: ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:1","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#性质--markov-property"},{"categories":["额外学习"],"content":"马尔可夫过程 (Markov Process) 记一个随机过程中: S是有限数量的状态集 P是状态转移概率矩阵 它具有马尔可夫性质 转移概率不会随时间变化 则它是一个马尔可夫过程, 表示为\\(\u003cS,P\u003e\\). 以下例子: 一个学生所处状态的随机过程 这里每一个球就是随机过程中的一个状态, 箭头表示状态转移, 箭头上的数字表示转移概率. 比如学生在Facebook这个状态, 那他有10%的概率会去Class 1 学习, 90%的概率会继续玩Facebook. 以下是可能的状态转移过程: C1 - C2 - C3 - Pass - Sleep C1 - FB - FB - C1 - C2 - Sleep C1 - C2 - C3 - Pub - C2 - C3 - Pass - Sleep C1 - FB - FB - C1 - C2 - C3 - Pub - C1 - FB - FB - FB - C1 - C2 - C3 - Pub - C2 - Sleep 这个随机过程的转移概率矩阵为: ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:2","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#马尔可夫过程--markov-process"},{"categories":["额外学习"],"content":"马尔可夫奖励过程(Markov reward process) 这部分的题目比上部分多了一个奖励, 因此内容上也一下, 和马尔可夫随机过程相比,我们在每一个状态上添加一个奖励. 先摆上给每个状态添加奖励后的随机过程的一个图示: 马尔可夫奖励过程表示为: \\(\u003cS,P,R,\\gamma\u003e\\) S是有限数量的状态集 P是状态转移概率矩阵 R是一个奖励函数，\\( R_{s} = E[R_{t+1} | S_{t} = s] \\) \\(\\gamma\\)是一个折扣因子， 其取值范围为: [0, 1] ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:3","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#马尔可夫奖励过程--markov-reward-process"},{"categories":["额外学习"],"content":"奖励函数 离开当前状态所获得的奖励,记为\\(R\\). 用上面的图举个例子, 假如学生当前在状态Class 1, 此时他即可能进入Class 2, 也可能进入facebook, 不管他下一个状态进入的是哪个, 他离开Class 1状态都会获得 -2 的奖励, 也就是进入下一个状态时, 会获得本状态的奖励. ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:4","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#奖励函数"},{"categories":["额外学习"],"content":"折扣因子 折扣因子记为 \\(\\gamma \\in [0,1]\\), 当我们用它来计算未来收益时会乘以折扣因子, 比如在Class 1 进入facebook和进入 Class 2后虽然当前的收益是相同的, 但未来收益是不同的. 引入折扣因子的原因: 首先，数学上的方便表示，在带环的马尔可夫过程中，可以避免陷入无限循环，达到收敛。 其次，随着时间的推移，远期利益的不确定性越来越大，符合人类对于眼前利益的追求。 再次，在金融上，近期的奖励可能比远期的奖励获得更多的利息，越早获得奖励，收益越高. ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:5","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#折扣因子"},{"categories":["额外学习"],"content":"收益 (Return) 定义为: 从当前时刻起经达 k+1 时间步骤后获得的带折扣奖励总和, 即: 例个例子: 在这个马尔可夫过程中, 各状态奖励为: 因此对于采样获得的马尔可夫链能获得的收益为: ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:6","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#收益--return"},{"categories":["额外学习"],"content":"价值函数(state-value function) 从该状态s开始的回报的期望, 它表达的是某一状态的长期价值, 记为\\(V(s)\\), 表达式为: 比如对于如下马尔可夫过程: 我们将每个状态价值函数的初始值设为0 FB状态时，有0.9的概率进入FB,0.1的概率进入到C1，因此 Pub状态时，有0.2的概率进入C1,0.4的概率进入到C2，0.4概率进入C3，因此 同理,其他状态价值函数: 根据上面公式，进行迭代计算V值。各状态的初始V值都设0，算出各状态的后续状态的V(S’)值, 再将算得的V(S’) 作为下一个状态的初始值V(S). 因此可得: 如此下去,直到稳定. ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:7","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#价值函数--state-value-function"},{"categories":["额外学习"],"content":"MRP的贝尔曼方程（Bellman Equation for MRPs） 推导过程就不列了, 涉及到了不大懂的知识, 将最终的方程列一下: 这个式子还是很好理解的,结合前面的例子,当前状态的收益为当前状态的价值+\\(\\sum\\)下一个状态的转移概率X下一个状态的价值 X \\(\\gamma\\). 可以用下面这个图形来解释: 它还有矩阵形式, 就不列了, 这里的用处不大, 原博客上都有 ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:8","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#mrp的贝尔曼方程-bellman-equation-for-mrps"},{"categories":["额外学习"],"content":"马尔可夫决策过程（Markov decision process） 马尔可夫决策过程是在马尔可夫奖励过程的基础上加入了动作, 定义为: \\(\u003cS,A,P,R,\\gamma\u003e\\) 马尔可夫决策过程的状态转移概率和奖励函数不仅取决于智能体当前状体，还取决于智能体选取的动作, 而马尔可夫奖励过程仅取决于当前状态。 ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:9","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#马尔可夫决策过程-markov-decision-process"},{"categories":["额外学习"],"content":"策略 (Policy) 它是一个对于给定状态s时, 其动作a的分布, 记为: 它定义了智能体的行为方式, 即各种状态下采取各种动作的概率(采取不同的动作即会转移到不同的状态) MDP的策略仅与当前的状态有关，与历史信息无关；同时某一确定的策略是静态的，与时间无关；但是个体可以随着时间更新策略。 由于状态转移会与不同的策略有关, 因此某个状态的收益也与策略有关. ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:10","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#策略--policy"},{"categories":["额外学习"],"content":"价值函数 (Value Function） ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:11","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#价值函数-value-function"},{"categories":["额外学习"],"content":"贝尔曼期望方程（Bellman Expectation Equation） ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:12","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#贝尔曼期望方程-bellman-expectation-equation"},{"categories":["额外学习"],"content":"备份图（backup diagram） ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:13","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#备份图-backup-diagram"},{"categories":["额外学习"],"content":"最优价值函数（Optimal Value Function） ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:14","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#最优价值函数-optimal-value-function"},{"categories":["额外学习"],"content":"贝尔曼最优方程（Bellman Optimality Equation） ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:15","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#贝尔曼最优方程-bellman-optimality-equation"},{"categories":["额外学习"],"content":"马尔可夫决策过程的扩展 其他类别的MDP有：无限状态和连续MDP；部分可观测MDP；不带折扣的、平均奖励MDP等 ","date":"2022-10-04","objectID":"/posts/org_13_markon_decision/:1:16","series":null,"tags":["数学"],"title":"马尔可夫决策过程 (Markov decision processes,MDP)","uri":"/posts/org_13_markon_decision/#马尔可夫决策过程的扩展"},{"categories":["额外学习"],"content":"霍夫丁不等式表达 下面的这个式子是我们常用的 ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:1:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#霍夫丁不等式表达"},{"categories":["额外学习"],"content":"Markov inequality 一个取值非负的随机变量\\(X \\ge 0\\), 有不等式 \\(P(X \\ge \\epsilon) \\le \\frac{1}{\\epsilon} \\mathbb{E}X\\). 这个不等式的证明: 过程中使用了微积分和一些不等式的基础, 不了解了. ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:2:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#markov-inequality"},{"categories":["额外学习"],"content":"Jesen inequality 对于突函数而言的一个不等式 ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:3:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#jesen-inequality"},{"categories":["额外学习"],"content":"均值不等式 这里使用的其实是对\\((a - b)^2 \\ge 0\\)的变换, 最终得到\\((a+b)^2 \\ge 2 \\sqrt{ab}\\). ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:4:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#均值不等式"},{"categories":["额外学习"],"content":"霍夫丁不等式的证明 首先使用\\(Y_i = X_i - \\mathbb{E}_i\\) 来替换原不等式, 得到新的需要证明的式子: 这里变换后\\(Y_i\\)的聚会范围变了, 我们设它的聚会范围为: \\(a_i \\le Y_i \\le b_i\\) 这里要对上面方框中的式子使用马尔可夫不等式来放缩,但由于我们并不能保证 \\(\\sum Y_i \\ge 0\\), 因此使用e的指数对原式进行变换, 结果如下: 这里由于\\(Y_i\\) 是独立同分布的, 因此可以做变换 \\(e^{-t\\epsilon} \\cdot \\mathbb{E}[e^{t \\sum Y_i}] = e^{-t \\epsilon} \\cdot \\prod \\mathbb{E}[e^{t Y_i}]\\) 根据\\(Y_i\\)的取值范围, 我们利用\\(\\alpha\\)来修改\\(Y_i\\)的表达: 再将修改后的表达带入\\(e^{tY_i}\\) 得: 这里使用了杰森不等式进行了缩放 所以利用杰森不等式和\\(\\alpha\\)的缩放, 我们可以对\\(\\mathbb{E}[e^{tY_i}]\\)进行缩放得下式(记为*): 这里引入两个变量\\(\\mu, \\gamma\\) 再将这两个变量带t主(*)式得: 此时再将变换后的(*)式取对数,并记为\\(g(u)\\)得如下式: 此时我们想对\\(g(u)\\)在0处进行泰勒展开, 所以我们对它进行求导再计算其自变量为0时的值, 在其二次导入使用均值不等式进行缩放,计算如下: 此时对\\(g(u)\\)进行泰勒展开,借助拉格朗日余项得: 这里的缩放利用了上面二次导的缩放. 我们获得了\\(g(u)\\)的界, 根据\\(g(u)\\)的定义以及(*)式, 我们可以得到: 此时再带入最被的式子可以得到\\(P(\\sum Y_i \\ge \\epsilon)\\)的一个不等式: 上式的右侧是一个关于t的二次函数, 因此对右侧取\\(t \u003e 0\\)时的最小值可得: 得证. 将上式还原成\\(X_i\\)的形式即可得到最原始的霍夫丁不等式. 以上参考自: 参考链接 ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:5:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#霍夫丁不等式的证明"},{"categories":["额外学习"],"content":"将霍夫丁不等式应用在伯努利两点分布的特例 有独立随机变量服从伯努利分布, 即某个变量取1时概率为p, 取0时概率为(1-p), 则它满足的霍夫丁不等式如下: 上式其实表达的是均值依概率收敛于p 对于不等式中的绝对值展开成两部分 先看正的部分, 原式展开并带入霍夫丁不等式即得: 再看负的部分: 令\\(Y_i = - X_i\\) 并替换原式可得: 所以将两个式子合在一起就得到了 原来的不等式证明. ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:6:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#将霍夫丁不等式应用在伯努利两点分布的特例"},{"categories":["额外学习"],"content":"论文中涉及到的 ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:7:0","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#论文中涉及到的"},{"categories":["额外学习"],"content":"ShortMAC: Efficient Data-Plane Fault Localization, NDSS 论文中的引理一: 恶意交换机注入一个数据包会被检测到的概率为q, 设一个阈值\\(T_{in}\\). 若要保证被检测到的包数少于域值\\(T_{in}\\)的概率不多于\\(\\delta\\), 那么恶意交换机注入的包数不多于: 完整描述如下: 给定的证明如下: 照原文的说法, FN的概率 \\(\\mathbb{P}_{fn} = \\mathbb{P}(C_{m+1}^{bad} \u003c T_{in})\\), 即被检测到的数量未到达阈值. 这里我按照我的理解推导了一下式(6), 首先建模为伯努利, 记注入的数据包为随机变量\\(X_1, X_2, …, X_y\\), 被检测到的概率为q, 所以这里记随机变量\\(X_i\\)为1的概率为q. y个这样的随机变量出现1的次数小于阈值的概率即为式(6)中的FN概率, 表达如下: \\[P(C_{m+1} ^{bad} \u003c T_{in}) = P(\\sum X_i \u003c T_{in})\\] 文中提取了利用霍夫丁不等式, 因此我们把上式右侧做些变换: \\(P(\\sum X_i \u003c T_{in}) \\) \\(= P(\\sum X_i - qy\u003c T_{in} - qy )\\) \\(= P(\\sum (X_i - q) \u003c T_{in} - qy )\\) \\(= P(\\sum (X_i - q) \u003c -(-T_{in} + qy ))\\) 在上面这个式子中, 由于这是一个伯努利分布, 因此\\(q=\\mathbb{E}X_i\\), 所以它已经符合霍夫丁不等式的形式, 其中\\(-T_{in} + qy\\)即为\\(\\epsilon\\), 因此利用这个不等式算这个概率的上界: \\( P(\\sum (X_i - q) \u003c -(-T_{in} + qy ))\\) \\(= exp(- \\frac{2(qy - T_{in})^2}{\\sum 1^2})\\) \\(=exp(-\\frac{2}{y} (qy - T_{in})^2)\\) \\(=exp(-2y (q - \\frac{T_{in}}{y})^2)\\) 可以看到这里的结果比式(6)少了一个2倍, 不知道是谁的公式出了问题 . ","date":"2022-09-26","objectID":"/posts/org_12_hoeffding_ineq/:7:1","series":null,"tags":["数学"],"title":"Hoeffding's inequality (霍夫丁不等式讲解)","uri":"/posts/org_12_hoeffding_ineq/#shortmac-efficient-data-plane-fault-localization-ndss"},{"categories":["实验"],"content":"版本及环境 ovs 2.13.7 ubuntu 18.04 与前一篇ovs安装的环境一致，里面所提及的脚本本篇也会用到 看这篇需要有一定的OVS基础，基本概念必须要了解。 ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:1:0","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#版本及环境"},{"categories":["实验"],"content":"基本概念 这里讲的action并不是openflow action, 而是数据平面的执行action OVS中流主要从两个部分转发：内核空间和用户空间 内核空间主要是通过缓存的流表转发流，若在缓存流表中未找到，则到用户空间的完整流表中找。 用户空间对于匹配的流会添加一份缓存到内核空间的流表中; 若用户空间的完整流表也没有匹配的，就把这个数据包的相关信息发到控制器。 一个OpenFlow flow有两部分的组成：match, action match用于匹配到达的数据包，action是对匹配到的数据包执行相应的动作 下面这个图是流表的例子 下图为已有的一些action 为什么需要自定义action: 当然是已有的满足不了需求了！！！ ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:2:0","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#基本概念"},{"categories":["实验"],"content":"基本步骤 先在OVS社区进行讨论（挺难找的） 在ofp-action.c中添加新的action代码 添加parse/encode/decode代码，这是为了使ovs-ofctl和控制器使用新加的action 在内核datapath部分实现新加的action 在ovs-vswitchd中添加action的用户层面实现 将action翻译到datapath ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:3:0","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#基本步骤"},{"categories":["实验"],"content":"流表的添加过程概述 对于下面这个流表 它的添加过程为： 控制平面（控制器，还有在mininet中的操作命令行中） 我们的流表字符串会被先编码为ofpacts 再将ofpacts编码为OpenFlow actions 将flow_mod 消息发送到ovs-vswitchd 数据平面： 将OpenFlow actions 解码为 ofpacts 把flow放到交换机的规则分类器中（这里要表达的意思其实是：把转换后的ofpacts放到流表中，当有数据包来了后就会进行流表匹配） ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:4:0","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#流表的添加过程概述"},{"categories":["实验"],"content":"自定义action代码实现 ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:0","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#自定义action代码实现"},{"categories":["实验"],"content":"一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。 enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错. include/openvswitch/ofp-actions.h 中添加定义 OFPACT(GOTO_TABLE, ofpact_goto_table, ofpact, \"goto_table\") \\ OFPACT(PVL, ofpact_pvl, ofpact, \"pvl\") //这行是我们的，注释删掉 找到文件中代码对应的位置，添加一行我们自定义的pvl 结合/include/openvswitch/ofp-actions.h 中关于`#define OFPACTS` 的宏定义看,每添加一行OFPACT编译器会根据宏定义添加大量的处理函数；结合/include/openvswitch/ofp-actionsh.h中关于enum OVS_PACKED_ENUM ofpact_type来看,每添加一行OFPACT会给这个枚举类型添加一项. 因为C中没有类这个概念，当新添加一个行为是，对应的行为属性其实是通过宏定义这个方式来实现的。 include/openvswitch/ofp-actions.h 中添加代码 // 在 struct ofpact_goto_table 后面添加 /* OFPACT_PVL. * * Used for OFPAT_PVL */ struct ofpact_pvl { OFPACT_PADDED_MEMBERS( struct ofpact ofpact; uint32_t command; /* command from the controller */ ); uint8_t data[]; }; 这里面其实定义了新action中所需要的参数。 datapath/linux/compat/include/linux/openvswitch.h:中添加代码： //在 enum ovs_action_attr { 中添加代码 OVS_ACTION_ATTR_PVL = 29, /* unit32_t */ //这行是我们的，本注释删掉 __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted * from userspace. */ 这里需要对新添加的类型定义显式的值，否则可能会出错 这部份代码是内核层的定义，这个枚举类型里有所有的action,当datapath要执行哪个action时,会有for循环轮每个action, 再用switch case语句直接跳到对应的action中进行执行. ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:1","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#一-添加-action-定义--openflow"},{"categories":["实验"],"content":"一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。 enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错. include/openvswitch/ofp-actions.h 中添加定义 OFPACT(GOTO_TABLE, ofpact_goto_table, ofpact, \"goto_table\") \\ OFPACT(PVL, ofpact_pvl, ofpact, \"pvl\") //这行是我们的，注释删掉 找到文件中代码对应的位置，添加一行我们自定义的pvl 结合/include/openvswitch/ofp-actions.h 中关于`#define OFPACTS` 的宏定义看,每添加一行OFPACT编译器会根据宏定义添加大量的处理函数；结合/include/openvswitch/ofp-actionsh.h中关于enum OVS_PACKED_ENUM ofpact_type来看,每添加一行OFPACT会给这个枚举类型添加一项. 因为C中没有类这个概念，当新添加一个行为是，对应的行为属性其实是通过宏定义这个方式来实现的。 include/openvswitch/ofp-actions.h 中添加代码 // 在 struct ofpact_goto_table 后面添加 /* OFPACT_PVL. * * Used for OFPAT_PVL */ struct ofpact_pvl { OFPACT_PADDED_MEMBERS( struct ofpact ofpact; uint32_t command; /* command from the controller */ ); uint8_t data[]; }; 这里面其实定义了新action中所需要的参数。 datapath/linux/compat/include/linux/openvswitch.h:中添加代码： //在 enum ovs_action_attr { 中添加代码 OVS_ACTION_ATTR_PVL = 29, /* unit32_t */ //这行是我们的，本注释删掉 __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted * from userspace. */ 这里需要对新添加的类型定义显式的值，否则可能会出错 这部份代码是内核层的定义，这个枚举类型里有所有的action,当datapath要执行哪个action时,会有for循环轮每个action, 再用switch case语句直接跳到对应的action中进行执行. ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:1","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#lib-ofp-actions-dot-c中添加代码"},{"categories":["实验"],"content":"一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。 enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错. include/openvswitch/ofp-actions.h 中添加定义 OFPACT(GOTO_TABLE, ofpact_goto_table, ofpact, \"goto_table\") \\ OFPACT(PVL, ofpact_pvl, ofpact, \"pvl\") //这行是我们的，注释删掉 找到文件中代码对应的位置，添加一行我们自定义的pvl 结合/include/openvswitch/ofp-actions.h 中关于`#define OFPACTS` 的宏定义看,每添加一行OFPACT编译器会根据宏定义添加大量的处理函数；结合/include/openvswitch/ofp-actionsh.h中关于enum OVS_PACKED_ENUM ofpact_type来看,每添加一行OFPACT会给这个枚举类型添加一项. 因为C中没有类这个概念，当新添加一个行为是，对应的行为属性其实是通过宏定义这个方式来实现的。 include/openvswitch/ofp-actions.h 中添加代码 // 在 struct ofpact_goto_table 后面添加 /* OFPACT_PVL. * * Used for OFPAT_PVL */ struct ofpact_pvl { OFPACT_PADDED_MEMBERS( struct ofpact ofpact; uint32_t command; /* command from the controller */ ); uint8_t data[]; }; 这里面其实定义了新action中所需要的参数。 datapath/linux/compat/include/linux/openvswitch.h:中添加代码： //在 enum ovs_action_attr { 中添加代码 OVS_ACTION_ATTR_PVL = 29, /* unit32_t */ //这行是我们的，本注释删掉 __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted * from userspace. */ 这里需要对新添加的类型定义显式的值，否则可能会出错 这部份代码是内核层的定义，这个枚举类型里有所有的action,当datapath要执行哪个action时,会有for循环轮每个action, 再用switch case语句直接跳到对应的action中进行执行. ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:1","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#include-openvswitch-ofp-actions-dot-h-中添加定义"},{"categories":["实验"],"content":"一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。 enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错. include/openvswitch/ofp-actions.h 中添加定义 OFPACT(GOTO_TABLE, ofpact_goto_table, ofpact, \"goto_table\") \\ OFPACT(PVL, ofpact_pvl, ofpact, \"pvl\") //这行是我们的，注释删掉 找到文件中代码对应的位置，添加一行我们自定义的pvl 结合/include/openvswitch/ofp-actions.h 中关于`#define OFPACTS` 的宏定义看,每添加一行OFPACT编译器会根据宏定义添加大量的处理函数；结合/include/openvswitch/ofp-actionsh.h中关于enum OVS_PACKED_ENUM ofpact_type来看,每添加一行OFPACT会给这个枚举类型添加一项. 因为C中没有类这个概念，当新添加一个行为是，对应的行为属性其实是通过宏定义这个方式来实现的。 include/openvswitch/ofp-actions.h 中添加代码 // 在 struct ofpact_goto_table 后面添加 /* OFPACT_PVL. * * Used for OFPAT_PVL */ struct ofpact_pvl { OFPACT_PADDED_MEMBERS( struct ofpact ofpact; uint32_t command; /* command from the controller */ ); uint8_t data[]; }; 这里面其实定义了新action中所需要的参数。 datapath/linux/compat/include/linux/openvswitch.h:中添加代码： //在 enum ovs_action_attr { 中添加代码 OVS_ACTION_ATTR_PVL = 29, /* unit32_t */ //这行是我们的，本注释删掉 __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted * from userspace. */ 这里需要对新添加的类型定义显式的值，否则可能会出错 这部份代码是内核层的定义，这个枚举类型里有所有的action,当datapath要执行哪个action时,会有for循环轮每个action, 再用switch case语句直接跳到对应的action中进行执行. ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:1","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#include-openvswitch-ofp-actions-dot-h-中添加代码"},{"categories":["实验"],"content":"一、添加 action 定义(OpenFlow) lib/ofp-actions.c中添加代码 这里添加我们自定义action的名字，这个名字是OpenFlow action的名字，它并不是OVS action的名字。OpenFlow action 需要解码才可转换为 OVS action。 enum ofp_raw_action_type { /* ... */ /* NX1.3+(47): struct nx_action_decap, ... */ NXAST_RAW_DECAP, /* OF1.0+(30): uint32_t. */ OFPAT_RAW_PVL, //这行是我们的，注释删掉 /* NX1.3+(48): void. */ NXAST_RAW_DEC_NSH_TTL, /* ... */ } 这里的注释 * OF1.0+(30): uint32_t. * 是必要的，它声明了OF消息的类型，序号以及构造OF消息所需要的参数，ovs会根据这里声明的类型在编译时会在/lib/ofp-actions.inc2这个文件里按put_OFAT_##ENUM的形式自动生成函数,这里生成的函数名为put_OFAT_PVL, 这个函数的第一个参数是 ofpbuf *, 其他的参数为注释中指定的参数(指定为void时则只有一个参数),因此未按指定格式注释会出错. include/openvswitch/ofp-actions.h 中添加定义 OFPACT(GOTO_TABLE, ofpact_goto_table, ofpact, \"goto_table\") \\ OFPACT(PVL, ofpact_pvl, ofpact, \"pvl\") //这行是我们的，注释删掉 找到文件中代码对应的位置，添加一行我们自定义的pvl 结合/include/openvswitch/ofp-actions.h 中关于`#define OFPACTS` 的宏定义看,每添加一行OFPACT编译器会根据宏定义添加大量的处理函数；结合/include/openvswitch/ofp-actionsh.h中关于enum OVS_PACKED_ENUM ofpact_type来看,每添加一行OFPACT会给这个枚举类型添加一项. 因为C中没有类这个概念，当新添加一个行为是，对应的行为属性其实是通过宏定义这个方式来实现的。 include/openvswitch/ofp-actions.h 中添加代码 // 在 struct ofpact_goto_table 后面添加 /* OFPACT_PVL. * * Used for OFPAT_PVL */ struct ofpact_pvl { OFPACT_PADDED_MEMBERS( struct ofpact ofpact; uint32_t command; /* command from the controller */ ); uint8_t data[]; }; 这里面其实定义了新action中所需要的参数。 datapath/linux/compat/include/linux/openvswitch.h:中添加代码： //在 enum ovs_action_attr { 中添加代码 OVS_ACTION_ATTR_PVL = 29, /* unit32_t */ //这行是我们的，本注释删掉 __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted * from userspace. */ 这里需要对新添加的类型定义显式的值，否则可能会出错 这部份代码是内核层的定义，这个枚举类型里有所有的action,当datapath要执行哪个action时,会有for循环轮每个action, 再用switch case语句直接跳到对应的action中进行执行. ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:1","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#datapath-linux-compat-include-linux-openvswitch-dot-h-中添加代码"},{"categories":["实验"],"content":"二、parse，encode和decode 这步的目的是为了ovs-ofctl和控制器能够使用我们新添加的action ","date":"2022-09-19","objectID":"/posts/org_11_ovs_add_action/:5:2","series":null,"tags":["ovs"],"title":"OVS添加自定义action","uri":"/posts/org_11_ovs_add_action/#二-parse-encode和decode"},{"categories":["科研学习"],"content":"affliation and publication author: publication: 本文主要 SDN 中详细调研当前拓扑发现服务的解决办法和缺点 ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:0:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#"},{"categories":["科研学习"],"content":"Abstract ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:1:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#abstract"},{"categories":["科研学习"],"content":"Intro ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:2:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#intro"},{"categories":["科研学习"],"content":"Preliminary Knowledge ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:3:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#preliminary-knowledge"},{"categories":["科研学习"],"content":"LLDP 协议 Link Layer Discovery Protocal,详细解释了LLDP包每个字段的作用,但我并没有看懂 ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:3:1","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#lldp-协议"},{"categories":["科研学习"],"content":"Topology Discovery 拓扑发现:物理层拓扑可以帮我们了解节点分布和节点连接,逻辑拓扑可以帮我们了解设备之间的数据流 ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:4:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#topology-discovery"},{"categories":["科研学习"],"content":"Discoery Topology in single-domain networks ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:5:0","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#discoery-topology-in-single-domain-networks"},{"categories":["科研学习"],"content":"Network with only OpenFlow switches 支持OF的交换机有两个特性: 1. 设置了连接控制器的端口；2. 有流表将包通过packetIn发到控制器. 控制器向每个交换机发个packetOut,并把LLDP包放里面, LLDP包的目的MAC为广播地址.交换机收到LLDP包后将其转发给所有的邻居交换机.邻居交换机收到LLDP发现不地从控制器来在,就将该LLDP包通过PacketIn发给控制器,这时LLDP包的元数据中已有了一些交换机制基本信息,如交换机ID, 交换机端口号. 信息交换过程见图5, 代价:生成packetIn包数为2倍链路数,在\\[6\\]中有改进,缺点:只能发现相邻交换机. ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:5:1","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#network-with-only-openflow-switches"},{"categories":["科研学习"],"content":"Network with Traditional and Openflow Switches 控制器要发现所有OF交换机之间的连接, 直接的或间接的(两个OF交换机中间隔了传统交换机). 当前使用2层组合拓扑发现协议进行拓扑发现即LLDp包和BDDP包, BDDP包与LLDP包不同之处为 目的地地址为广播而不是多播； EtherType为0x8999. 使用方法:控制器通过向OF交换机的每个输出端口发送BDDP包并下发匹配流表,OF 交换机收到则匹配EtherType 0x8999并返回给控制器, 此时BDDP包中与LLDP包相同有着交换机的一些信息. 传统交换机则会广播最终播给OF交换机.图6为信息交换过程. 缺点: 当前无标准. 耗资源. ","date":"2022-09-16","objectID":"/posts/org_10_topo_discover/:5:2","series":null,"tags":["论文阅读"],"title":"Current Trends of Discovery Topology in SDN","uri":"/posts/org_10_topo_discover/#network-with-traditional-and-openflow-switches"},{"categories":["科研学习"],"content":"affliation and publication author: Qi Li, XiaoyueZou, Qun Huang, Jing Zheng, Patrick P.C.Lee publication: IEEE Transactions on Dependable and secure computing, 2019 abs 传统方法无法应用到SDN中的原因: SDN 中的交换机功能太少. 作者提出: 使用控制器收集包和流的统计来判定包是否被修改, 交付路径是否正常; 并对该方法加以改进 与我的不同点: N-pfv中每一个包都要利用packetIn送到控制器进行完整性检测, 应该不可取 每个rule 都有一个timer, 如何在数据平面利用过期的包触发控制平面对path的完整性检测呢? 每个rule结束时都会有一个统计请求. 对每个流都要有一个hash表(\\(P_i\\)表). 抽样检测中如何使egress对ingress相同的抽样出来的包进行packetIn? 若使用流表的过期时间控制, 那就得不停地下发流表. (是我当时没看懂, 使用流表控制packetIn, 用概率参数\\(\\lambda\\)确定当前是否下发流表, 不下发就会有packetIn, 下发就没有) 使用的工具,或许有用: CAIDA数据集 拓扑 用于模仿dropping攻击的ovs-ofctl tool 用于模仿injection攻击的TCPreply ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:0:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#"},{"categories":["科研学习"],"content":"Introduction p1: 指出交付异常检测的重要性 p2: IP网的解决办法,不足及为何不可用于SDN p3: 提出一个方法, 并用其有可行性引出challenge p4: 本文的方法及贡献 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:1:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#introduction"},{"categories":["科研学习"],"content":"Problem Statement ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:2:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#problem-statement"},{"categories":["科研学习"],"content":"Basic of SDN ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:2:1","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#basic-of-sdn"},{"categories":["科研学习"],"content":"Threat Model packet hijacking attacks. 对包改路 packet delaying attacks. 延迟 packet injection attacks. 攻击者向流中加入包 packet dropping attacks. 丢流流的包 packet tempering attacks. 修改包 hybrid attacks. 丢一些包再复制或注入同等数量的包 表1 是对当前研究方法对这些问题的解决情况: 本段剩余内容: 分析已存在方法且无法用于SDN; 本文要解决的问题及假设. ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:2:2","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#threat-model"},{"categories":["科研学习"],"content":"Packet Forwarding verification ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:3:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#packet-forwarding-verification"},{"categories":["科研学习"],"content":"Design goals ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:3:1","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#design-goals"},{"categories":["科研学习"],"content":"Novel Packet Forwarding Verification (\\(\\mathcal{N}\\)-PFV) 当包在进和出交换机时都生成 packetIn 包以确定交有没有修改；控制器定时检查包的统计信息以确定包是否交付异常. 因此产生了2个问题: 如何交付包到控制器 中间节点何时报告统计信息 文中使用的标记见表2 PFV的整体overview见图2: PFV 算法见算法1 \\(N\\)-PFV作为NOS的一个模块运行在控制器中, 算法 1 中1-12行为NFV验证包的完整性. 对每个从ingress来的包计算它的Message Authentication Code (MAC), 并将其存入一个hash表中(每个项都有超期时间) 对从egress来的包计算它的MAC, 并从hash表中将对应的删除并增加已验证包的计数\\(\\delta_i\\) 如果从egress的MAC无法与hash表中的匹配,定位这个交换机 7-9 若被匹配的包与总的hash个数之比小于\\(\\theta\\), 验证失败, 定位恶意交换机 10-19 当rule过期, 就检查数据平面这个rule对应所有流表的连续性, 以确定当前攻击. 不同: 每个rule都有一个timer; 每个rule最终都会触发一次流状态请求 图2中的例子中,从A中进入的包会触发packetIn, 从C中出去的包也会.若最后2个PacketIn包相等则通过验证,否则让B生成PacketIn, 若此时相等则证明链路B-C安全. 若控制器中有rule过期则收集ABC的流表并比较. 如图2中可见B有恶意行为因为他的统计信息比A少. 若此时控制器中没有MAC过期则 packet hyjacking, 否则 dropping. 可见PFV可以有效地定位恶意交换机. ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:3:2","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#novel-packet-forwarding-verification--mathcal-n-pfv"},{"categories":["科研学习"],"content":"Discussion ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:3:3","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#discussion"},{"categories":["科研学习"],"content":"Enhanced PFV: DynaPFV DynaPFV 通过随机抽取flow中的包并生成packetIn来降低检测代价。当收到packetIn包时以概率\\(\\lambda\\)确定下一个包是继续检测完整性还是下发流表. DynaPFV过程见算法2， 若收到packetIn包或所保存的hash中有过期的，则以一定的概率进行包完整性检查。若检查，下发检查流表（会触发packetIn）否则下发随机过期时间的流表（流表过期会触发行为检查）。 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:4:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#enhanced-pfv-dpfv"},{"categories":["科研学习"],"content":"Dynamic Packet Verific ation 具体算法过程可见算法3. 当从ingress中收到某个流\\(f_i\\)的PacketIn包时, 就为它计算MAC并将其存入hash表\\(\\mathcal{P}_i\\)中. 当从egress中收到时就计算MAC并从对应的hash表中移除并增加验证成功包的计数. 每次移除都降低抽样概率\\(\\lambda = \\lambda * \\alpha\\), 若有MAC过期则增加抽样概率\\(\\lambda = \\frac{\\lambda + 1}{2}\\). 若匹配包数与总包数之比小于\\(\\theta\\)则认为异常从而定位异常交换机. 此外初始值设定\\(\\lambda = 1, \\alpha = 0.99\\). 最后用图3来说明对上述过程举例. ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:4:1","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#dynamic-packet-verific"},{"categories":["科研学习"],"content":"Dynamic Behavior Verification 下发流表的过期时间是随机的,流表过期会触发行为检查,因此检查的间隔也是随机的.检查过程如算法4所示: 对path上的交换机处理的包进行统计, 并都与ingress交换机的统计结果求比值, 中间交换机直接统计, egress交换机则为统计结果加检查的包数\\(S_i[0] + sizeof(\\mathcal{P}_i + \\sigma _i)\\). 比值大于\\(\\theta\\)但小于1则提高抽样概率\\(\\lambda\\), 否则减小\\(\\lambda\\). 最后清空\\(\\delta_i\\)和hash表, 并更新\\(\\sigma_i\\) ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:4:2","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#dynamic-behavior-verification"},{"categories":["科研学习"],"content":"Analysis ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:5:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#analysis"},{"categories":["科研学习"],"content":"Detection Effectiveness Analysis 检测效果与\\(\\lambda\\)有关, 未检测到的包序列取决与一个过期时间, 通过离散包序列, 未检测包序列的长度有限,可记为{1,2,…,n}, 因此我们可以将未检测的包序列建模为马尔可夫链, 未检测到的包序列升序服从于{1,2,…,n}中的一个正态分布. 本节将数据包与其剩余未检测序列的包数相对应, 当一个包被随机选中检测则认为剩余未检测序列的包数为0. 记\\(X(t)\\)为:当第t个包到达时该序列剩余的包数, 因此\\(X(t)\\)是一个随机变量. 我们可发现: \\(X(t+1)\\)只取决于\\(X(t)\\) 若\\(X(t)\\)非0, 则\\(X(t+1)=X(t)-1\\) \\(X(t+1)\\)以\\(\\lambda\\)的概率为0, 或以\\(1-\\lambda\\)的概率服从均匀分布:{1,2,…,n} 由一, \\(\\{X(t)\\}\\)形成一个有n+1个状态{0,1,…,n}的马尔可夫链. 记\\(p_{k}(t)\\)为\\(X(t) = k\\)的概率, 则\\(X(t+1)=0\\)的概率为\\(X(t)\\)为0且以\\(\\lambda\\)触发或\\(X(t)=1\\), 因此可得: \\begin{equation} p_0(t+1) = \\lambda p_0(t) + p_1(t) \\tag{1} \\end{equation} 同理,\\(X(t+1)=k\\)时(1). \\(X(t)=0\\), 下一个阶段不检测且新的不检测序列触发的是k个, 此时概率为\\(\\frac{1-\\lambda}{n}p_{0}(t)\\)；(2). \\(X(t)=k+1\\), 此时概率为 \\(p_{k+1}(t)\\), 所以: \\begin{equation} p_k(t-1) = \\frac{1-\\lambda}{n}p_{0}(t) + p_{k+1}(t), 1 \\le k \u003c n. \\tag{2} \\end{equation} 再同理, 当\\(X(t+1)=n\\), 则\\(X(t)\\)一定等于0, 因此: \\begin{equation} p_n(t+1) = \\frac{1-\\lambda}{n}p_0(t). \\tag{3} \\end{equation} 此时, 第t个包被检测即\\(X(t)\\)为0, 概率为\\(p_{0}(t)\\). 因为\\(p_{0}(t)\\)无法被直接求得, 但它可被拓展:\\( p_0(t+1) = \\lambda p_0(t) + p_1(t) \\tag{1}\\), 再迭代替换\\(p_{k} (t+1-k)\\), \\(1 \\le k \\le n\\) , 就可以得到: \\begin{equation} p_0(t+1) =\\lambda p_0(t) + \\frac{1-\\lambda}{n} \\sum_{k=1}^np_0(t-k) \\tag{4} \\end{equation} 这个式子是不平凡的, 但仍可得到平稳概率: \\begin{equation} \\lim_{t\\rightarrow \\infty} p_0(t) = \\frac{2}{(1+n)(1-\\lambda)+2} \\end{equation} 图4展示了在不同的\\(\\lambda\\)时每个包的检测概率 对\\(\\lambda\\)的选择 不能太大,否则有太多的PacketIn包, 也不能太小,因为每个包的检测概率\\(\\frac{2}{(1+n)(1-\\lambda)+2}\\) 不能低于0.2. 因此在本文的算法中使用动态的\\(\\lambda\\)选择法, 让其增长时不会超过1. 本文选择的初始值\\(\\lambda = 1, \\alpha = 0.99\\) ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:5:1","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#detection-effectiveness-analysis"},{"categories":["科研学习"],"content":"Security Analysis 主要讲了每种攻击是如何被检测到的, 可看原文 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:5:2","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#security-analysis"},{"categories":["科研学习"],"content":"Performance Evaluation 在mininet和真实硬件上测试,所使用的trace从CAIDA\\[2\\]上获得 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:6:0","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#performance-evaluation"},{"categories":["科研学习"],"content":"Implementation DynaPFV Mode 实现MAC及其定时功能 Kernel Model 修改Floodlight, 使数据平面可以只接收packetOut而不接收修改流表操作 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:6:1","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#implementation"},{"categories":["科研学习"],"content":"Experiment Setup 实验平台 攻击的实现 丢包: 使用ovs-ofctl工具在这. 包注入: 使用TCPreply. \\(\\theta\\): 设为98.9 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:6:2","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#experiment-setup"},{"categories":["科研学习"],"content":"Mininet Experiment Results 每个主机生成250个流并每秒共生成1000个包 Experiment A1: Detection Accuracy 见图6a:不同的触发概率, 不同的攻击, 不同的篡改间隔, 不同的篡改持续时间 图6a是检测性能对不同\\(\\lambda\\)的检测效果, 动态的效果更好. Experiment A.2: Selection of \\(\\tau\\): 实验结果如下: 结果表明可以在6秒内检测出大多数攻击. Experiment A.3: Detection Delay: 检测不同\\(\\lambda\\)时的检测时延和流数与检测时延的关系, 结果见图8 Experiment A.4: Overhead: 比较不同\\(\\lambda\\)时packetIn的触发概率,导致的延迟和吞吐量的变化, 比较不同path长度时包的将会延迟, 检测结果如图9. 再没通信代价, 结果见图10 ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:6:3","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#mininet-experiment-results"},{"categories":["科研学习"],"content":"Hardware Testbed Experiment Results 使用4个EdgeCore AS4610-54T交换机, 使用 CAIDE数据集. Experiment B.1: Detection Delays: 不同的包率和不同攻击的检测延迟,CDF见图11: Experiment B.2: Overhead: 对包传输时迟的影响和吞吐量随\\(\\lambda\\)的变化见图12: ","date":"2022-09-16","objectID":"/posts/org_09_dyna/:6:4","series":null,"tags":["论文阅读"],"title":"Dynamic Packet Forwarding Verification in SDN","uri":"/posts/org_09_dyna/#hardware-testbed-experiment-results"},{"categories":["实验"],"content":"OVS安装 ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:0","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs安装"},{"categories":["实验"],"content":"ovs与linux内核版本对应 OVS版本是需要与linux内核版本对应的，否则会导致内核函数与OVS调用的函数不匹配，简称装不上。 https://docs.openvswitch.org/en/latest/faq/releases/ linux 内核版本查看uname -r ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:1","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs与linux内核版本对应"},{"categories":["实验"],"content":"安装过程 这里要注意，如果下载的是官网的压缩文件，则不用./boot.sh直接从./configure开始即可， 如果是在github上下载的，则需要./boot.sh再configure 官方教程: https://docs.openvswitch.org/en/latest/intro/install/# 下载链接: http://www.openvswitch.org/download/ 下载版本: 2.13.6, 解压后进入根目录 参考资料: https://www.cnblogs.com/goldsunshine/p/10331606.html https://blog.csdn.net/zhangmeimei_pku/article/details/97929098 在这之前要先安装python和python-pip, 这么做会让系统自动安装c编译器 sudo apt install python sudo apt install python-pip OVS的源码安装命令如下： ./configure make make install ## 安装内核 make modules_install ## 将openvswitch载入到内核模块中 /sbin/modprobe openvswitch ## 看内核模块是否被加载 /sbin/lsmod |grep openvswitch ## 启动(这里要注意一下使用sudo找不到命令的问题,所以需要找到原来的目录运行一下) export PATH=$PATH:/usr/local/share/openvswitch/scripts ovs-ctl start export PATH=$PATH:/usr/local/share/openvswitch/scripts ovs-ctl --no-ovs-vswitchd start export PATH=$PATH:/usr/local/share/openvswitch/scripts ovs-ctl --no--ovsdb-server start ## 下面的是要配置ovsdb的数据库 (配置数据库了套接字都需要使用sudo,命令找不到就使用which, 然后使用绝对路径运行命令) ## 原文:In addition to using the automated script to start Open vSwitch, you may wish to manually start the various daemons. Before starting ovs-vswitchd itself, you need to start its configuration database, ovsdb-server. Each machine on which Open vSwitch is installed should run its own copy of ovsdb-server. Before ovsdb-server itself can be started, configure a database that it can use: ## 这里要注意, 需要在openvswitch要目录运行该命令 mkdir -p /usr/local/etc/openvswitch ovsdb-tool create /usr/local/etc/openvswitch/conf.db \\ vswitchd/vswitch.ovsschema ## 配置ovsdb-server以使用上面创建的数据库，监听Unix域套接字 ## 原文: Configure ovsdb-server to use database created above, to listen on a Unix domain socket, to connect to any managers specified in the database itself, and to use the SSL configuration in the database: mkdir -p /usr/local/var/run/openvswitch ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file ovs-vsctl --no-wait init ovs-vswitchd --pidfile --detach --log-file 若对OVS的源码有修改，改完ovs之后，再次按照这个步骤重新安装一下自己的ovs 重启系统后: 这个时候启动ovs会失败, 这是因为OVS自带的数据库不会自动启动 因此我们需要把后三个命令再运行一下才行, 即: ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file ovs-vsctl --no-wait init ovs-vswitchd --pidfile --detach --log-file ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:2","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#安装过程"},{"categories":["实验"],"content":"自动脚本 这里是我修改OVS源码时为了方便而写的一些自动脚本 OVS删除脚本 修改完OVS源码需要重新安装前需要先停止并删除本机运行的OVS，这是自动脚本： #!/bin/bash # 停止其运行 sudo /usr/local/share/openvswitch/scripts/ovs-ctl stop sleep 2 # 依次删除脚本；还有两个不知道干嘛的 sudo rm -rf /usr/local/share/openvswitch/scripts sudo rm -rf /usr/local/etc/openvswitch/ sudo rm -rf /usr/local/var/run/openvswitch/ sleep 2 # 移除内核模块 echo 'lsmod | grep openvswitch' lsmod | grep openvswitch echo 'sudo rmmod openvswitch' sudo rmmod openvswitch echo 'lsmod | grep openvswitch' lsmod | grep openvswitch # 若移除内核失败,执行下面两条命令 # sudo ovs-dpctl show # 查看是否被占用 # sudo ovs-dpctl del-dp ovs-system # 删除 OVS一键安装脚本 修改完OVS时需要重新安装它，这是它的安装一键脚本，在这之前别忘记删除本机上已安装的OVS,否则易失败 #!/bin/bash ./configure --with-linux=/lib/modules/$(uname -r)/build echo '' echo -e \"\\033[47;30m end configure \\033[0m\" sleep 3 make echo -e \"\\033[47;30m end make \\033[0m\" sleep 3 sudo make install echo -e \"\\033[47;30m end make install \\033[0m\" sleep 3 sudo make modules_install echo -e \"\\033[47;30m end sudo make modules_install \\033[0m\" sleep 3 sudo /sbin/modprobe openvswitch echo -e \"\\033[47;30m end sudo /sbin/modprobe openvswitch \\033[0m\" sleep 3 /sbin/lsmod | grep openvswitch echo -e \"\\033[47;30m end /sbin/lsmod | grep openvswitch \\033[0m\" sleep 3 sudo mkdir -p /usr/local/etc/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/etc/openvswitch \\033[0m\" sleep 3 sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema # 这里没出现找不到路径的问题,可能是安装了内核版本的原因 echo -e \"\\033[47;30m end ovsdb-tool \\033[0m\" sleep 3 sudo mkdir -p /usr/local/var/run/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/var/run/openvswitch \\033[0m\" sleep 3 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m end sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" sleep 3 sudo mn --test pingall echo -e \"\\033[47;30m end sudo mn --test pingall \\033[0m\" sleep 3 echo -e \"\\033[47;30m show dmesg \\033[0m\" dmesg | tail # 这时能查到我们插入源码的信息 OVS重启脚本 在重启系统后，OVS自带的一些服务数据库啥的不会一同启动，因此需要手动启动 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" OVS迁移脚本 源码被一个系统编译过,再复制到其他系统中编译不成功,需要运行下这个脚本才可 #!/bin/bash autoscan echo -e \"\\033[47;30m autoscan \\033[0m\" sleep 1 aclocal echo -e \"\\033[47;30m aclocal \\033[0m\" sleep 1 autoconf echo -e \"\\033[47;30m autoconf \\033[0m\" sleep 1 automake --add-missing echo -e \"\\033[47;30m automake --add-missing \\033[0m\" ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:3","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#自动脚本"},{"categories":["实验"],"content":"自动脚本 这里是我修改OVS源码时为了方便而写的一些自动脚本 OVS删除脚本 修改完OVS源码需要重新安装前需要先停止并删除本机运行的OVS，这是自动脚本： #!/bin/bash # 停止其运行 sudo /usr/local/share/openvswitch/scripts/ovs-ctl stop sleep 2 # 依次删除脚本；还有两个不知道干嘛的 sudo rm -rf /usr/local/share/openvswitch/scripts sudo rm -rf /usr/local/etc/openvswitch/ sudo rm -rf /usr/local/var/run/openvswitch/ sleep 2 # 移除内核模块 echo 'lsmod | grep openvswitch' lsmod | grep openvswitch echo 'sudo rmmod openvswitch' sudo rmmod openvswitch echo 'lsmod | grep openvswitch' lsmod | grep openvswitch # 若移除内核失败,执行下面两条命令 # sudo ovs-dpctl show # 查看是否被占用 # sudo ovs-dpctl del-dp ovs-system # 删除 OVS一键安装脚本 修改完OVS时需要重新安装它，这是它的安装一键脚本，在这之前别忘记删除本机上已安装的OVS,否则易失败 #!/bin/bash ./configure --with-linux=/lib/modules/$(uname -r)/build echo '' echo -e \"\\033[47;30m end configure \\033[0m\" sleep 3 make echo -e \"\\033[47;30m end make \\033[0m\" sleep 3 sudo make install echo -e \"\\033[47;30m end make install \\033[0m\" sleep 3 sudo make modules_install echo -e \"\\033[47;30m end sudo make modules_install \\033[0m\" sleep 3 sudo /sbin/modprobe openvswitch echo -e \"\\033[47;30m end sudo /sbin/modprobe openvswitch \\033[0m\" sleep 3 /sbin/lsmod | grep openvswitch echo -e \"\\033[47;30m end /sbin/lsmod | grep openvswitch \\033[0m\" sleep 3 sudo mkdir -p /usr/local/etc/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/etc/openvswitch \\033[0m\" sleep 3 sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema # 这里没出现找不到路径的问题,可能是安装了内核版本的原因 echo -e \"\\033[47;30m end ovsdb-tool \\033[0m\" sleep 3 sudo mkdir -p /usr/local/var/run/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/var/run/openvswitch \\033[0m\" sleep 3 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m end sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" sleep 3 sudo mn --test pingall echo -e \"\\033[47;30m end sudo mn --test pingall \\033[0m\" sleep 3 echo -e \"\\033[47;30m show dmesg \\033[0m\" dmesg | tail # 这时能查到我们插入源码的信息 OVS重启脚本 在重启系统后，OVS自带的一些服务数据库啥的不会一同启动，因此需要手动启动 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" OVS迁移脚本 源码被一个系统编译过,再复制到其他系统中编译不成功,需要运行下这个脚本才可 #!/bin/bash autoscan echo -e \"\\033[47;30m autoscan \\033[0m\" sleep 1 aclocal echo -e \"\\033[47;30m aclocal \\033[0m\" sleep 1 autoconf echo -e \"\\033[47;30m autoconf \\033[0m\" sleep 1 automake --add-missing echo -e \"\\033[47;30m automake --add-missing \\033[0m\" ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:3","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs删除脚本"},{"categories":["实验"],"content":"自动脚本 这里是我修改OVS源码时为了方便而写的一些自动脚本 OVS删除脚本 修改完OVS源码需要重新安装前需要先停止并删除本机运行的OVS，这是自动脚本： #!/bin/bash # 停止其运行 sudo /usr/local/share/openvswitch/scripts/ovs-ctl stop sleep 2 # 依次删除脚本；还有两个不知道干嘛的 sudo rm -rf /usr/local/share/openvswitch/scripts sudo rm -rf /usr/local/etc/openvswitch/ sudo rm -rf /usr/local/var/run/openvswitch/ sleep 2 # 移除内核模块 echo 'lsmod | grep openvswitch' lsmod | grep openvswitch echo 'sudo rmmod openvswitch' sudo rmmod openvswitch echo 'lsmod | grep openvswitch' lsmod | grep openvswitch # 若移除内核失败,执行下面两条命令 # sudo ovs-dpctl show # 查看是否被占用 # sudo ovs-dpctl del-dp ovs-system # 删除 OVS一键安装脚本 修改完OVS时需要重新安装它，这是它的安装一键脚本，在这之前别忘记删除本机上已安装的OVS,否则易失败 #!/bin/bash ./configure --with-linux=/lib/modules/$(uname -r)/build echo '' echo -e \"\\033[47;30m end configure \\033[0m\" sleep 3 make echo -e \"\\033[47;30m end make \\033[0m\" sleep 3 sudo make install echo -e \"\\033[47;30m end make install \\033[0m\" sleep 3 sudo make modules_install echo -e \"\\033[47;30m end sudo make modules_install \\033[0m\" sleep 3 sudo /sbin/modprobe openvswitch echo -e \"\\033[47;30m end sudo /sbin/modprobe openvswitch \\033[0m\" sleep 3 /sbin/lsmod | grep openvswitch echo -e \"\\033[47;30m end /sbin/lsmod | grep openvswitch \\033[0m\" sleep 3 sudo mkdir -p /usr/local/etc/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/etc/openvswitch \\033[0m\" sleep 3 sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema # 这里没出现找不到路径的问题,可能是安装了内核版本的原因 echo -e \"\\033[47;30m end ovsdb-tool \\033[0m\" sleep 3 sudo mkdir -p /usr/local/var/run/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/var/run/openvswitch \\033[0m\" sleep 3 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m end sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" sleep 3 sudo mn --test pingall echo -e \"\\033[47;30m end sudo mn --test pingall \\033[0m\" sleep 3 echo -e \"\\033[47;30m show dmesg \\033[0m\" dmesg | tail # 这时能查到我们插入源码的信息 OVS重启脚本 在重启系统后，OVS自带的一些服务数据库啥的不会一同启动，因此需要手动启动 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" OVS迁移脚本 源码被一个系统编译过,再复制到其他系统中编译不成功,需要运行下这个脚本才可 #!/bin/bash autoscan echo -e \"\\033[47;30m autoscan \\033[0m\" sleep 1 aclocal echo -e \"\\033[47;30m aclocal \\033[0m\" sleep 1 autoconf echo -e \"\\033[47;30m autoconf \\033[0m\" sleep 1 automake --add-missing echo -e \"\\033[47;30m automake --add-missing \\033[0m\" ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:3","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs一键安装脚本"},{"categories":["实验"],"content":"自动脚本 这里是我修改OVS源码时为了方便而写的一些自动脚本 OVS删除脚本 修改完OVS源码需要重新安装前需要先停止并删除本机运行的OVS，这是自动脚本： #!/bin/bash # 停止其运行 sudo /usr/local/share/openvswitch/scripts/ovs-ctl stop sleep 2 # 依次删除脚本；还有两个不知道干嘛的 sudo rm -rf /usr/local/share/openvswitch/scripts sudo rm -rf /usr/local/etc/openvswitch/ sudo rm -rf /usr/local/var/run/openvswitch/ sleep 2 # 移除内核模块 echo 'lsmod | grep openvswitch' lsmod | grep openvswitch echo 'sudo rmmod openvswitch' sudo rmmod openvswitch echo 'lsmod | grep openvswitch' lsmod | grep openvswitch # 若移除内核失败,执行下面两条命令 # sudo ovs-dpctl show # 查看是否被占用 # sudo ovs-dpctl del-dp ovs-system # 删除 OVS一键安装脚本 修改完OVS时需要重新安装它，这是它的安装一键脚本，在这之前别忘记删除本机上已安装的OVS,否则易失败 #!/bin/bash ./configure --with-linux=/lib/modules/$(uname -r)/build echo '' echo -e \"\\033[47;30m end configure \\033[0m\" sleep 3 make echo -e \"\\033[47;30m end make \\033[0m\" sleep 3 sudo make install echo -e \"\\033[47;30m end make install \\033[0m\" sleep 3 sudo make modules_install echo -e \"\\033[47;30m end sudo make modules_install \\033[0m\" sleep 3 sudo /sbin/modprobe openvswitch echo -e \"\\033[47;30m end sudo /sbin/modprobe openvswitch \\033[0m\" sleep 3 /sbin/lsmod | grep openvswitch echo -e \"\\033[47;30m end /sbin/lsmod | grep openvswitch \\033[0m\" sleep 3 sudo mkdir -p /usr/local/etc/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/etc/openvswitch \\033[0m\" sleep 3 sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema # 这里没出现找不到路径的问题,可能是安装了内核版本的原因 echo -e \"\\033[47;30m end ovsdb-tool \\033[0m\" sleep 3 sudo mkdir -p /usr/local/var/run/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/var/run/openvswitch \\033[0m\" sleep 3 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m end sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" sleep 3 sudo mn --test pingall echo -e \"\\033[47;30m end sudo mn --test pingall \\033[0m\" sleep 3 echo -e \"\\033[47;30m show dmesg \\033[0m\" dmesg | tail # 这时能查到我们插入源码的信息 OVS重启脚本 在重启系统后，OVS自带的一些服务数据库啥的不会一同启动，因此需要手动启动 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" OVS迁移脚本 源码被一个系统编译过,再复制到其他系统中编译不成功,需要运行下这个脚本才可 #!/bin/bash autoscan echo -e \"\\033[47;30m autoscan \\033[0m\" sleep 1 aclocal echo -e \"\\033[47;30m aclocal \\033[0m\" sleep 1 autoconf echo -e \"\\033[47;30m autoconf \\033[0m\" sleep 1 automake --add-missing echo -e \"\\033[47;30m automake --add-missing \\033[0m\" ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:3","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs重启脚本"},{"categories":["实验"],"content":"自动脚本 这里是我修改OVS源码时为了方便而写的一些自动脚本 OVS删除脚本 修改完OVS源码需要重新安装前需要先停止并删除本机运行的OVS，这是自动脚本： #!/bin/bash # 停止其运行 sudo /usr/local/share/openvswitch/scripts/ovs-ctl stop sleep 2 # 依次删除脚本；还有两个不知道干嘛的 sudo rm -rf /usr/local/share/openvswitch/scripts sudo rm -rf /usr/local/etc/openvswitch/ sudo rm -rf /usr/local/var/run/openvswitch/ sleep 2 # 移除内核模块 echo 'lsmod | grep openvswitch' lsmod | grep openvswitch echo 'sudo rmmod openvswitch' sudo rmmod openvswitch echo 'lsmod | grep openvswitch' lsmod | grep openvswitch # 若移除内核失败,执行下面两条命令 # sudo ovs-dpctl show # 查看是否被占用 # sudo ovs-dpctl del-dp ovs-system # 删除 OVS一键安装脚本 修改完OVS时需要重新安装它，这是它的安装一键脚本，在这之前别忘记删除本机上已安装的OVS,否则易失败 #!/bin/bash ./configure --with-linux=/lib/modules/$(uname -r)/build echo '' echo -e \"\\033[47;30m end configure \\033[0m\" sleep 3 make echo -e \"\\033[47;30m end make \\033[0m\" sleep 3 sudo make install echo -e \"\\033[47;30m end make install \\033[0m\" sleep 3 sudo make modules_install echo -e \"\\033[47;30m end sudo make modules_install \\033[0m\" sleep 3 sudo /sbin/modprobe openvswitch echo -e \"\\033[47;30m end sudo /sbin/modprobe openvswitch \\033[0m\" sleep 3 /sbin/lsmod | grep openvswitch echo -e \"\\033[47;30m end /sbin/lsmod | grep openvswitch \\033[0m\" sleep 3 sudo mkdir -p /usr/local/etc/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/etc/openvswitch \\033[0m\" sleep 3 sudo ovsdb-tool create /usr/local/etc/openvswitch/conf.db vswitchd/vswitch.ovsschema # 这里没出现找不到路径的问题,可能是安装了内核版本的原因 echo -e \"\\033[47;30m end ovsdb-tool \\033[0m\" sleep 3 sudo mkdir -p /usr/local/var/run/openvswitch echo -e \"\\033[47;30m end sudo mkdir -p /usr/local/var/run/openvswitch \\033[0m\" sleep 3 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m end sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m end sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" sleep 3 sudo mn --test pingall echo -e \"\\033[47;30m end sudo mn --test pingall \\033[0m\" sleep 3 echo -e \"\\033[47;30m show dmesg \\033[0m\" dmesg | tail # 这时能查到我们插入源码的信息 OVS重启脚本 在重启系统后，OVS自带的一些服务数据库啥的不会一同启动，因此需要手动启动 sudo ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \\ --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\ --private-key=db:Open_vSwitch,SSL,private_key \\ --certificate=db:Open_vSwitch,SSL,certificate \\ --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \\ --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovsdb-server \\033[0m\" sleep 3 sudo ovs-vsctl --no-wait init echo -e \"\\033[47;30m sudo ovs-vsctl --no-wait init \\033[0m\" sleep 3 sudo ovs-vswitchd --pidfile --detach --log-file echo -e \"\\033[47;30m sudo ovs-vswitchd --pidfile --detach --log-file \\033[0m\" OVS迁移脚本 源码被一个系统编译过,再复制到其他系统中编译不成功,需要运行下这个脚本才可 #!/bin/bash autoscan echo -e \"\\033[47;30m autoscan \\033[0m\" sleep 1 aclocal echo -e \"\\033[47;30m aclocal \\033[0m\" sleep 1 autoconf echo -e \"\\033[47;30m autoconf \\033[0m\" sleep 1 automake --add-missing echo -e \"\\033[47;30m automake --add-missing \\033[0m\" ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:1:3","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ovs迁移脚本"},{"categories":["实验"],"content":"Mininet安装(官网上的安装教程最全) 下载:http://mininet.org/download/ 去github上下载它的源码 解压后进入根目录 使用git tag可以查看所有的版本, 不切换当前默认安装3.2.1b1. 使用的安装命令: ## 只安装mininet和openflow1.3, 因此使用命令: ./util/install.sh -n3 ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:2:0","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#mininet安装官网上的安装教程最全"},{"categories":["实验"],"content":"测试 运行 sudo mn –test pingall, 成功则说明2个都安装好了 *** Creating network *** Adding controller *** Adding hosts: h1 h2 *** Adding switches: s1 *** Adding links: (h1, s1) (h2, s1) *** Configuring hosts h1 h2 *** Starting controller c0 *** Starting 1 switches s1 ... *** Waiting for switches to connect s1 *** Ping: testing ping reachability h1 -\u003e h2 h2 -\u003e h1 *** Results: 0% dropped (2/2 received) *** Stopping 1 controllers c0 *** Stopping 2 links .. *** Stopping 1 switches s1 *** Stopping 2 hosts h1 h2 *** Done completed in 6.082 seconds ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:3:0","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#测试"},{"categories":["实验"],"content":"ryu源码安装 下载源码 git clone https://github.com/faucetsdn/ryu.git github上的readme里面有相关的安装依赖说明, 直接使用pip安装没成功, 因此我们这里使用python3安装. 安装pip3 sudo apt install python3-pip 安装依赖 sudo pip3 install -r tools/pip-requires 安装ryu(此之前应已安装python3) sudo python3 setup.py install 运行 ryu-manager loading app ryu.controller.ofp_handler instantiating app ryu.controller.ofp_handler of OFPHandler 成功 ","date":"2022-08-28","objectID":"/posts/05_ovs_install/:4:0","series":null,"tags":["ovs"],"title":"mininet , ovs , ryu 分别进行源码安装","uri":"/posts/05_ovs_install/#ryu源码安装"},{"categories":null,"content":"摘要 随着智能工厂的空前发展，工业网络中需要更加频繁更改网络流量的转发策略。软件定义网络具有高灵活性和可编程性的优点，可动态地管理网络流量转发策略，它对于智能工业网络具有很可观的发展前景。然而，软件定义工业网络十分容易受到网络攻击，网络攻击会导致工业生产效率降低甚至引起工业事故。本文提出一个基于深度学习的单类入侵检测方案（DO-IDS）来提高工业网络的安全性。首先，DO-IDS 定期抽取工业网络流量的流统计信息并据此生成网络状态特征；其次，我们利用一种基于深度学习的降维方法来过滤上述特征中的冗余特征；此外，我们设计一种基于深度学习的单类检测器来计算网络特征的异常打分；最后，我们对所提出的检测方案进行了模拟实验，结果表明 DO-IDS 可以高效率且高准确率地检测出异常流量。 关键字：工业网络安全；入侵检测；单类深度学习；软件定义工业网络（SDIN） ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:1:0","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#摘要"},{"categories":null,"content":"介绍 智能工厂的快速发展和革新极大地提高了工厂的生产效率并降低了生产代价。越来越多的工厂模式（如私人定制、远程控制、数据孪生等）需要频繁地自定义或更改网络流量转发策略，这些功能需要一个灵活的工业网络架构才能实现。然而，传统网络的转发功能函数是直接实现在硬件中，这种实现方式使得网络管理员需要手动对网络设备进行配置才可更改流量转发策略。 软件定义网络解偶了网络的数据平面和控制平面，在逻辑上集中式且可编程的控制平面使得SDN具有极大的灵活性。数据平面只需要根据从控制平面处接收到的指令转发网络流量即可，这种简单的功能可以极大地降低数据平面的硬件成本。因此对于智能工厂而言，软件定义工业网络（SDIN）具有很大的发展潜力。 工业网络中工业设备间的安全通信对于构建安全的工业环境，定制生产策略和多生产线的同步都至关重要。然而，软件定义工业网络的这种架构十分容易受到网络攻击。中心化的控制平面面临着单点失效的问题，数据平面与控制平面的通信信道可能会遭受分布式拒绝服务攻击和中间人攻击。此外，传统网络所面临的网络攻击，如 Probing, R2I, U2R, Trojan, Worm 等也均会在软件定义工业网络环境中出现，这些网络攻击会降低工业生产效率，甚至会导致严重的工业事故。例如，美国的燃气公司曾在2021年的5月遭受过一次网络攻击，该攻击导致燃气管道关闭了数日；世界上最大的钢铁生产商也曾遭受过网络攻击并导致了北美区域的钢铁产量下降。 入侵检测技术能够监控网络状态，识别异常网络流量和网络行为，并在网络异常发生时及时警告网络管理员从而降低由网络攻击所造成的损失。然而，在软件定义工业网络环境中的进行入侵检测仍然存在着一些挑战。首先，所有的智能功能都存在于逻辑上集中的控制器中，若要在当前的高带宽网络环境中对每一个数据包进行检查必定会给控制器带来极大的负担，因此入侵检测技术应足够地轻量级以减少控制器的负担。其次，网络攻击虽然无时无刻不在网络中发生，但网络中的正常流量仍然占据了绝大多数，当前网络环境中流量极大，因此手动标识每个数据包是否正常十分地不可行。再次，网络流量的分布模式随网络设备和网络应用的变化而变化，因此当前已存在的检测模型和数据集会逐渐过时，并造成入侵检测的高误报率。最后，控制器所收集的信息中，冗余和无用信息会极大地降低入侵检测模型的检测性能。 为提高工业网络的安全性并克服以上挑战，本文提出了一种基于深度学习的单类入侵检测机制（DO-IDS）来识别软件定义工业网络环境的安全。DO-IDS有三个模块组成：收集器（Collector），检测器（Detector）和防御器（Defender）。收集器负责定期从数据平面抽取网络流的特征信息。检测器负责过滤所抽取特征信息中的冗余信息，再利用基于长短期记忆网络的自编码器（LAE）将特征信息编码为固定长度的向量并计算该向量的异常分数。由 deep-SVDD 启发，我们提出了一种基于深度学习的单类检测算法来计算流量特征的异常分数。防御器会根据检测器所计算出的异常分数来选择合适的流量策略。本文贡献总结如下： 提出了一个基于深度学习的单类异常检测方案，该方案可有效地监控网络状态并检测网络中的异常行为从而提高工业网络安全性。 为克服当前无法获得有标签且最新训练数据集的问题，我们提出一种基于单类深度学习的异常发现算法，并提出针对该算法提出了三个优化：压缩，异常样本利用以及联合训练。 提出利用LAE来将所收集的网络流特征编码为固定长度的向量，从而过滤掉所收集特征信息的冗余信息并方便异常分数的计算。 对所提出的方法进行了模拟实验，实验结果表明相较于当前异常检测算法，本文提出的检测方案在不平衡数据集上能够取得很好的检测效果。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:2:0","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#介绍"},{"categories":null,"content":"相关工作 近年来学者们提出了很多网络入侵和异常检测相关的研究工作，这些工作基本可分为基于熵的，基于机器学习的和基于深度学习的。在本部分我们对前人的针对网络入侵和异常检测相关的工作进行介绍。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:3:0","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#相关工作"},{"categories":null,"content":"基于熵的入侵检测 数据样本的熵值可以用来表示样本分布的随机性，熵值越高表示样本的分布越离散。文献[12]中提出了一种基于熵的轻量级 DDoS 泛洪攻击检测方法，该方法通过利用网络中的边缘交换机来收集网络流的统计信息从而达到检测的目的。文献[13]中提出一种基于联合熵的流量异常检测方法，该方法通过动态选择可疑网络数据包的属性并计算它们的联合熵来提高检测性能。然而，在基于熵的方法中，需要监控的网络数据包的属性需要由网络管理员手动指定，这大大降低了检测方法的易用性。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:3:1","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#基于熵的入侵检测"},{"categories":null,"content":"基于机器学习的入侵检测 机器学习技术十分擅长在超大数据集中找出数据的发展趋势和分布模式，且该过程自动进行不需要人为干预。此外，当我们将网络流量聚焦为流记录时，所需要收集的数据量会大大减少，这使得收集网络流记录并结合机器学习的异常检测方法越来越受欢迎[14]。文献[15]中提出在SDN环境中收集网络流特征信息，并用收集的信息训练有监督分类模型从而监控网络状态。文献[16]中提出使用受限波尔兹曼机将所收集的网络流特征信息转换为固定长度的向量并利用支持向量机算法对其进行异常检测。虽然有监督的分类算法分类正确率高，但收集有标签且当下未过时的网络流量数据样本十分困难。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:3:2","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#基于机器学习的入侵检测"},{"categories":null,"content":"基于深度学习的入侵检测 深度学习技术可以在大数据集中找出数据间的隐藏关系，这个优点使得该技术广受研究人员的偏爱[17][18]。文献[19]利用所收集的网络流统计信息来训练深度神经网络模型从而进行网络入侵检测。文献[20]提出一种将特征筛选和门递归单元长短期记忆网络相结合的方法来监督网络流特征是否发生异常。文献[21]中提出训练自编码器网络来重构流量样本，并对重构误差进行聚类。若一个流量样本的重构误差不属于已知的任何一类，则该样本被视为异常。现有的基于深度学习的检测方法要么需要二类数据进行训练，要么只能使用正常数据进行训练。 本文提出 DO-IDS 来提高软件定义网络环境的安全性。与已知的工作相比，DO-IDS 通过利用 LAE 来将特征序列编码为固定长度的向量，这使得 DO-IDS 有处理网络特征序列的能力，且利用 LAE 获得固定长度向量的过程可降低序列信息的冗余信息从而提高 DO-IDS 的检测正确率。此外，DO-IDS 的训练过程中既可以只使用单类正常数据作为训练样本，也可以使用有标签的数据集，并能够定期更新检测器的检测参数从而持续保证检测性能。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:3:3","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#基于深度学习的入侵检测"},{"categories":null,"content":"检测系统概述 本文所提出的DO-IDS在SDN控制器中实现，其由三个模块组成：收集器，检测器和防御器。DO-IDS的工作流由图1所示，每个模块的功能将在后续介绍。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:4:0","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#检测系统概述"},{"categories":null,"content":"收集器 收集器由监控器和特征提取器这两个组件组成。监控器定期向数据平面发送网络状态请求，数据平面的交换机在收到这样的请求后会将它们的状态信息返回给收集器。然而，由数据平面返回的状态信息中存在着大量的重复信息。比如当前存在一个从$A$到$B$的流\\(A \\rightarrow S_1 \\rightarrow S_2 \\rightarrow B\\)，其中$S_1$和$S_2$为数据平面的交换机。对于这个流，交换机$S_1$和$S_2$中所存储的信息是完全相同的，但是要进行异常检测时，只需要一个这样的数据即可。特征抽取器会首先对接收到的数据进行去重，然后将这些去重后的信息组织成特征向量序列，这些特征向量序列将会被发送到检测器和防御器模块进行流量异常检测。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:4:1","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#收集器"},{"categories":null,"content":"检测器 检测器在收到收集器发来的特征向量序列后会对它们计算异常分数，并将这些异常分数发送给防御器。检测器由编码器、解码器和打分器这三个组件组成，编码器将特征向量序列编码成固定长度的向量，这个过程可以减少序列中的冗余信息。本文中的固定长度向量指的是向量维度相同的向量。解码器利用编码器的输出结果重构向量序列，解码器的重构过程可帮助更新编码器中神经网络参数。打分器对编码结果计算异常分数，并将这个分数发送给防御器。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:4:2","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#检测器"},{"categories":null,"content":"防御器 防御器模块判断网络中是否存在异常流量并执行相应的防御策略。该模块由比较器、规则生成器、警告器和辅助数据库四个组件组成。比较器首先判定从检测器处收到的异常分数是否超过指定的门限值\\(\\tau\\)。若超过了，那么与这个分数相关的特征序列就会被判定为从异常流中抽取的序列，因此通知警告器此异常的发生，并将该特征序列存入辅助数据库并将该条数据赋予异常标签。警告器在收到异常通知后会将该异常报告给管理员。当异常发生时，规则生成器会根据异常特征序列生成流表来实现数据平面的防御过程。若接收到的异常分数小于门限值\\(\\tau\\)，与这个异常分数相关的流特征则会被认为是从正常流中提取的，则将其以正常样本的形式存入辅助数据库。辅助数据库维护特征向量序列样本，并定期地且这些样本训练检测器并替换旧的检测器。 ","date":"2022-08-23","objectID":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/:4:3","series":null,"tags":null,"title":"DO-IDS汉语版","uri":"/hide/do-ids%E6%B1%89%E8%AF%AD%E7%89%88/#防御器"},{"categories":["科研学习"],"content":"选择的流经过所有的交换机 控制器实时构造rule graph 获取所有的ingress rule（入度为0的规则），并依长度降序排序 对每一个ingress rule \\(r_0\\): 若该path的节点未在节点集\\(\\mathbb{S}\\)中： 将$r_0$所属的rule path所经过的节点加入$\\mathbb{S}$中； 将 \\(r_0\\) 所属的rule path放到规则集$\\mathbb{R}$中。 若节点集的节点数等于规则图中的节点数（这表明每一个交换机都有经过其的rule），则结束. 只针对交换机的流规则选择办法中，当攻击者对某个流进行恶意交付时，无法被检测。 ","date":"2022-08-23","objectID":"/hide/org_08_rule_selection/:1:0","series":null,"tags":["idea"],"title":"记录在数据平面选择流的过程","uri":"/hide/org_08_rule_selection/#选择的流经过所有的交换机"},{"categories":["科研学习"],"content":"选择的流经过所有的输出端口 控制器实时构造rule graph 针对每个交换机的输出端口，记为集合\\(\\mathbb{O}\\). 计算每个rule path所经过的输出端口数。 每次选择经过$\\mathbb{O}$中端口数最多的rule path \\(r\\),记$O(r)$为规则$r$所经过的输出端口 \\(\\mathbb{O} = \\mathbb{O} / \\{O( r)\\}\\) \\(\\mathbb{R} = \\mathbb{R} + \\{r\\}\\) 若\\(|\\mathbb{O}| == 0\\)，则算法结束，返回\\(\\mathbb{R}\\) ","date":"2022-08-23","objectID":"/hide/org_08_rule_selection/:2:0","series":null,"tags":["idea"],"title":"记录在数据平面选择流的过程","uri":"/hide/org_08_rule_selection/#选择的流经过所有的输出端口"},{"categories":["科研学习"],"content":"文章目的 介绍一个用于在有向无环图（DAG）中进行最小路径覆盖（Minimum Path Cover, MPC）的算法。文中给定了一个场景（交通网络中的运输问题），并将这个场景建模成MPC问题，最后给出了求解方法。 ","date":"2022-08-21","objectID":"/posts/org_06_mpc/:1:0","series":null,"tags":["论文阅读"],"title":"Solving Minimum Path Cover on a DAG","uri":"/posts/org_06_mpc/#文章目的"},{"categories":["科研学习"],"content":"情景样例 假设一个交通运输系统中有4个地铁站，站与站之间可达，交通时间表可确定。你需要做的是购买车票从而实现所有的运输。时间表如下： 最坏的情况是每辆车都买一个票，需要7张。但其实有的运输任务可被同一个车完成，如T1和T2。我们需要做的是最大化运输效率，即最小化所构买的车票数，此时，找到了一个目标函数。 最优情况是一列车走过所有的站，这时只要买一张票即足够，这种情况不存在，因此我们把问题定义为： 最大化车所到达的站数的同时，保证所有的站点均到达。 首先根据传输时间表构造交通图，因为车辆到达时间是不同的且有先后的，所以车辆换乘是有时间依赖的，据此构造图如下: 因此，现在问题转变为: 在以上构造的图上找到MPC。 ","date":"2022-08-21","objectID":"/posts/org_06_mpc/:2:0","series":null,"tags":["论文阅读"],"title":"Solving Minimum Path Cover on a DAG","uri":"/posts/org_06_mpc/#情景样例"},{"categories":["科研学习"],"content":"解决办法 在通用的图上找MPC是一个NP-hard问题，但在DAG中找MPC可转换为找二部图的最大匹配问题，这可以在多项式时间内完成。 为解决以上问题，首先构造一个辅助图，在辅助图中，将原始图中的每个节点分为两个，一个节点保留原始节点的出度，另一个节点保留原始图的入度。举个例子，将节点$t$划分为\\(t_1, t_2\\). 对于t的邻居，从$t_1$画边连出去，对于将$t$作为邻居的其他节点，将该节点画边连到\\(t_2\\)。如此构造的图其实是一个二部图，结果如下: 在以上二部图中查找匹配，假如找完最大匹配后某一个节点未到达，则需要单独为该节点购买一个车次的票以完成运输。因此最小化未到达节点的问题即是上图中的查找最大匹配的问题。而二部图的最大匹配问题是可以在多项式时间内完成的。 其中的一个匹配结果为： ","date":"2022-08-21","objectID":"/posts/org_06_mpc/:3:0","series":null,"tags":["论文阅读"],"title":"Solving Minimum Path Cover on a DAG","uri":"/posts/org_06_mpc/#解决办法"},{"categories":["科研学习"],"content":"二部图最大匹配 对于二部图的匹配问题其是就是用匈牙利算法来解决的。这里简单介绍一下。参考自这里，这个作者还有其他算法的讲解以及代码实现。 对于现有的二部图 要找到它的最大匹配，是需要遍历它所有的节点的: 对于B1, 它与G2和G4都有连接，这里先将它与G2相连。 对于B2，它只与G2相连，这时再返回去看与G2相连的B1是否有别的相连的，可见G4可选，因此就将G2与B2相连，B1与G4相连； 对于B3，它与G1和G3相连，G1和G3都均未与其他节点相连，可将它连上G1 对于B4, 它只能与G4相连，但G4已与B1相连。B1除了G4，还可以与G2相连，但G2已与B2相连了，因此如果B4与G4相连了，B1就无法与别的节点相加，所以B4就无法匹配了。 至此，最大匹配结束。上述过程可见计算的复杂度是二部图两边节点之积。 ","date":"2022-08-21","objectID":"/posts/org_06_mpc/:4:0","series":null,"tags":["论文阅读"],"title":"Solving Minimum Path Cover on a DAG","uri":"/posts/org_06_mpc/#二部图最大匹配"},{"categories":["额外学习"],"content":"Magit 的基本介绍 Magit是在emacs中对git的一种扩展, 它的本质是在emacs中, 利用emacs的方式调用git的命令, 使得git的使用更加地emacs化. 本人的emacs 能力有限, 因此只介绍magit中的一些最常用的命令, 方便日常使用够用即可. 要更加全面地研究可以看它的原网站. ","date":"2022-08-15","objectID":"/posts/org_05_magit_usage/:1:0","series":null,"tags":["git"],"title":"Magit的基本使用","uri":"/posts/org_05_magit_usage/#magit-的基本介绍"},{"categories":["额外学习"],"content":"Magit的基本介绍 ","date":"2022-08-15","objectID":"/posts/org_05_magit_usage/:2:0","series":null,"tags":["git"],"title":"Magit的基本使用","uri":"/posts/org_05_magit_usage/#magit的基本介绍"},{"categories":["额外学习"],"content":"打开Magit窗口: 使用Emacs打开任一由git管理的文件, 再使用快捷键 C-x g (M-x magit-status) 即可打开. 基本上第一次需要使用M-x magit-status打开, 后面才能用C-x g快捷键, 不知道是不是什么bug. 打开后会有一个窗口(这里我事先建好了一个 git 仓库) 分析下magit 窗口每部分的意思: Head: 当前HEAD指向 Untracked files: 未追踪的文件 (也就是没使用 git add 命令添加的文件) Unstaged changes: 由git管理, 进行了修改, 但未添加到暂存区的文件 Recent commits: 最近的提交记录, 第一列就是提交ID 如果常使用git, 以上解释应该一遍就能记住 ","date":"2022-08-15","objectID":"/posts/org_05_magit_usage/:2:1","series":null,"tags":["git"],"title":"Magit的基本使用","uri":"/posts/org_05_magit_usage/#打开magit窗口"},{"categories":["额外学习"],"content":"常用的一些快捷键 g \u0026 G: g可以刷新当前buffer, G刷新全部buffer. 什么意思呢, 比如当前你在查看magit面板, 但是突发奇想往工程里添加了个文件, 这时magit面板的Untracked files里应该要多一个刚添加的文件的, 但是并没有, 此时需要按一下g, 这时这个新加的文件就会出现然Untracked files里了. TAB: 折叠, 即如果光标在Untracked files这一行, 按TAB, 即可将UnTracked files这个小节给折叠起来, 工程文件多的时候这个功能十分管用. 下面是将Recent commits折叠后的结果. C-p, C-n \u0026 M-p, M-n: C-p和C-n是上下移动, 与emacs移动相同. M-p和M-n是同级上下移动. 比如上面这个图, 如果光标在file这一行, 按M-n则会移动到new这一行, 如果光标在Untracked files这一行, 按M-n则会移动到Unstaged changes这一行. d d: 查看diff, 将text.txt文件中的内容修改, 并将光标移动到Unstaged changes中的 modified text.txt 这一行, 按两下d, 即可弹出 diff 相关内容, 弹窗如下: 这个弹窗分两部分, Unstaged changes部分是文件名以及其修改的总结. 它的下面是针对每个文件高亮修改的内容. 可以清楚地看到改支的行以及改动的内容: 红删除, 蓝为添加行, 标红内容为删除内容, 标蓝内容为添加内容. 一开始看可能有些不习惯, 但习惯后这个功能十分有用. 此外, 如果在某一个提交行按 d d, 则会显示本次提交与前一次提交的diff s \u0026 u: s可将文件添加到暂存区, u可将文件移出暂存区. 比如光标调整到new这个文件上, 按s后结果为: 可以看到new这个文件从Untracked files移到了staged changes这个小节下. 翻译成git的话就是 使用了 git add new 这个命令. q: 退出当前buffer. Enter: 到处都能用, 一个很好用的地方是, 在查看diff时, 在某一行按Enter, 它会直接跳到这个文件的这一行供你修改. c: 提交弹窗, 如下: 此时按c, 即Commit (git commit -m), (通常直接按两下c), 这时会进入提交信息提示弹窗, 输入完提示信息后 再按C-c C-c 即可完成提交 (C-c C-k 放弃提交). 此时按a, 即 git commit --amend l: log弹窗 r: rebase弹窗 ","date":"2022-08-15","objectID":"/posts/org_05_magit_usage/:2:2","series":null,"tags":["git"],"title":"Magit的基本使用","uri":"/posts/org_05_magit_usage/#常用的一些快捷键"},{"categories":["额外学习"],"content":"可能看起来学习成本高, 但其实学会后好处要远远大于学习成本 ","date":"2022-08-15","objectID":"/posts/org_05_magit_usage/:3:0","series":null,"tags":["git"],"title":"Magit的基本使用","uri":"/posts/org_05_magit_usage/#可能看起来学习成本高-但其实学会后好处要远远大于学习成本"},{"categories":null,"content":"基础(最常用的命令) git init #初始化Git仓库 git add . #添加所有未追踪文件或修改 git add filename #添加指定文件 git commit -m \"commit information\" # 提交 git push #推送到远程 git pull #从远程拉取 git status # 查看当前状态 git log # 查看提交日志 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:1:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#基础--最常用的命令"},{"categories":null,"content":"版本回退 前一个版本: I’m a little tired!!! 当前版本: I’m not tired!!! 这时使用 git add 和 git commit 提交了, 但是想回退过去的操作办法如下: git中HEAD表示当前的提交版本, HEAD^表示前一个提交版本,所以想回退的操作为: git reset --hard HEAD^ 未回退命令时日志显示: 有两个版本: first 和 not tired 使用回退命令后日志显示: 只有 first 了 当知道commit ID时, 使用 commit ID直接跳到想要的版本. 比如现在想再返回 not tired, 操作命令为: git reset --hard commit_id 这时再查看log结果为: 可以看到, 使用了这个命令后, 我们的not tired 提交又回来了. 当不知道commit ID时也是有办法的 git提供了 git reflog 命令, 这个命令的输出结果是记录你的每一次命令, 使用 git reflog 命令查看历史命令: 可以看到第一列记录了所有的commit ID, 最后一列记录了执行的操作, 根据最后一列信息找到对应的ID号即可 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:2:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#版本回退"},{"categories":null,"content":"回退问题: 如何跳到某个指定commit_id的版本? 假如你刚提交了一个版本, 现在后悔了想返回到前一个版本, 应该使用什么命令? 假如你回退到前某个版本, 现在后悔了, 想返回到最近的某个版本, 但是 commit_id 不记得, 该怎么办? ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:2:1","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#回退问题"},{"categories":null,"content":"回退总结: HEAD 为当前版本, 使git reset --hard commit_id 可以跳到对应的版本 git reflog 命令可以查看所有操作的记录, 可以用于查找所需要的版本号 tip: HEAD表示当前版本, HEAD^表示前一个提交版本, HEAD^^为前2个提交的版本, HEAD~100 为第前100个版本 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:2:2","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#回退总结"},{"categories":null,"content":"撤销修改 前一节所说的版本回退有个缺点, 那就是, 回退到前一个版本, 所有相关文件的最新修改均会丢失. 并且版本回退是针对已提交的内容的. 现在有个新问题: 在git管理的版本下, 撤销对某个文件的修改. 这之前要了解一下git管理的基本逻辑. ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:3:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#撤销修改"},{"categories":null,"content":"git 基本逻辑 git仓库其实分为工作区(working tree), 暂存区(stage), 和 仓库() 工作区就是我们看到和使用的部分 暂存区是我们使用 git add filename 后文件所到达的部分 仓库是我们使用 git commit 后文件所在的部分 在使用 git commit 命令时, 只会将暂存区部分的内容保存到仓库 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:3:1","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#git-基本逻辑"},{"categories":null,"content":"文件修改的撤销 在上一次提交后, 本次我们对某个文件进行了修改, 发现修改后程序运行出错了. 现在删除对文件的修改, 应该怎么做(并未使用 git add命令)? 这时需要的命令为 git checkout -- filename. 对文件修改后查看工作区状态: 可以看到有修改, 这时使用 git checkout filename 后结果为: 再次查看文件, 修改己经没有了 假设这次我们对文件进行了修改, 且已经使用了 git add filename了该怎么办呢? 办法是使用 git reset HEAD filename 记其回到未 add 的情况. 我们将修改添加到暂存区, 并查看状态: 先看一下与前面的区别, 未add时, 字是红色的, 提示信息是\"尚未暂存以备提交的变更\" 使用 git add filename 后提示信息是\"要提交的变更\" 此时使用 git reset HEAD filename 后的状态为: 可以看到取消了暂存的变更, 这时查看状态则又到了修改未提交的状态了. 此时再使用 git checkout -- filename 命令即可以撤销修改了. ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:3:2","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#文件修改的撤销"},{"categories":null,"content":"撤销问题 有修改, 但是未添加到暂存区, 如何撤销? 有修改, 已添加到暂存区, 如何撤销? ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:3:3","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#撤销问题"},{"categories":null,"content":"撤销总结 git checkout -- filename 撤销对工作区文件的修改 git reset HEAD filename 撤销对文件的暂存操作 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:3:4","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#撤销总结"},{"categories":null,"content":"文件删除 git仓库的文件删除和正常文件夹的删除不大一样, 因为git将删除也视为了一个操作, 因此删除也需要提交. 正常删除文件后查看仓库状态: 同样, 使用 git checkout -- filename也可以取消该操作. 使用 git rm filename 删除文件后查看状态: 可以看到, 直接删除后提示信息是红色的, 且提示信息是\"修改尚未加入提交\". 也就是说, 这时还需要使用 git add命令才可以使用 git commit将删除操作提交到仓库. 而 git rm filename则可以直接将删除提交到仓库. 对于已添加,未添加的修改如何撤销可见上一节. ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:4:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#文件删除"},{"categories":null,"content":"删除问题 若要删除仓库中的文件应如何操作? 直接删除与使用 git rm 命令删除有何不同? 删除后如何撤销? ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:4:1","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#删除问题"},{"categories":null,"content":"删除总结 删除与修改一样, 都是要提交到仓库的 使用 git rm 操作相当于使用 直接删除并使用了 git add 命令 删除的撤销可根据是否添加到暂存区同修改一样操作 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:4:2","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#删除总结"},{"categories":null,"content":"分支 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:5:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#分支"},{"categories":null,"content":"创建与合并 分支的创建与删除: git branch branch_name 创建新分支前: 创建新分支后: git branch newBranch (* 表示当前HEAD所在的分析, 即当前工作区的分支) 切换分支: git checkout newBranch 可以看到 * 从main到了newBranch 分支删除: git branch -d newBranch (不能删除当前所在分支, 因此要先切回main分支才可执行该操作) 分支的合并现有两个分支:main和bugFix 合并前: 将HEAD放在main分支上, 并执行 git merge bugFix: 可以看到, 合并会产生一个新的提交, 且当前节点有了两个父节点. 这里其实可以更深入理解下git checkout这个命令, 它的真实作用是切换当前工作区在git这个仓库树中的位置.即, HEAD可以指向main或者bugFix这种具体的分支名, 也可以指向某一个commit_id(每一个commit_id即是工作区的一个版本) ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:5:1","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#创建与合并"},{"categories":null,"content":"冲突的修正 假如我们现在有2个分支: master和newBranch, 在这两个分支中我们都对一个文件进行了修改. 这时, 将newBranch分支合并到master分支时就会出现冲突: 这里master分支中我们添加的内容是\"Creating a new branch!!!“并提交了. 在newBranch分支中我们添加的内容是\"Create a new branch!!!”. 所以在HEAD处于master分支, 并运行 git merge newBranch时会出现冲突. 我们打开提示的冲突文件, 文件内容如下: Git用\u003c，=，\u003e标记出不同分支的内容，我们修改如下后保存： 这时查看仓库状态为: 此时将其添加到仓库并提交 这时查看日志树可以看到合并过程: ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:5:2","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#冲突的修正"},{"categories":null,"content":"分支问题 如何创建分支与删除分支? 如何在不同分支中进行切换? 如何合并不同的分支? 合并分支后有冲突了该怎么办? ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:5:3","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#分支问题"},{"categories":null,"content":"分支总结 分支创建: git branch branch_name 分支删除: git branch -d branch_name 将其他分支合并到当前分支: git merge other_branch 分支切换: git checkout branch_name 冲突解决: 修正冲突的文件并添加到暂存区, 然后提交 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:5:4","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#分支总结"},{"categories":null,"content":"高级篇:命令详解 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:0","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#高级篇-命令详解"},{"categories":null,"content":"分离HEAD 这是一个很小的概念, 单独说它, 就是因为它很重要. 其实git是由不同的提交组成, 每个提交都可以看成一个树中的节点. 所有的提交在一起组成了一个提交树. 而当前的工作区(也就是我们能看到并修改的那些文件), 就是HEAD所指向的. 其实HEAD并不是非要指向具体的分支, 它也可以直接指向某个提交. 比如当前的提交树为: 可以看到*在bugFix这个分支上, 这也表示HEAD指向bugFix, 我们可以直接让它指向C4 git checkout C4 (这里的C4是提交id): 同样, 也可以使用这个命令让它指向 main, 或者 C0: 其实checkout这个命令用来切换HEAD的指向并不准确, 新版的git使用switch命令 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:1","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#分离head"},{"categories":null,"content":"相对引用(^) 在不同的仓库进行切换时, 使用commit id十分麻烦, 因为id需要使用git log命令查找, git提供了相对引用, 即^表示上一个, ^^表示上2个, ~10 表示前10个. 如使用 git checkout main^ 效果为: 可以看到当HAED指向main时, HEAD^和main^都是指向C5的. 再次使用 git checkout HEAD~3 结果为: ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:2","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#相对引用"},{"categories":null,"content":"撤销变更 (reset \u0026 revert) 当本地出错要回退时, 有2个命令可用. reset可将当前分支回退到指定提交. 可看执行结果: 原本提交树是这样, 使用 git reset HEAD^ 后: 可以看到, 这个命令让分支放弃了当前节点而指向了父节点. 若对原本的提交树使用 git revert HEAD^ 命令后的提交树为: 可以看到, 现在这人分支指向了C1’这个提交, 其实C1’与C1是相同的, 但是 git 将回退作为一个操作然后提交到仓库. 这样做的好处: 在本地其实是没有什么区别的, 但是如果推送到远程, 使用git reset后若要与远程同步, 需要将远程的最新提交删除, 这个操作难以实现, 因此将回退作为一个新的提交可以方便远程与本地的同步, 方便多人合作. ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:3","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#撤销变更--reset-and-revert"},{"categories":null,"content":"提交树的节点移动 (rebase \u0026 cherry-pick) rebase: 它的主要作用是创建线性提交记录, 方便工程修改脉路整理. 比如对于当前提交树: 我们使用 git rebase main后提交树变化为: 现在分析一下这个结果. feature 和 main 分支的公共父节点是C1, 我在的HEAD指向feature, 此时运行以上命令后, git 将C2,C4 提交接到了main所指向的C3上, 也就是说: 这个命令会将当前分支的所有提交接到指定的分支上 因此 rebase 可以表象地理解为 剪枝 + 嫁接 如果使用merge命令的话提交树会变为: 这时提交记录则不够线性, 不方便查看对工程的修改历史 rebase 的另一个功能: 提交记录排序与删除. git rebase -i HEAD~4: 这个命令会弹出一个交互式的创口, 让你调整最新4个提交节点的顺序或者删除提交节点. 下面是一个例子: 知道这个功能即可, 不具体说明了 cherry-pick: 这个命令允许我们随意地移动提交树中的节点, 将指定的提交节点移动到当前的HEAD所指定的节点下. 对以下提交树: 使用 git cherry-pick C2 C4 C6 后结果为: 可以看到, 选中的提交节点都添加到了当前分支 main 所指向的节点下. 这样的命令有什么作用呢? 场景一: 当前出了一些问题, 可此需要新建一些分支来解决, 最终解决了当前的问题: 但是此时, 我们只想要收录解决问题的提交到当前的main下, 此时就可以使用 rebase -i 和 cherry-pick 这两个命令来实现. 将HEAD调整到main分支上, 再使用 git cherry-pick C4 (左) 或者使用 git rebase -i HEAD~3 后调整提交 (右) 即可获得: 场景二: 更新历史提交节点中的信息 下面的提交树中, 我想更新newImage提交中的信息, 且是只更新它的信息, 可使用 rebase -i 和 cherry-pick 这两种方式来实现. 口述使用 rebase -i 命令过程: 先调整C2和C3顺序,将C2提交节点放到最前, 再使用 git commit --amend 来提交列新C2中的信息, 最后使用 rebase -i 命令将C3节点放到最前. 详细说明 cherry-pick 过程 (因为不用交互, 易于博客中展示). 首先调整HEAD到main: git checkout main 其次, 将C2 拿到最前: git cherry-pick C2 然后, 修改C2中的内容并提交: git commit --amend 最后, 将C3节点放到最前: git cherry-pick C3 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:4","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#提交树的节点移动--rebase-and-cherry-pick"},{"categories":null,"content":"提交树的节点移动 (rebase \u0026 cherry-pick) rebase: 它的主要作用是创建线性提交记录, 方便工程修改脉路整理. 比如对于当前提交树: 我们使用 git rebase main后提交树变化为: 现在分析一下这个结果. feature 和 main 分支的公共父节点是C1, 我在的HEAD指向feature, 此时运行以上命令后, git 将C2,C4 提交接到了main所指向的C3上, 也就是说: 这个命令会将当前分支的所有提交接到指定的分支上 因此 rebase 可以表象地理解为 剪枝 + 嫁接 如果使用merge命令的话提交树会变为: 这时提交记录则不够线性, 不方便查看对工程的修改历史 rebase 的另一个功能: 提交记录排序与删除. git rebase -i HEAD~4: 这个命令会弹出一个交互式的创口, 让你调整最新4个提交节点的顺序或者删除提交节点. 下面是一个例子: 知道这个功能即可, 不具体说明了 cherry-pick: 这个命令允许我们随意地移动提交树中的节点, 将指定的提交节点移动到当前的HEAD所指定的节点下. 对以下提交树: 使用 git cherry-pick C2 C4 C6 后结果为: 可以看到, 选中的提交节点都添加到了当前分支 main 所指向的节点下. 这样的命令有什么作用呢? 场景一: 当前出了一些问题, 可此需要新建一些分支来解决, 最终解决了当前的问题: 但是此时, 我们只想要收录解决问题的提交到当前的main下, 此时就可以使用 rebase -i 和 cherry-pick 这两个命令来实现. 将HEAD调整到main分支上, 再使用 git cherry-pick C4 (左) 或者使用 git rebase -i HEAD~3 后调整提交 (右) 即可获得: 场景二: 更新历史提交节点中的信息 下面的提交树中, 我想更新newImage提交中的信息, 且是只更新它的信息, 可使用 rebase -i 和 cherry-pick 这两种方式来实现. 口述使用 rebase -i 命令过程: 先调整C2和C3顺序,将C2提交节点放到最前, 再使用 git commit --amend 来提交列新C2中的信息, 最后使用 rebase -i 命令将C3节点放到最前. 详细说明 cherry-pick 过程 (因为不用交互, 易于博客中展示). 首先调整HEAD到main: git checkout main 其次, 将C2 拿到最前: git cherry-pick C2 然后, 修改C2中的内容并提交: git commit --amend 最后, 将C3节点放到最前: git cherry-pick C3 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:4","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#场景一-当前出了一些问题-可此需要新建一些分支来解决-最终解决了当前的问题"},{"categories":null,"content":"提交树的节点移动 (rebase \u0026 cherry-pick) rebase: 它的主要作用是创建线性提交记录, 方便工程修改脉路整理. 比如对于当前提交树: 我们使用 git rebase main后提交树变化为: 现在分析一下这个结果. feature 和 main 分支的公共父节点是C1, 我在的HEAD指向feature, 此时运行以上命令后, git 将C2,C4 提交接到了main所指向的C3上, 也就是说: 这个命令会将当前分支的所有提交接到指定的分支上 因此 rebase 可以表象地理解为 剪枝 + 嫁接 如果使用merge命令的话提交树会变为: 这时提交记录则不够线性, 不方便查看对工程的修改历史 rebase 的另一个功能: 提交记录排序与删除. git rebase -i HEAD~4: 这个命令会弹出一个交互式的创口, 让你调整最新4个提交节点的顺序或者删除提交节点. 下面是一个例子: 知道这个功能即可, 不具体说明了 cherry-pick: 这个命令允许我们随意地移动提交树中的节点, 将指定的提交节点移动到当前的HEAD所指定的节点下. 对以下提交树: 使用 git cherry-pick C2 C4 C6 后结果为: 可以看到, 选中的提交节点都添加到了当前分支 main 所指向的节点下. 这样的命令有什么作用呢? 场景一: 当前出了一些问题, 可此需要新建一些分支来解决, 最终解决了当前的问题: 但是此时, 我们只想要收录解决问题的提交到当前的main下, 此时就可以使用 rebase -i 和 cherry-pick 这两个命令来实现. 将HEAD调整到main分支上, 再使用 git cherry-pick C4 (左) 或者使用 git rebase -i HEAD~3 后调整提交 (右) 即可获得: 场景二: 更新历史提交节点中的信息 下面的提交树中, 我想更新newImage提交中的信息, 且是只更新它的信息, 可使用 rebase -i 和 cherry-pick 这两种方式来实现. 口述使用 rebase -i 命令过程: 先调整C2和C3顺序,将C2提交节点放到最前, 再使用 git commit --amend 来提交列新C2中的信息, 最后使用 rebase -i 命令将C3节点放到最前. 详细说明 cherry-pick 过程 (因为不用交互, 易于博客中展示). 首先调整HEAD到main: git checkout main 其次, 将C2 拿到最前: git cherry-pick C2 然后, 修改C2中的内容并提交: git commit --amend 最后, 将C3节点放到最前: git cherry-pick C3 ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:4","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#场景二-更新历史提交节点中的信息"},{"categories":null,"content":"tag 前文中提交节点要么是使用提交ID标识的, 要么是使用分支名子标识的. 分支名字会被移动, 且有新的提交时分支名字也会移动到新的提交节点中, 提交ID太长,难记.因此需要一个为某个提交节点进行永久命各的办法: 它就是tag. 对于以下的提交树: 为不同的提交节点添加tag, 如运行命令: git tag V1 C1, git tag V2 C2, 这时的提交树为: 同时, 可以直接利用tag名称来移动HEAD: git checkout V1 可以看到这时HEAD指向了C1. 为什么不是V1* 呢, 这是因为无支对某个tag直接提交, 所以才会发生这种分离HEAD的现象. ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:5","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#tag"},{"categories":null,"content":"describe git describe \u003cref\u003e: \u003cref\u003e 为提交树中的引用, 默认为HEAD. 该命令的输出结果为: \u003ctag\u003e_\u003cnum\u003e_g\u003chash\u003e, tag为与该引用最近的标签, num 为 该引用与最近标签的间隔提交数, \u003chash\u003e为\u003cref\u003e的提交ID. 对于以下的提交树, 使用 git describe, git describe main, git describe side 的结果分别为: ","date":"2022-08-06","objectID":"/posts/org_04_git_usage/:6:6","series":null,"tags":["git"],"title":"Git的基本使用","uri":"/posts/org_04_git_usage/#describe"},{"categories":null,"content":"系列目的 介绍Git的基础配置及基础使用 介绍Magit的使用, 因为Magti相比与Git方便很多, 配合Emacs效率更高 ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:1:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#系列目的"},{"categories":null,"content":"使用命令行 windows 中使用bash, linux或Mac下使用terminal, 总之要开使用Git, 就要用命令行 要做的第一件事是检查电脑上是否安装了Git, 使用命令: git –version查看, 安装了则会返回版本号 没安装就去官网安装下 ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:2:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#使用命令行"},{"categories":null,"content":"配置Git的名字和邮箱 让Git知道你是谁, 两条命令: git config --global user.name \"your_name\" git config --global user.email \"your_email\" git config --list: #列出配置信息 git config --unset --global user.name # 取消名称设置 不使用 global 参数,则设置的是本仓库的信息 ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:3:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#配置git的名字和邮箱"},{"categories":null,"content":"配置Git代理 # 设置当前代理 git config http.proxy http://127.0.0.1:2334 # 取消当前代理 git config --unset http.proxy #设置socks5代理 git config http.proxy socks5://127.0.0.1 #取消全局代理 git config --global --unset http.proxy ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:4:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#配置git代理"},{"categories":null,"content":"初始化Git仓库 在需要使用Git管理的仓库中运行 git init 即可 ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:5:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#初始化git仓库"},{"categories":null,"content":"Magit 这是Emacs下的一个Git工具, 直接在Emacs下安装该包即可, 一般现有的Emacs工具都被作者安装好了. Emacsh下Magit的打开方式: M-x magit-status ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:6:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#magit"},{"categories":null,"content":"Git趣味学习 这个游戏可以学习基础； 这个网站可以助你熟练掌握命令； ","date":"2022-08-06","objectID":"/posts/org_03_git_get_started/:7:0","series":null,"tags":["git"],"title":"Git 与 Magit 初始篇","uri":"/posts/org_03_git_get_started/#git趣味学习"},{"categories":null,"content":"emacs: ox-hugo emacs里面主要是使用ox-hugo这个插件, 将所写的org文件转成md文件, 当然转换中仍有一些问题, 但勉强可以使用. ","date":"2022-08-04","objectID":"/posts/org_02_hugo_with_emacs/:1:0","series":null,"tags":["博客"],"title":"使用emacs写hugo博客","uri":"/posts/org_02_hugo_with_emacs/#emacs-ox-hugo"},{"categories":null,"content":"ox-hugo的安装 M-x list-packages: 这个命令会列出所有的可安装的包 C-s: 使用搜索找到ox-hugo 操控高亮到ox-hugo, 按i x 这两个字母, i表示Install, x表示eXecute. 在配置文件中添加ox-hugo配置 (use-package ox-hugo :ensure t ;Auto-install the package from Melpa :pin melpa ;`package-archives' should already have (\"melpa\" . \"https://melpa.org/packages/\") :after ox) 这时在org模式里就可以使用hugo了 C-c C-e时会多一个导出选项: 如果按以上操作, 有这一项出来, 那么ox-hugo才算成功, 没有就排查错误, 比如ox-hugo有没有安装上, 配置信息有没有加对地方 ","date":"2022-08-04","objectID":"/posts/org_02_hugo_with_emacs/:2:0","series":null,"tags":["博客"],"title":"使用emacs写hugo博客","uri":"/posts/org_02_hugo_with_emacs/#ox-hugo的安装"},{"categories":null,"content":"ox-hugo的使用 将org文件使用ox-hugo导出时,需要加一些配置才能导出到正确的位置.我参考这个配置: #+OPTIONS: author:nil ^:{} #+HUGO_FRONT_MATTER_FORMAT: YAML #+HUGO_BASE_DIR: 博客的根目录 #+HUGO_SECTION: posts/ #+HUGO_CUSTOM_FRONT_MATTER: :toc true #+HUGO_AUTO_SET_LASTMOD: t #+HUGO_TAGS: 标签1 标签2 #+HUGO_CATEGORIES: 类别 #+HUGO_DRAFT: false #+TITLE: 博客名字 这其实是一个重复性的工作, 因此使用Yasnippet模板 配置Yasnippet模版(安装使用部分略, 使用的Centaur Emacs贡献者已安装配置好了) 使用: M-x yas-new-snippet (C-c \u0026 C-n) 调出添加模板界面 添加以下内容, 再保存(起个名字:hugo, 这默认保存在~/.emacs.d/snippets/org-mode/hugo中) # -*- mode: snippet -*- # name: hugo_blog # key: \u003ehugo # -- #+OPTIONS: author:nil ^:{} #+hugo_front_matter_format: yaml #+HUGO_BASE_DIR: ../ #+HUGO_SECTION: posts/ #+DATE: `(format-time-string \"[%Y-%m-%d %a %H:%M]\")` #+HUGO_CUSTOM_FRONT_MATTER: :toc true #+HUGO_AUTO_SET_LASTMOD: t #+HUGO_TAGS: $1 #+HUGO_CATEGORIES: $2 #+HUGO_DRAFT: false #+TITLE: $3 模板解释: 1. key: 后面部分, 这个是所使用的快捷键；2. #–: 后面的部分是模板 这时输入在文中 \u003ehugo, 再按TAB后就可以弹出模板内容 #+OPTIONS: author:nil ^:{} #+hugo_front_matter_format: yaml #+HUGO_BASE_DIR: ../ #+HUGO_SECTION: posts/ #+DATE: [2022-08-05 Fri 00:41] #+HUGO_CUSTOM_FRONT_MATTER: :toc true #+HUGO_AUTO_SET_LASTMOD: t #+HUGO_TAGS: #+HUGO_CATEGORIES: #+HUGO_DRAFT: false #+TITLE: ","date":"2022-08-04","objectID":"/posts/org_02_hugo_with_emacs/:3:0","series":null,"tags":["博客"],"title":"使用emacs写hugo博客","uri":"/posts/org_02_hugo_with_emacs/#ox-hugo的使用"},{"categories":null,"content":"部署博客到github 在博客目录下运行 hugo 命令, 这是会更新根目录下public文件夹里的内容 申请一个仓库, 这个仓库是需要与用户名同名的:your_name.github.io 申请完后会有一些提示教你怎么去将本地仓库提交到github上 在本地的public目录下创建git目录 git init git add * git commit -m \"commit 1st\" git remote add origin https://github.com/your_name/your_name.github.io.git git push -u origin main 在提交的时候可能需要用到用户名your_name与密码,密码改为申请密钥 密钥申请: 点setting 选择developer settings 选择第三个 personal access tokens 点generate new token 对note, expiration 和 scopes进行设置即可. note是你这个token的名字, expiration是这个token的有效时间, select scopes是这个token的作用范围, 如果都不选这个token就一点用都没有 ","date":"2022-08-04","objectID":"/posts/org_02_hugo_with_emacs/:4:0","series":null,"tags":["博客"],"title":"使用emacs写hugo博客","uri":"/posts/org_02_hugo_with_emacs/#部署博客到github"},{"categories":null,"content":"自动推送脚本 hugo cd public git add . msg=\"rebuilding site `date`\" if [ $# -eq 1 ] then msg=\"$1\" fi git commit -m \"$msg\" git push cd .. 这里会需要输入github的用户名和密码,密码是前面创建的token 最后等仓库的action页面build完成就行了, 一般就是等一会 ","date":"2022-08-04","objectID":"/posts/org_02_hugo_with_emacs/:5:0","series":null,"tags":["博客"],"title":"使用emacs写hugo博客","uri":"/posts/org_02_hugo_with_emacs/#自动推送脚本"},{"categories":null,"content":"ubuntu 18.04安装hugo最新稳定版 在站上下载安装包 https://github.com/gohugoio/hugo/releases 安装即可 `sudo hugo version`查看版本 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:1:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#ubuntu-18-dot-04安装hugo最新稳定版"},{"categories":null,"content":"创建hugo站 hugo new site hello-world 这个命令会创建一个hello-world文件夹 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:2:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#创建hugo站"},{"categories":null,"content":"进入 hello-world文件夹 cd hello-world sudo hugo 即可显示提示信息, 若不这样显示, 就是出错了, 网上查别的教程吧 至此安装完成 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:3:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#进入-hello-world文件夹"},{"categories":null,"content":"选择主题 hugo这个博客是需要配合现有的主题的, 我这里使用的是DoIt主题 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:4:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#选择主题"},{"categories":null,"content":"主题下载 在这个网址下臷主题网址,我选择的是DoIt. DoIt的使用教程在这里 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:4:1","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#主题下载"},{"categories":null,"content":"主题使用 下载主题并放到./hello-world/themes文件夹里 修改配置文件,就是根目录下的config.toml, 这里使用的是DoIt网站上提供的默认配置 baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" title = \"My New Hugo Site\" # Change the default theme to be use when building the site with Hugo theme = \"DoIt\" [params] # DoIt theme version version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 # Markup related configuration in Hugo [markup] # Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false is a necessary configuration (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 打开hugo服务: hugo server (若要远程打开, 则命令为:hugo server –bind 0.0.0.0) 打开博客页面: http://localhost:1313 ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:4:2","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#主题使用"},{"categories":null,"content":"头像 先弄个需要作为头像的图片, 将其放到/static/images/avatar.jpg 在配置文件中添加(这里图片的URL相对目录是相对根目录下static或assert目录的) [params.home.profile] enable = true # Gravatar Email for preferred avatar in home page gravatarEmail = \"\" # URL of avatar shown in home page avatarURL = \"/images/avatar.jpg\" 将DoIt中/exampleSite/content文件夹中除posts以外的内容都复制到本博客的/content文件夹中(在此之前这个/content文件夹只有posts一个文件夹) 重新运行博客就有头像了 效果: ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:4:3","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#头像"},{"categories":null,"content":"hugo内容组织 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:5:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#hugo内容组织"},{"categories":null,"content":"本地资源 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:5:1","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#本地资源"},{"categories":null,"content":"添加评论系统 因为博客托管在github上, 因此使用utterances评论系统, 这个评论系统使用的是github中的issue模块来存储评论内容, 因此要评论首先要登录github账号. 首先安装utterances, 点进这个网址, 选择你要的作为评论系统的repository(可以建个新的, 也可以用已有的, 但必须是public类型的repository), 记录下你的仓库名. 有人在这里提供了详细操作截图. 将仓库名写入配置文件 # DoIt NEW | 0.2.5 Utterances comment config [params.page.comment.utterances] enable = true # owner/repo repo = \"forrestk3/forrestk3.github.io\" issueTerm = \"title\" label = \"\" lightTheme = \"github-light\" darkTheme = \"github-dark\" 这里要修改的有两处: enable 后在改成 true；repo 后面改成你的用户名/仓库名, 这个仓库名就是前面在utterances安装时选择的仓库, 是需要授权的；其实issueTerm使用默认的也行, 但我觉得\"title\"类型更合理. 前面修改完后, 重新启动博客就可以在末尾看到我们添加的评论系统了, 效果如下, 因为我登录了, 所以能看到头像 这里需要注意的一点, 有的主题默认配置中有一项baseURL需要注释掉, 否则评论系统添加不成功(找了半天的错误) 当我们添加评论后, 相关项目的issue会出评论留存. 查看项目issue: ","date":"2022-08-04","objectID":"/posts/org_01_hugo_install/:6:0","series":null,"tags":["博客"],"title":"hugo安装与入门","uri":"/posts/org_01_hugo_install/#添加评论系统"},{"categories":["科研学习"],"content":" Rossow C. Amplification Hell: Revisiting Network Protocols for DDoS Abuse[C]//NDSS. 2014. 本文重审各种基于UDP的协议，并分析哪些易用于RDOS，总结目前已被用作的RDOS和应对措施分析。本文主要有三总分组成：threat model,vulnerable protocols,realword attacks countmeasure。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:0:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#"},{"categories":["科研学习"],"content":"Threat model A要利用反射攻击V。 A：可发包的网络攻击者 V：网络实体。 ${M_p}$:所有可能的潜在放大器，如图1所示： 攻击者发包给$M_p$,$M_p$响应给V，其中响应包要多得多，使V的网络过载。$M_p$为运行了可能会被用于放大器的协议的实体。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:0:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#threat-model"},{"categories":["科研学习"],"content":"Amplification Vulnerablity 表1列举了可能被用于DRDOS的协议，没有列举不能放大的协议。 使用scanning,crawling,querying来枚举这14个协议。 对网络服务，通过扫描抽样估计网络中可能的放大器个数。 对于P2P协议，通过迭代爬取所有peer列表，爬取所需信息可通过读源码，逆向来获取。爬取1小时结速，结果作为lower bounds。实现过程见[26] 对于游戏服务协议，通过查询的方式获得可用的游戏服务器列表。 这里对于DNS考虑两类：open resolver记为：$DNS_{OR}$,authoritative name servers,记为：$DNS_{NS}$ 表2这列举结果，记录了发现1k和发现100k的时间。该结攻击者可轻易获得放大器。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:0:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#amplification-vulnerablity"},{"categories":["科研学习"],"content":"Amplification Factors 这里分析每个协议的放大因子。使用BAF表示字节放大效果， $B A F=\\frac{\\operatorname{len}(U D P \\text { payload }) \\text { amplifier to victim}}{\\operatorname{len}(U D P \\text { payload }) \\text { attacker to amplifier}}$ 它的意思为：$\\frac{返回字节}{发送字节}$，当然这里去掉了一些无关的头。对于包讨大效果，使用PAF，表示为： $P A F=\\frac{\\text {number of packets amplifier to victim}}{\\text {number of packets attacker to amplifier}}$ 它的意思是$\\frac{返回包数}{发送包数}$ 表3为对每个协议的BAF和PAF的测量结果。 下面对每个协议作分析： SNMP：它的GetBuld会有放大功能，最大BAF为：11.3 NTP：它的monlist请求会被用于放大攻击。 DNS：对于ANY请求，OR会导致放大，BAF为：28.7-64.1，布署了DNSSEC后对NS发ANY请求放大因子为：54.6-98.3 NetBios:使用name lookup,BAF为3.8-4.9 SSDP： discovery请求，BAF为：30.8-75.9 CharGen:对UDP报返回随机大小的字符，数量太少未统计BAF QOTD：如6,BAF平均为：140.3 BitTorrent:Hash搜索，BAF为：3.8-10.3 Kad：可利用peer列表交换来攻击，同6未统计BAF Quade 3:请求服务器当前状态。BAF：63.9-82.8 Steam:同10,BAF：5.5-14.7 ZeroAccess:peer list和comamand exchange,BAF:36.0-41.1 Sality:换文件的URL list,BAF:L37.3-38.4 Gameover:peer list和proxy list交换机制，BAF：46 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:1:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#amplification-factors"},{"categories":["科研学习"],"content":"Real-world observations 找victim和amplifier 找暗网的port scan 流量 放置amplification bait ##数据集 Netflow data：使用Netflow采集的数据集，2013-6-14~2013-6-25这12天的数据。 Darknet traffic:不知道从哪弄的暗网流量数据集，D1为/17网络，D2为/27网络，收集4周的暗网流量 诱饵：放置可用于放大器的服务器诱饵（大手笔）诱饵可能会被用于真实攻击，这无法避免，就当他们为科学献身了。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:0:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#real-world-observations"},{"categories":["科研学习"],"content":"Realword amplificationscans 利用手头上的暗网数据集D1,D2,检测哪可能被扫描，表4列出了前10的UDP扫描端口，该表可见DNS，CharGen,NetBios,SNMP易受攻击（我也没看出来他怎么得出这个结论的。） 在D2中手动检测这些协议发现攻击者钟意Open Resolver。对其他协议的扫描： CharGen:发送one byte UDP payload NetBios:equal name queries SNMP:mixture of bulk,nonbulk requests NTP和SSDP黑客们不大喜欢 这次分析也发现一些不在本文列举范围内的协议：MSSQL，SIP，Teredo tunnels ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:1:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#realword-amplificationscans"},{"categories":["科研学习"],"content":"Realword DRDoS Victims 图2列出了受攻击的情形，在V看来可通过in和out流量不均来检测。 Netflow利用这个特征监控流量，为了简化，只观察固定UDP端口，通过（IP，UDP PORT）识别server，client只用IP来识别，以此创建pairflow: pair $f l o w :=\u003cC_{I P}, S_{I P}, S_{p o r t}, B_{2 s}, B_{2 c}, t\u003e$ 这里的$B_{2s}$为to server的通信负载字节数。$B_{2c}$同理。 每小时计算一次pariflow,并找victim，条件为：1.流量超过一定阈值，$T_B=100000$B。2.接收流量远大于发送流量$rf=\\frac{f.B_{2s}}{f.B_{2c}} \\gt T_r=1000$。另外，丢弃所有pairflows,server are within the network of the ISP。 结果： 表5列出victim的相关情况，IP使用A-I标签代替。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:2:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#realword-drdos-victims"},{"categories":["科研学习"],"content":"Realworld amplifier Abuse 检测Amplifier比victim更难，因为攻击者的行为合法用户也会做。，如图3所示。 这里通过设定不同的阈值只进行，$T_r=5,T_B=10000000$ 结果：检测到143个可疑pariflows，6个DNS OR 被用于55个攻击，4个CharGen被用于57个攻击，5个SNMP和3个Steam可疑。被用于攻击的诱饵中CharGen和Quade3 game server被用于攻击。 总体看来，现实中很多amplifier都被用于attack。 ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:3:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#realworld-amplifier-abuse"},{"categories":["科研学习"],"content":"countermeasures 禁止IP欺骗的方法：不行，世界各地都有支持IP欺骗。 强化协议设计： 会话握手：只有通过一定的验证才给予响应。延迟，额外开销，需要要协议布置前进行这种设计。 请求向应对称：降低有效性 限制请求发送率：不行，amplifier太多，攻击者可控制一个网络，不好的设计还会被attacker利用。 更安全的服务配置：如SNMP无密码在网络中暴露，那就设个密吗；当前网络设备大多是缺省配置，所以一个好的配置是管用的。 基于包的过滤： IP过滤：DRDOS是分布式的，不行 PORT：测量放大器对响应端口的频率 包大小: 负载字符串的匹配：搜索响就中的静态子串。 表7为统计结果 该方法只能用于预选候选攻击流量，并且有些服务没有任何这些检测特征。 本文的一些参考文献不错 DDoS attack type:[4][7][12][20][29][32][33][34][35] DDoS Detection and Mitigation:[10][28][39][13][9][41][25][11][23][31] DDoS Attack Analysis:[3][17] ","date":"2019-09-14","objectID":"/posts/31_amplification_hell/:0:0","series":null,"tags":["论文阅读"],"title":"Amplification Hell: Revisiting Network Protocols for DDoS Abuse.","uri":"/posts/31_amplification_hell/#countermeasures"},{"categories":["科研学习"],"content":" Sekar V, Duffield N G, Spatscheck O, et al. LADS: Large-scale Automated DDoS Detection System[C]//USENIX Annual Technical Conference, General Track. 2006: 171-184. 本文提出LADS，根据轻量级和重量级DDoS检测优缺点进行分析提出两阶段检测法。首先检测是可能有异常，再通过流收集器进一步检测以决定是否发出警告。 ","date":"2019-09-13","objectID":"/posts/30_lads/:0:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#"},{"categories":["科研学习"],"content":"LADS ","date":"2019-09-13","objectID":"/posts/30_lads/:0:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#lads"},{"categories":["科研学习"],"content":"基本概念 ###系统目标： 正确率 实时性 对所有的客户有效 ","date":"2019-09-13","objectID":"/posts/30_lads/:1:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#基本概念"},{"categories":["科研学习"],"content":"Lightweight Anomaly Detection 轻量级检测阶段不太关心FP，因为它只会误触下一阶段检测，但关心FN，因为会漏检测。 Volumn anomaly detection:建立预测模型预测流体积是否异常 检测流量分布是否异常，可用于进一不分析。 ","date":"2019-09-13","objectID":"/posts/30_lads/:1:1","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#lightweight-anomaly-detection"},{"categories":["科研学习"],"content":"Focused Anomaly Detection 重量级检测需要注意解决计算代价和正确率。 Rule-based detection:有些攻击有时显特征，可以用rule匹配检测。 Uni-dimensional aggregation:单维层次收集算法，使用源/目的IP前缀发现可能的攻击者。 Multi-dimensional culstering:利用IP5元组分析。 ","date":"2019-09-13","objectID":"/posts/30_lads/:1:2","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#focused-anomaly-detection"},{"categories":["科研学习"],"content":"Lightweight Anomaly Detection 利用SNMP出口包计数判断体积异常，根据已存的数据获得要预测进间段的历史数据的模型(均值，方差)根据过去k周的历史数据，每个时间段以这k个数据预测mean和噪声，如图4.再利用历史数据和当前观察数据计算偏移值，（如果偏移值过大，就进行触发检测事件）如图5。 以上，计算好后进行临时聚类，如图6. $\\alpha_{add}:event扩展阈值，\\alpha_{trigger}：event触发阈值，keepalive：持续时间$ 当偏移值超过$\\alpha_{add}$时，有event就扩展该event，没有就创建event。可以设定阈值移除所有低于它的警告，移除一些连接重置或SNMP bug警告。 异常以egress接口，start time，end time标记发往下一阶段。 ","date":"2019-09-13","objectID":"/posts/30_lads/:2:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#lightweight-anomaly-detection-1"},{"categories":["科研学习"],"content":"Focused Anomaly Detection 收集netflow record 信息 构造如下数据集： TCP SYN flag set(SYN set) TCP RST flag set(RST set) ICMP flows(ICMP set) All flow record(All set) 对每个数据集报告体积并附带IP目的前缀，使用F8算法计算并产生攻击警告，警告条件：All set的前缀小于/28但流量大于bandwidth Attack Threshold，或SYN/ICMP/RST集中观察的前缀IP范围大于相应配置值。 这里的阈值是更新的，更新公式：$Rate(Duartion)=Rate(BaseDuration)*DecreaseFactor^{\\frac{Duration}{BaseDuration}}$.BaseDuration定为300s,DecreaseFactor定为0.95。 图8有算法由两个步骤组成： aggregation:计数总体规定前缀流量中大于最小规定前缀流量的数。 reprot:根据前一步计算决定报告某前缀是否为潜在的攻击目标，前缀大小对应的流量阈值固定。 根据实验，本方法更高效。 ","date":"2019-09-13","objectID":"/posts/30_lads/:3:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#focused-anomaly-detection-1"},{"categories":["科研学习"],"content":"Exprement ","date":"2019-09-13","objectID":"/posts/30_lads/:0:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#exprement"},{"categories":["科研学习"],"content":"基本介绍 SNMP feeds:SNMP每5分钏报告一次如下信息： total traffic volume per interface router utilization information Netflow Feeds:以1：500抽样收集网络包 Alarms from commercial system:利用商业系统做基准并比较。 ","date":"2019-09-13","objectID":"/posts/30_lads/:1:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#基本介绍"},{"categories":["科研学习"],"content":"系统配置 SNMP training period:k=5 Absolute Volume Threshold:250kbps Event score threshold：$\\alpha_{trigger}$=5 Temporal Clustering Parameter:$\\alpha_{add=2.5},keepalive=15 min$ bandwidth attack threshold:26Mbps SYN/RST/ICMP Threshold:2.6bps ","date":"2019-09-13","objectID":"/posts/30_lads/:2:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#系统配置"},{"categories":["科研学习"],"content":"实验结果 这部分简单看了下，因为这篇确实有点老了。 图10 FN率与阈值以及异常包数的关系 图11：sensitivity与scalability的关系： sensitivity:触发event的可能性。scalability:event触发后的需要收集数据的大小； 图12:在使用过滤器前后SNMP异常事件触发数的对比。 图13：在测试的11天中异常报告占比情况（每小时约有15个event生成） 与商业检测系统对比如图14,图15 success:我们的和商业的几乎结果一致 Found early incidents:我们发现地更早 Found late incidents:我们发现地更晚 Anomaly detection misses:商业有警告，但我们的没有 Potential commercial-alarm false positive:商业有警告，我们有event,但进一步检测我们没有警告。 Threshold misses:对某IP有大量的flow，但是我没有警告。 F15：我们的和商业的都失败的事件占比情况 ","date":"2019-09-13","objectID":"/posts/30_lads/:3:0","series":null,"tags":["论文阅读"],"title":"LADS: large-scale automated DDOS detection system","uri":"/posts/30_lads/#实验结果"},{"categories":["科研学习"],"content":" Mirkovic J, Reiher P. A taxonomy of DDoS attack and DDoS defense mechanisms[J]. ACM SIGCOMM Computer Communication Review, 2004, 34(2): 39-53. 本文不错，就是老了点，对DDoS攻击和防御做了总结和分类，而不是提供个具体的方法。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:0:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#"},{"categories":["科研学习"],"content":"DDoS攻击总结 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:0:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ddos攻击总结"},{"categories":["科研学习"],"content":"攻击overview ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:1:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#攻击overview"},{"categories":["科研学习"],"content":"网络架构的缺点： 网络安全性高度独立 网络资源有限 攻击者协调工作 实体与网络带宽不一致，使攻击者有大量的资源可使用。 没有强制审计 网络是分布式 分布式管理，每个网络在本地管理下运行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:1:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#网络架构的缺点"},{"categories":["科研学习"],"content":"攻击策略 找slave,slave再找slave,进行spoof攻击。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:1:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#攻击策略"},{"categories":["科研学习"],"content":"DDoS目的 威望，钱，斗争，仇。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:1:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ddos目的"},{"categories":["科研学习"],"content":"Taxonomy of ddos attack 贴上攻击分类图： ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#taxonomy-of-ddos-attack"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da自动化程度"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-1手动"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2半自动"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2cm交流机制"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2cm-1直接"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2cm-2间接"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-3自动"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss扫描策略"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss-1随机扫描"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss-2命中表检测"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss-3路标检测"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss-4置换扫描"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3ss5本地子网扫描"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3pm传播机制"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3pm-1中心源传播"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3pm-2连式传播"},{"categories":["科研学习"],"content":"DA:自动化程度 分为手动，自动，半自动。 DA-1：手动 攻击手动扫描主机，黑它，插入恶意代码，启动，现在基本没有了。 DA-2：半自动 使用handler控制agent来进行攻击。 DA-2：CM：交流机制 handler与agent交流手段分：直接，间接。 DA-2：CM-1：直接 需要将handler的IP写死在攻击代码中，因此一个agent被发现可能导致整个攻击的失败 DA-2：CM-2：间接 间接通信，handler与agent通过IRC[19]进行交流，DDoS更稳定，攻击代码可更新，还可以定期更换IRC使其更难被发现。 DA-3：自动 全自动化，handler与agent之间不需要通信，攻击属性写死在攻击代码里。handler要做的就是启动攻击脚本。缺点：攻击系统不够灵活。 DA-2 DA-3：SS：扫描策略 一般使用worm自动感染主机，扫描方式分很多种，下面介绍 DA-2 DA-3：SS-1：随机扫描 被感染的主机使用种子随机扫描IP。这会导致大量流量，触发攻击检测系统。 DA-2 DA-3：SS-2：命中表检测 每感染一个就给被感染者发送一部分感染列表。优：快速，无碰撞；劣：列表可能太长，传输流量大；列表需要事先收集。 DA-2 DA-3：SS-3：路标检测 使用被感染的主机信息对新的主机进行扫描；优：流量小；缺：慢。 DA-2 DA-3：SS-4：置换扫描 所有被感染者有共同的IP表，IP对应下标。agent从随机下标开始，遇到被感染的再从随机下标开始。速度一般，有可能导致攻击检测。 DA-2 DA-3：SS5：本地子网扫描 该方法可附加到前面各扫描方法中，可以防炎墙内找弱机。 DA-2 DA-3：PM：传播机制 基于感染阶段的传播机制可分为：central source propagation,back-chaining propagation,autonomous propogation. DA-2 DA-3：PM-1：中心源传播 感染机器从中心服务器下载代码。缺：会有单点失败问题。 DA-2 DA-3：PM-2：连式传播 当前感染的机器将代码传给下一个。优：稳定。 DA-2 DA-3：PM-3：自治传播 在探索阶段注入攻击指令。优：流量小。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#da-2-da-3pm-3自治传播"},{"categories":["科研学习"],"content":"EV：探索可攻击的弱点 EV-1：语义法 利用弱机已安装的协议或应用的缺点，如：TCP SYN，CGI请求攻击，NAPTHA 攻击。 EV-2：Brute-Force 发送超过弱机处理能力的大量流量。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ev探索可攻击的弱点"},{"categories":["科研学习"],"content":"EV：探索可攻击的弱点 EV-1：语义法 利用弱机已安装的协议或应用的缺点，如：TCP SYN，CGI请求攻击，NAPTHA 攻击。 EV-2：Brute-Force 发送超过弱机处理能力的大量流量。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ev-1语义法"},{"categories":["科研学习"],"content":"EV：探索可攻击的弱点 EV-1：语义法 利用弱机已安装的协议或应用的缺点，如：TCP SYN，CGI请求攻击，NAPTHA 攻击。 EV-2：Brute-Force 发送超过弱机处理能力的大量流量。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ev-2brute-force"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav源地址验证"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1源地址欺骗"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1ar地址是否可路由"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1ar-1可路由"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1ar-2不可路由"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1st欺骗策略"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1st-1随机源地址"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1st-2子网欺骗地址"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-1st-3使用agent出口路由地址"},{"categories":["科研学习"],"content":"SAV：源地址验证 安源地址验证类型的攻击可分：spoofed source address,valid source address SAV-1:源地址欺骗 这个方法很流行 SAV-1：AR：地址是否可路由 这个可以再分：routable source sdress,non-routable source address SAV-1：AR-1：可路由 反射攻击，如：Smurf attack SAV-1:AR-2:不可路由 一般使用网络空间中被分配却未被使用的地址 SAV-1：ST：欺骗策略 按选欺骗地址的技术可分：random,subnet,enroute SAV-1:ST-1:随机源地址 使用随机生成的地址。缺：容易被入口过滤器丢弃。 SAV-1：ST-2：子网欺骗地址 使用agent的子网地址 SAV-1：ST-3：使用agent出口路由地址 SAV-2：验证源地址 有的攻击需要请求/响应，所以需要用真实的地址。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#sav-2验证源地址"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard攻击频率"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard-1持续攻击"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard-2变频攻击"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard-2rcm变频机制"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard-2rcm-1逐增"},{"categories":["科研学习"],"content":"ARD：攻击频率 可以分为：constant rate,variable rate ARD-1：持续攻击 agent以固定频率发包，通常是最大。缺：触发攻击检测 ARD-2：变频攻击 通过改变攻击频率的方式避免触发攻击检测 ARD-2：RCM：变频机制 可分为：increasing rate,fluctuating rate ARD-2:RCM-1：逐增 慢慢提高，逐渐增加耗victim的资源。可以延迟被检测 ARD-2：RCM-2：跳频 跳动攻击，可多组协作，保持有一组活跃攻击。优：难以被发现。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:4","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ard-2rcm-2跳频"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc是否定制"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc-1characterizable"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc-1ravs基于attack和victim服务的关系"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc-1ravs-1可过滤"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc-2ravs-2non-filterable"},{"categories":["科研学习"],"content":"PC：是否定制 根据是否定制包头包内容可分：characterizable and non-characterizable attacks. PC-1：Characterizable 定制攻击一般用于特定主机或协议 PC-1：RAVS：基于attack和victim服务的关系 可分：filterable and non-filterable PC-1：RAVS-1：可过滤 发畸形包给victim的非标准服务，如UDP flood,ICMP ECHO flood。缺：可由防火墙拦截。 PC-2：RAVS-2：Non-Filterable 向victim请求合法服务的攻击，如：HTTP request flood,DNS request flood。优：难解决。 PC-2：Non-characterizable 使用随机生成的包。缺：攻击效果不行。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:5","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pc-2non-characterizable"},{"categories":["科研学习"],"content":"PAS：Agent的持续性 一直活跃会被检测，按Agent的持续性分：constant agent set,attack with variable agent set. PAS-1：Constant Agent Set 所有Agent收到的指令一致，一起开一起关。 PAS-2：Variable Agent Set Agent分组，组内同步，如ARD-2 RCM-2 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:6","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pasagent的持续性"},{"categories":["科研学习"],"content":"PAS：Agent的持续性 一直活跃会被检测，按Agent的持续性分：constant agent set,attack with variable agent set. PAS-1：Constant Agent Set 所有Agent收到的指令一致，一起开一起关。 PAS-2：Variable Agent Set Agent分组，组内同步，如ARD-2 RCM-2 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:6","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pas-1constant-agent-set"},{"categories":["科研学习"],"content":"PAS：Agent的持续性 一直活跃会被检测，按Agent的持续性分：constant agent set,attack with variable agent set. PAS-1：Constant Agent Set 所有Agent收到的指令一致，一起开一起关。 PAS-2：Variable Agent Set Agent分组，组内同步，如ARD-2 RCM-2 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:6","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#pas-2variable-agent-set"},{"categories":["科研学习"],"content":"VT:victim类别 可分为：application,host,network,infrastructure VT-1:应用 攻击机器上的某个应用，耗尽其资源使合法用户无法使用。优：难检测 VT-2：主机 针对主机，耗尽资源使其不可用。如：TCP SYN。一般通过防火墙防御。 VT-3 网络 耗网络带宽。用防火墙容易防御。 VT-4 基础设施 攻击一些服务，如：DNS，ROUTER等。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:7","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#vtvictim类别"},{"categories":["科研学习"],"content":"VT:victim类别 可分为：application,host,network,infrastructure VT-1:应用 攻击机器上的某个应用，耗尽其资源使合法用户无法使用。优：难检测 VT-2：主机 针对主机，耗尽资源使其不可用。如：TCP SYN。一般通过防火墙防御。 VT-3 网络 耗网络带宽。用防火墙容易防御。 VT-4 基础设施 攻击一些服务，如：DNS，ROUTER等。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:7","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#vt-1应用"},{"categories":["科研学习"],"content":"VT:victim类别 可分为：application,host,network,infrastructure VT-1:应用 攻击机器上的某个应用，耗尽其资源使合法用户无法使用。优：难检测 VT-2：主机 针对主机，耗尽资源使其不可用。如：TCP SYN。一般通过防火墙防御。 VT-3 网络 耗网络带宽。用防火墙容易防御。 VT-4 基础设施 攻击一些服务，如：DNS，ROUTER等。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:7","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#vt-2主机"},{"categories":["科研学习"],"content":"VT:victim类别 可分为：application,host,network,infrastructure VT-1:应用 攻击机器上的某个应用，耗尽其资源使合法用户无法使用。优：难检测 VT-2：主机 针对主机，耗尽资源使其不可用。如：TCP SYN。一般通过防火墙防御。 VT-3 网络 耗网络带宽。用防火墙容易防御。 VT-4 基础设施 攻击一些服务，如：DNS，ROUTER等。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:7","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#vt-3-网络"},{"categories":["科研学习"],"content":"VT:victim类别 可分为：application,host,network,infrastructure VT-1:应用 攻击机器上的某个应用，耗尽其资源使合法用户无法使用。优：难检测 VT-2：主机 针对主机，耗尽资源使其不可用。如：TCP SYN。一般通过防火墙防御。 VT-3 网络 耗网络带宽。用防火墙容易防御。 VT-4 基础设施 攻击一些服务，如：DNS，ROUTER等。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:7","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#vt-4-基础设施"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv对victim的影响"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv-1disruptive"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv-1pdr被攻击后是否可恢复"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv-1pdr-1可恢复"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv-1pdr-2不可恢复"},{"categories":["科研学习"],"content":"IV：对victim的影响 可分为：disruptive,degrading IV-1:Disruptive 使服务不可用 IV-1：PDR:被攻击后是否可恢复 可分为：revoverable,non-recoverable IV-1:PDR-1:可恢复 当攻击停止，victim就恢复，如UDP flooding IV-1:PDR-2:不可恢复 攻击停止victim无法恢复如使其死机等 IV-2：degrading 攻击只降低服务质量。这种攻击难以检测，威害巨大。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:8","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#iv-2degrading"},{"categories":["科研学习"],"content":"DDoS防御总结 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:0:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#ddos防御总结"},{"categories":["科研学习"],"content":"防御challenge 布署 成效不好 攻击意图了解少 没有防御标准 无法进行大范围测试 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:1:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#防御challenge"},{"categories":["科研学习"],"content":"Taxonomy of DDoS Defenses 贴上防御分类图 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#taxonomy-of-ddos-defenses"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al防御机制活跃等级"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1阻止"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg阻止目标"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-1attack-prevention"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-1st保护目标"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-1st-1系统安全"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-1st-2协议安全"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-2dos-prevertion"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-2pm防御手段"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-2pm-1资源审计"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-1pg-2pm-1资源增加"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2被动响应"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads攻击检测策略"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-1模式匹配"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-2异常检测"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-2nbsnormal-behavior-specification"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-2nbs-1standard"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-2nbs-1trained"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ads-3第三方检测"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ars攻击响应策略"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ars-1agent识别"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ars-2rate限制"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ars-3过滤"},{"categories":["科研学习"],"content":"AL：防御机制活跃等级 可分为：preventive,reactive AL-1：阻止 通过避免攻击发生，保护主机不受攻击 AL-1:PG：阻止目标 可分为：attack prevention,denial of service prevention AL-1:PG-1:attack prevention 修改系统和协议以避免攻击发生。 AL-1：PG-1：ST：保护目标 根据保护目标可再分为：system security,protocol security AL-1：PG-1：ST-1：系统安全 保护主机和router使他们成为强机。 AL-1：PG-1：ST-2：协议安全 完善协议，不好的协议使Server易受攻击，如TCP-SYN AL-1：PG-2：Dos Prevertion AL-1:PG-2:PM:防御手段 可分为：resource accounting,resource multiplication AL-1:PG-2:PM-1:资源审计 user需要验证才会被分配资源。 AL-1：PG-2：PM-1：资源增加 用大量资源进行负载均衡，让attack耗不完。 AL-2：被动响应 致力于攻击发生时减小攻击的影响 AL-2：ADS：攻击检测策略 可分为：pattern detection,anomaly dettection,third-party detection AL-2:ADS-1:模式匹配 将模式存于数据库，对新包匹配。缺：新的攻击不会检测到。优：FP低。 AL-2：ADS-2：异常检测 定期与正常系统行为模型比较来发现异常。 AL-2：ADS-2:NBS：normal behavior specification 可分为：standard,trained AL-2:ADS-2:NBS-1:standard 依靠协议标准特征进行检测，没有FP，但复杂攻击可以伪装成标准特征。 AL-2：ADS-2：NBS-1：trained 训练正常特征生成阈值来区分。缺：阈值不好定；模型更新可能会误训练。 AL-2：ADS-3：第三方检测 不自已检测。 AL-2：ARS：攻击响应策略 可分为：agent identification,rate-limiting,filtering,reconfiguration AL-2:ARS-1:Agent识别 使victim可以识别出Agent，结合其他策略降低攻击影响。 AL-2：ARS-2：rate限制 给恶意流限速，通常用于FP高的情况 AL-2：ARS-3：过滤 将恶意流完全过滤。缺：攻击者可以利用它误判性来达到dos目的。 AL-2：ARS-4:重配置 重配置TOPO，境加资源或隔离attacker. ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:1","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#al-2ars-4重配置"},{"categories":["科研学习"],"content":"CD：协作程度 可分为：autonomous,cooperative,interdependent CD-1:Autonomous 防御机制与其他实体不合作。 CD-2：Cooperative 防御机制与其他实体协作，如：将防御决策发给router CD-3:Interdependent 防御机制需要依靠其他实体进行攻击阻止，攻击检测，高效响应。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#cd协作程度"},{"categories":["科研学习"],"content":"CD：协作程度 可分为：autonomous,cooperative,interdependent CD-1:Autonomous 防御机制与其他实体不合作。 CD-2：Cooperative 防御机制与其他实体协作，如：将防御决策发给router CD-3:Interdependent 防御机制需要依靠其他实体进行攻击阻止，攻击检测，高效响应。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#cd-1autonomous"},{"categories":["科研学习"],"content":"CD：协作程度 可分为：autonomous,cooperative,interdependent CD-1:Autonomous 防御机制与其他实体不合作。 CD-2：Cooperative 防御机制与其他实体协作，如：将防御决策发给router CD-3:Interdependent 防御机制需要依靠其他实体进行攻击阻止，攻击检测，高效响应。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#cd-2cooperative"},{"categories":["科研学习"],"content":"CD：协作程度 可分为：autonomous,cooperative,interdependent CD-1:Autonomous 防御机制与其他实体不合作。 CD-2：Cooperative 防御机制与其他实体协作，如：将防御决策发给router CD-3:Interdependent 防御机制需要依靠其他实体进行攻击阻止，攻击检测，高效响应。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:2","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#cd-3interdependent"},{"categories":["科研学习"],"content":"DL：布署位置 可分为：victim,intermediate,source network DL-1:Victim Network 在victim网络布署来保护这个网络 DL-2：Intermediate network 以中件设备形式存在，保护大量主机，victim可以向其请求保护服务。 ####DL-3：Source network 在源头阻止攻击的产生。缺：谁来付错布署这个？ ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#dl布署位置"},{"categories":["科研学习"],"content":"DL：布署位置 可分为：victim,intermediate,source network DL-1:Victim Network 在victim网络布署来保护这个网络 DL-2：Intermediate network 以中件设备形式存在，保护大量主机，victim可以向其请求保护服务。 ####DL-3：Source network 在源头阻止攻击的产生。缺：谁来付错布署这个？ ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#dl-1victim-network"},{"categories":["科研学习"],"content":"DL：布署位置 可分为：victim,intermediate,source network DL-1:Victim Network 在victim网络布署来保护这个网络 DL-2：Intermediate network 以中件设备形式存在，保护大量主机，victim可以向其请求保护服务。 ####DL-3：Source network 在源头阻止攻击的产生。缺：谁来付错布署这个？ ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:2:3","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#dl-2intermediate-network"},{"categories":["科研学习"],"content":"总结 本文是一篇不错的总结，被引用了1943次，许多参文献中都出更本文，有的文章里推荐阅读本文。本文的参考文献中有很多关于攻击的网站和资料。 ","date":"2019-09-12","objectID":"/posts/29_taxonomy/:0:0","series":null,"tags":["论文阅读"],"title":"A taxonomy of DDoS attack and DDoS defense mechanisms","uri":"/posts/29_taxonomy/#总结"},{"categories":["科研学习"],"content":" B. Wang, Y. Zheng, W. Lou and Y. T. Hou, “DDoS Attack Protection in the Era of Cloud Computing and Software-Defined Networking,” 2014 IEEE 22nd International Conference on Network Protocols, Raleigh, NC, 2014, pp. 624-629. 这篇不怎么样，CCF B类计算机网络会议。本文提出一个用于云防御DDoS攻击的框架。 ","date":"2019-09-11","objectID":"/posts/28_ddos_cloud_computing/:0:0","series":null,"tags":["论文阅读"],"title":"DDoS Attack Protection in the Era of Cloud Computing and Software-Defined Networking","uri":"/posts/28_ddos_cloud_computing/#"},{"categories":["科研学习"],"content":"介绍： 混合云架构图如图1。 如图如示：攻击者会攻击1.local Server;2.cloud sever； 1.中的攻击方式有(1)和(2)两种防火墙防（2），对于（1）则取决于攻击者的流量是否重定向到防御系统。2.中攻击方式有（3）（4）（5）。由于云服务中快速的资源得分配使（4）（5）更难被防御。 ","date":"2019-09-11","objectID":"/posts/28_ddos_cloud_computing/:0:0","series":null,"tags":["论文阅读"],"title":"DDoS Attack Protection in the Era of Cloud Computing and Software-Defined Networking","uri":"/posts/28_ddos_cloud_computing/#介绍"},{"categories":["科研学习"],"content":"本文的方法：DaMask 设计目标：effective,small overhead,inexpensive. effective:将企业流量切片处理 overhead:通过高效的检测算法达到目的 inexpensive:当虚拟机迁移时快速地配置参数文件 DaMask的工作流如图2所示： 由图可见DaMask分为两部分：DaMask-D和DaMask-M。检测算法是在Da-D中运行。 Da-D当收到包时交付给相应的NOS进行检测，如果是attack,发alert交给Da-M处理，如果是nomal交付，如果是unknow就进一步检测。 Da-M：有两个功能：countermeasure selection and log generation.当收到alert后匹配相应的countermeasure，并提供API制定对策。缺省对策为drop。countermeasure会通过controller对switch下发流表。 ","date":"2019-09-11","objectID":"/posts/28_ddos_cloud_computing/:0:0","series":null,"tags":["论文阅读"],"title":"DDoS Attack Protection in the Era of Cloud Computing and Software-Defined Networking","uri":"/posts/28_ddos_cloud_computing/#本文的方法damask"},{"categories":["科研学习"],"content":"评估 实验配置基本信息： 私有云LinxuA：AMD E1-1200*2 1.4GHz CPU,4 G memoriy； 控制器LinuxB：Inter i7-2600 CPU 3.4GHz,12G memory,并运行MaMask。 公有云：AWS的EC2.拓扑图见图3. 通信代价测试：结果见表1；本模块几乎不影响通信时延。 对拓扑改变的适用性 当网络拓扑改变时（如图3中增加了switchB），在FlowVisor里改相应公司的流头。经发ICMP包测试有效且不影响其他服务。 ","date":"2019-09-11","objectID":"/posts/28_ddos_cloud_computing/:0:0","series":null,"tags":["论文阅读"],"title":"DDoS Attack Protection in the Era of Cloud Computing and Software-Defined Networking","uri":"/posts/28_ddos_cloud_computing/#评估"},{"categories":["科研学习"],"content":" Fayaz S K, Tobioka Y, Sekar V, et al. Bohatei: Flexible and elastic ddos defense[C]//24th {USENIX} Security Symposium ({USENIX} Security 15). 2015: 817-832. 本文提出一种针对新型网络的DDoS的防御系统，通过SDN，将可疑流量通过VM以达到保护主机的目的。（本文目的是为特定主机提供保护服务，收费服务那种。）本篇的introduction和background都比别人难懂。。。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:0:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#"},{"categories":["科研学习"],"content":"Bohatei的基本概念 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:0:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#bohatei的基本概念"},{"categories":["科研学习"],"content":"problem scope Deployment scenario:布署在ISP上，并以可选服务的形式提供，图2为布署B的图。 Threat model:攻击类型：普通的DDoS如TCP SYN flood,UDP flood,DNS amplification,elephant flow。攻击可以是否（单类+单入口）$\\rightarrow$(多类+多入口) Defenses:使用有向无环图（DAG）表示攻击和缓解过程，边为前一个节点的处理结果，每个节点都是一个类似多个虚拟VM的实现，图3为一个例子。 本文重点是实现弹性防御，所以假设DDoS防御和DAG都是完成的。 本文不提供检测和防御算法，只作资源分配与管理。当检测到攻击类型与攻击强度后，本文根据攻击类型与攻击强度分配处理的Strategy Graph与VM资源并进行缓解。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#problem-scope"},{"categories":["科研学习"],"content":"Bohatei workflow and challenges Bo的工作流可见图2 attack detection:检测攻击并声明具体攻击信息。如：“srcprefix=*,dstprefix=cust,type=SYN” attack estimation:估计攻击流量的强度 Resource management:分配适当的网络资源（VM）来防御。 将可疑流量导入已分配的VM 当前需要解决的困难： 1.ISP 分多大的VM，几个VM来处理，这是一个NP hard 问题 2.如何丢弃恶意流？一发流表会使流表被饱和。 3.攻击者会改变攻击特性：类型，容量，入口点，这个能会导致：防御没有被使用或防御不足。 一下章讲如何解决这三个问题。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#bohatei-workflow-and-challenges"},{"categories":["科研学习"],"content":"本文实现原理 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:0:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#本文实现原理"},{"categories":["科研学习"],"content":"Resource Manager： 本部分讲ISP如何分VM的问题1，该问题最优解ILP是一个NP-hard问题，需要解决的时间很长，但作者将其分解为DSP和SSP，可以很快地解决出近似最优解。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#resource-manager"},{"categories":["科研学习"],"content":"Problem inputs 假设ISP是由边集$PoPs^5E={E_e}_e$和数据中心$D={D_d}_d$组成。PoP表示\"edge pop and ingress\". ISP contrainsts:uplink capacity$C_d^{link}$和数据中心的计算容量$C_d^{compute}$. Process requirements：对每个攻击需要策略图，资源管理器所需要的输入为一个标记图$DAG_a^{annotated}$，如图4。$T_{e,a}$表示由a出到e的流量比例，还有一个参数：$P_{a,i}$，它指的是VM对某个逻辑模型的$v_{a,i}$的处理能力。$v_{a,i}$指$DAG_a^{annotated}$的节点i。 Network footprint:$L_{e,d}$表示入口e到数据中心d的网络层代价，数据中心内有IntraUnitCost和InterUnitCost。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:1","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#problem-inputs"},{"categories":["科研学习"],"content":"Problem statement 将标记图转为物理图时每个$V_{a,i}$由一个或多个VM实现，问题有： fine-grained scaling:标注图高效并可扩展生成物理图，需要以图5c的方式，而不是图5b的方式扩展。 Goals:实例化VM，分布式处理流量使流量延迟最小化。 需要分配置两个参数：1.$T_{e,a}$发给每个数据中心的流量比例；2.在数据中心$V_{a,i}$的VM个数。可将资源管理器问题看作优化问题ILP，解可见图15.但这种解法需要花数个小时运行，因此并不适用于Bohatei. ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:2","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#problem-statement"},{"categories":["科研学习"],"content":"Hierarchical decomposition 问题分解：1.DSP（Datacenter Selection Problem）:选择一个数据中心处理可疑流量；2.SSP（Server Selection Problem）：在选择的数据中心中选择Server运行VM。利用贪心启发算法来求近似最优解。 DSP：将可疑流量$T_{e,a}$降序排序，算法将流量以最小的$L_{e,d}$分给数据中心。输出：1.$f_{e,a,d}$，表示入口可疑流量分配给每个数据中心的比例。2.对应攻击类型数据中心布署的物理图。可见附录B图16. SSP：根据前一个节点选择邻近节点中处理能力最高的Server处理可疑流量，见附录B图17. ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:3","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#hierarchical-decomposition"},{"categories":["科研学习"],"content":"Network Orchestraion 上一节解决了配置数据中心处理进入的可疑流量以及分配服务器运行防御VM，本节需要进行路由表的配置以支持上一节的决策，主要解决的问题是：当攻击流量出现时的可伸缩性。因为当攻击出现时通过下发流表丢弃包的方式会容易出现效率不高和饱和的问题。本节处理的办法为：通过预定义tag提前下发标记的方式避免流表项过多 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#network-orchestraion"},{"categories":["科研学习"],"content":"High-level idea 将问题分解 1.将流量转到数据中心；2.数据中心内将流量转到正确的VM。 使用基于标签逻辑交付规则和VM标签来替代流规则。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:1","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#high-level-idea"},{"categories":["科研学习"],"content":"Wide-area orchestraion 当流量被检测为可疑，就通过预插入规则和$f_{e,a,d}$导入数据中心。预插入规则通过设置表静态隧道的方式进行，当DSP被解出后就在骨干网中根据$f_{e,a,d}$进行分流配置。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:2","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#wide-area-orchestraion"},{"categories":["科研学习"],"content":"Intra-datacenter orchestration 数据中心内部包需要通过一个VM序列 1.本VM对包分析后决定下一个要发送的VM； 2.每个逻辑结点依需要实例化为几个VM，标注图层面需要负载均衡以均衡流量。 当包在物理图中传递时，本地控制器跟踪并根据其处理结果上下文信息选下一个VM。这样做会遇到的问题：满足需求并可伸缩。 Encoding processing context:将处理上下文编码成tag并放入包头，S根据这个信息决定要发的端口。如图6 解决Controller channel瓶颈：预插规则 解决rule爆炸：规则以通配符的方式决定包的交付。 scale-out load balancing:负载均衡器（LB）本身可能成为瓶颈，将每个VM中放一个LB并分布式协作，当处理包时LB根据处理上下文选择tab并进行负载均衡。 other issues:1.tag位的制定对：$k_{\\max } \\times l_{\\max } \\times \\sum | V_{a}^{\\text {annotated}} |$ 取对数。$k_{max}和l_{max}$为一下文可能的最大个数和一个节点实例化最大可能的VM数，$V_a^{}annotated$为对攻击类型a的标注图的顶点数。2.对于DNS amplification需要同一个VM处理请求和响应，而对UDP flood而不需要，处理办法为：边缘S接收入流量时将其发到处理相同tag出流量的数据中心。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:3","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#intra-datacenter-orchestration"},{"categories":["科研学习"],"content":"Strategy Layer interation model:把运行BO的ISP与攻击者之间的交互模型化为：重复的互动（看图原文吧，这个是真翻译不来）（我理解为：针对攻击ISP中BO做的改变） Objective:由于ISP需要事先分配VM和硬件资源，因此攻击者可以： G1.提高ISP的硬件资源消耗； G2.成功交付攻击流量； ISP的目标就是要最小化G1和G2 Threat model:假设攻击者预算流量因定，只是何时何地的分布不知，则可表示为：$\\sum_e\\sum_aT_{e,a}\\le B$,但具体的$T_{e,a}$值没有限制。 Limitations of strawman solutions:当前的不足以单点为例讲解，对PrevEpoch策略，会出现过度拟合问题，对uniform策略，出现过度供给问题。 Online adaption:这是本文使用的方法，若是静态攻击则$T_{e,a}^*=\\frac{\\sum_tT_{e,a,t}}{|t|}$合适，但敌人可能会改变改攻击属性，因此我们使用过去+随机的方式，即$\\widehat{T_{e, a, t+1}}=\\frac{\\sum_{t^{\\prime}=1}^{t} T_{e, a, t^{\\prime}}}{|t|}+randperturb$，而$randperturb$的值为：$\\left[0, \\frac{2 \\times B}{n e x t E p o c h \\times|E| \\times|A|}\\right]$，这里假设防御的全部资源预算为：$2\\times B$ ","date":"2019-09-10","objectID":"/posts/27_bohatei/:3:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#strategy-layer"},{"categories":["科研学习"],"content":"implentation 本文提供源码 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:0:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#implentation"},{"categories":["科研学习"],"content":"DDoS Defense modules 防御库由两个逻辑块组成： Analysis(A):分析可疑流，给流加标签以决定进一步分析或响应。 对从A处得来的流进行交付，log,drop,rate limit. 下面列举每一个攻击的防御办法 SYN flood：监控连接的TCP，如果源IP从来不完成握手，则将未来的包标识成attack,如果有的完成有的未完成，则使用SYN-proxy防御。图8 DNS amplification：图9。检测DNS Server是否对指定IP查询，并进行分析，如果快速分析结果为未知再进行深入慢速分析。 UDP floow：A能过辩别UDP包数据是否异常用地多来检测。 Elempant flow:A检测流是否异常大。 异常检测（本文异常检测方法是别人的，工作重点在怎么以服务的形式提供使用）：使用nfdump检测，将结果以三元组(Type,FlowSpec,Volume)发给Bohatei全局控制器.type为攻击类型，FlowSpec为对流的一种描述，volume为基于流记录的异常流容量。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#ddos-defense-modules"},{"categories":["科研学习"],"content":"SDN/NFV platform Control plane:将Bo实现为ODL的一个插件。 Date Plane: 使用Snort,Bro实现A和R，物理节点使用KVM中的VM进行。具体见表1. 使用GO实现DSP和SSP算法 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#sdnnfv-platform"},{"categories":["科研学习"],"content":"Evaluation SDN Testbed:13个Dell R720（20-core 2.8GHZ Xeon CPUs,128G RAM）每个机器在CentOS6.5(内核 v2.6.32)KVM。每个VM分配置1CPU，512M 内存。 Network Topologies:100G带宽，10ms延迟，数据中心数为骨干网S数的5%，在[22]中选拓扑结构。 Benig tarffic demands:使用iperf和自定义代码生成流量，流量多少与骨干网规模成正比。 Attack traffic:SYN flood手动写，DNS amplification用OpenDNS BIND,大象流和UDP flood使用Iperf。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:0:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#evaluation"},{"categories":["科研学习"],"content":"Bohatei scalability Resource management：见表2,BO与最优解差距不大，但其节省了大量的时间。 Control plane responsivess:见图10：攻击与延时图，由图可见当攻击增加时，本文中的方法使流表插入延发迟并不会劣化。 Number of forwarding rules:图11,有攻击时，BO下发流表要比正常的系统少。 Benefit of scale-out load balance:Bo负载平衡时，当有攻击不需要额外VM。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:1:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#bohatei-scalability"},{"categories":["科研学习"],"content":"Bohatei end-to-end effectiveness：结果见图12 当有攻击发生时，BO可以快速地响应并使吞吐量恢复。 Hardware cost:表3为硬件消耗比较，本文的方法消耗较少。 Routing efficiency:路由效率比较见图13,本文降低了20%-65%。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:2:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#bohatei-end-to-end-effectiveness结果见图12"},{"categories":["科研学习"],"content":"Dynamic DDoS attacks 攻击策略见图（城会玩）： 图14为对各攻击策略的资源与攻击成功率的回归比较，本文的方法可见效果最好。 ","date":"2019-09-10","objectID":"/posts/27_bohatei/:3:0","series":null,"tags":["论文阅读"],"title":"Bohatei: Flexible and elastic ddos defense","uri":"/posts/27_bohatei/#dynamic-ddos-attacks"},{"categories":["科研学习"],"content":" Cui Y, Yan L, Li S, et al. SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks[J]. Journal of Network and Computer Applications, 2016, 68: 65-79. 本文提出一种针对DDoS攻击的检测与缓解机制，由四部份组成：attack detection trigger,attack detection,attack traceback,attack mitigation。本文质量一般，不过packet_in trigger提出觉得有点创新。 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:0:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#"},{"categories":["科研学习"],"content":"introduction 本文通过trigger来触发检测算法进行检测，检测到后再分析switch是否为恶意攻击的路径，再结合全局拓扑和受攻击者IP找到恶意流的源switch，从源进行缓解。 整体架构如图4： init state:检测packet_in是否有异常。 detecxtion state:检测DDoS是否发生。 Traceback State:检测包攻击路径 Mitigation state:根据找到的source switch进行缓解。 1.发生异常 2.没检测到DDoS攻击 3.检测到DDoS攻击 4.没找到攻击包路径 5.path,source switch被找到 6.清理完成。 图5为组件和工作流程图 [] 由图可见本机制的4部分合作关系下面分别介绍这四部份。 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:0:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#introduction"},{"categories":["科研学习"],"content":"Attack detection trigger 本部份主要检测packet_in是否有异常的数据量峰值包括两部份：消息容量计算，消息容量异常检测，使用的是exact-STORM算法，它使用的一种Indexed Trream Buffer(ISB)的数据结构，ISB以节点的形式存储信息，主要结构为： n.obj: packet_in消息的velocity，其实就是时间间隔到达的包数除以时间间隔。 n.id n.count_after: buffer中其他点与当前点的V在一定范围内的个数。 n.nn_before: 最相近的指定个节点id组成的列表。 packet_in消息异常检测流程和算法如图6和A1： 算法和流程图讲的是一个东西。当指定数据的packet_in包到达后计算该时间间隔的包体积V（就是包数除以时间），并使用exact-STORM来检测是否异常。 exact-STORM算法如A2： 本算法中，如果buffer中包与本包的V差值在R之内的个数+与本包V值最近的几个包数(没说几个)\u003c某个值，则本包被视为游离包，返回异常。 使用本触发方法比定期触发更节省资源。 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:1:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#attack-detection-trigger"},{"categories":["科研学习"],"content":"Attack detection 本文使用的检测算法：BPNN（没具体讲算法怎么用。）输入层5,隐藏层10,输出层1.输入特征为：流项的包数，流项的字节数，流项的包率，流项的字节率，流项的生存时间。具体流程见图7： 解释：对每个流抽取特征并检测，如果是恶意流：存dIP，如果恶意流数量超过一定值：找到最可能的dIP，停止分析。 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:2:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#attack-detection"},{"categories":["科研学习"],"content":"attack traceback 利用前一阶段获得的信息进行路径发现和路径源头。具体流程见图8 这里再次使用BPNN算法，计算S中的每个流，如果恶意流数量超过一定值而将该S定为恶意S，再根据dIP，恶意S和全局拓扑找到source。 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:3:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#attack-traceback"},{"categories":["科研学习"],"content":"attack mitigation 目的：阻寒攻击流量。 在source给恶意流量以最高优先级插入丢弃策略，流项见图9 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:4:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#attack-mitigation"},{"categories":["科研学习"],"content":"评价 RYU中，使用25个S，200个host，重要参数设置见表2 ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:0:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#评价"},{"categories":["科研学习"],"content":"整体性能评估 表3各模块启动时间，图10：CPU使用率，图11控制器网络负载 表4为寻找路径结果 找到两条路径：e11-a3-c1-a2-e6和e16-a4-c1-a2-e6 表5为在block前后controller接收率的变化 ##结果性能对比 本文的优点：触发型检测，可删除S中的entries（没有具体的性能对比），对比见表6 比较trigger和periodic的性对，本文只是自己跟自己比，没有跟别人比。 Comput.NetW.这个怎么样？ ","date":"2019-09-09","objectID":"/posts/26_sd-anti-ddos/:1:0","series":null,"tags":["论文阅读"],"title":"SD-Anti-DDoS: Fast and efficient DDoS defense in software-defined networks","uri":"/posts/26_sd-anti-ddos/#整体性能评估"},{"categories":["科研学习"],"content":" Shin S W, Porras P, Yegneswara V, et al. Fresco: Modular composable security services for software-defined networks[C]//20th Annual Network \u0026 Distributed System Security Symposium. NDSS, 2013. 本文提供了一个应用框架FRESCO，可供研究人员和开发代人员更简单地实现各种检测、缓解模块。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:0:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#"},{"categories":["科研学习"],"content":"基本介绍 它提供API，可用来调用Module,Module是各种安全功能，如:firewall,scan detector,attack reflector,IDS detection logic。当前提供16个Module，每个Module有5个接口：input,output,event,parameter,action，M之间可以配合使用以实现更复杂的应用。 由于Controller不存TCP会话信息而分析却需要，FRESCO-DG存储和管理这些并在FRESCO应用之间共享。 FRESCO的功能模块化可通过共享数据和事件调用API来驱动。 FRESCO可将检测结果转为规则（可能很复杂） FRESCO的架构图如图1 由应用层和安全执行内核（SEK）组成，均在NOX控制器上运行。应用层使用NOX的python模块实现，它提供两个开发功能：DE和RC(Resource Controller)。开发者可以利用应用层的脚本进行开发应用（应用是基于模块的），当收到相应触发事件时被实例化的模块就会被激活。模块也可以对相应的事件生成新的流规则，这些规则会在SEK部分被处理。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:0:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#基本介绍"},{"categories":["科研学习"],"content":"FRESCO的详细价绍 ","date":"2019-09-08","objectID":"/posts/25_fresco/:0:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco的详细价绍"},{"categories":["科研学习"],"content":"FRESCO Application Layer 应用层中，模块是其基本组成单元，应用是模块的组装。每个模块有5个接口：input,output,parameter,action,event input:模块的输入 output:模块的输出 parameter:模块的配置参数 action:模块要对网络包或流进行的操作 event:模块的触发事件 举个粟子：一个丢弃所有HTTP包的应用。它由两个模块组成，结构图如图2. 第一个Module: input:包的端口值，parameter:80,event:当有新流到达时触发，output:端口值与80的比较结果 第二个M： input:第一个M的输出，action:drop或forward。 action是从NOX得到且是所有的switch都支持的，它基本有三种：drop,output,group:通过具体的组来处理。还有一种可选的：set action：switch重写匹配包的字段。FRESCO将其分为三种：redirect,mirror：拷贝并交付到某个镜像端口,quarantine：交流从网络隔离，只允许交付给指定主机。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:1:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-application-layer"},{"categories":["科研学习"],"content":"FRESCO Development Enviroment(DE) 提供API给开发者，屏蔽NOX实现和复杂的OF协议；释放安全功能相同的应用。DE提供以下四个功能： script-to-module translation:将脚本转换成相应的Modules并实例化。授权管理员会生成应用ID，相应脚本会嵌入ID并使用私钥加密，实例化的时候会进行解密并通过ID验证权限。 Database management:收集网络或switch状态，并提供接口给实例调用，也可用来暂存实例。 Event management:当指定事件发生时激活实例，也提供API供应用产生事件。事件有：flow arrivals,denied connections,session resets. Instance execution:加载实例到内存并运行。加载时利用公钥解密并验计ID。 ###FRESCO Resource Controller(RC) 监控switches并跟踪状态，当FRESCO要插表但表满，就会删旧表。需要功能：1.定期收集switch状态；2.垃圾处理，当表快满了（超过指定thresh）删除最长时间未用的表。 ###FRESCO Script Language 脚本语言需要定义六个变量：type：需要实例化模型的类型,input,output,parameter,action,event。每个变量可定义多值，用逗号分割。变量总结在表1中。图3是对图2中的例子用脚本语言描述。 图4是对应的脚本执行：1.生成脚本；2.加载到FRESCO；3.switch收到符合条件的包；4.报告事件；5，6创建实例并加载；7.发action到FRESCO；8.将action转成rule并插入switch。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:1:1","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-development-enviromentde"},{"categories":["科研学习"],"content":"FRESCO Security Enforcement Kernel(SEK) SEK解决：1.流表冲突，保证安全流表优先级；2.解决set action会绕过规则的问题：如set action可能过虚拟隧道绕过禁止两主机建立连接的问题，这个在[31]中更详细说明。 解决问题1需要的特征： 规则源识别，FRESCO对规则进行数据签名，以便SEK识别。 Rule conflict detection:SEK中的检测算法检测规则冲突；详见附录A1 Conflict resolution:优先级高的覆盖低的。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:2:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-security-enforcement-kernelsek"},{"categories":["科研学习"],"content":"实现 ","date":"2019-09-08","objectID":"/posts/25_fresco/:0:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#实现"},{"categories":["科研学习"],"content":"其本实现环境 FRESCO 应用是用python编写，在NOX上运行。 FRESCO SEK是NOX源码的一个扩展，C++代码，修改send_openflow_command用来接收应用rule并将其发到switch,修改的目的是解决冲突问题，保证安全规则被插入到switch中。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:1:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#其本实现环境"},{"categories":["科研学习"],"content":"工作实例： ","date":"2019-09-08","objectID":"/posts/25_fresco/:2:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#工作实例"},{"categories":["科研学习"],"content":"Implementing Reflector Net 实现一个反射网，将布置该服务的OF网转接到远程蜜罐。 检测实例：检测网络扫描，当TCP_Connection：Fail值数到达一个阈值时触发实例，如图5左.其输出作为第二个实例的输入。参数有：input,output：两个，sIP和检测结果,parameter:扫描算法的参数，设为5.,action：无 重定向实例：将恶意扫描转到蜜罐，图5右。当scan_result=1时将重定向所有的源IP。 图6为测试，主机2扫描4,包被交付到S时S将统计发送给FRESCO，检测到扫描将包重定向到3,3将结果返回给扫描者2,完成防御。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:2:1","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#implementing-reflector-net"},{"categories":["科研学习"],"content":"Cooperating with a Legacy Security Application 与其他应用协作可将其他应用的alert信息利用action转成流规则。传递的消息格式有两种：FRESCO类型：MESSAGE_LEGACY:FRESCO;标准格式类型：MESSAGE_LEGACY:IDMEF。 例：见图7,1.攻击者咸染C；2.BotHunter检测到；3.BotHunter发message给FRESCO；4.5.FRESCO根据结果实现检疫action;6.c被隔离。 botHunter使用FRESCO API传递感染信息包括：victim_ip,confidence_score，当score大于thresh时执行隔离，实现脚本见图8 ","date":"2019-09-08","objectID":"/posts/25_fresco/:2:2","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#cooperating-with-a-legacy-security-application"},{"categories":["科研学习"],"content":"评估实例： 评价环境：mininet:i3CPU,4G RAM;SEK:HP ProCurve 6600 OF-enable switch 。本部分有三个应用： ","date":"2019-09-08","objectID":"/posts/25_fresco/:3:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#评估实例"},{"categories":["科研学习"],"content":"FRESCO Scan Service 扫描检测，见图10 三个模块代码量为：205pythonk,24 script。 三个模块内容为：检测是否在表中；在：交付，不在：检测；是否扫描：是重定向，否：交付。 图11为相应的脚本。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:3:1","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-scan-service"},{"categories":["科研学习"],"content":"FRESCO BotMiner Service 图12为BotMiner实现；图13为相应脚本；321行python,40行script. ","date":"2019-09-08","objectID":"/posts/25_fresco/:3:2","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-botminer-service"},{"categories":["科研学习"],"content":"FRESCO P2P Plotter Service P2P恶意软件发现。恶意软件特征：低volume,低churn。 图14,15为说明图和脚本 ","date":"2019-09-08","objectID":"/posts/25_fresco/:3:3","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#fresco-p2p-plotter-service"},{"categories":["科研学习"],"content":"评估 1.代码量 比较FRESCO和非FRESCO实现的应用。 用FRESCO实现[24]中的算法并与其比较，表2为比较结果，其中FRESCO的代码量大大减少。 2.资源消耗 下发流表耗时比较 5个FRESCO应用与NOX的比较，结果见表3 FRESCO更 耗时一些，但这是运行在mininet中，如果在物理机上会减少很多耗时。 垃圾收集 FRESCO垃圾收集器阈值设为0.75,比较流表中项的个数见图16,使用FRESCO时维持在一个数，而不使用则一直涨。 ","date":"2019-09-08","objectID":"/posts/25_fresco/:4:0","series":null,"tags":["论文阅读"],"title":"FRESCO:Modular Composable Security Services for Software-Defined Networks","uri":"/posts/25_fresco/#评估"},{"categories":["科研学习"],"content":" Mahimkar A , Dange J , Shmatikov V , et al. dFence: Transparent Network-based Denial of Service Mitigation[J]. Nsdi ’, 2007:24-24.， 本文通过添加dFence中间设备，实现透明的DoS防御。图1架构图，将中间设备透明插入可能受攻击的主机前并拦截所有流量。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:0:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#"},{"categories":["科研学习"],"content":"Transparent Middlebox Invocation 本部分讲如何透明调用中间设备，网络不用了解中间设备存在于否。要解决的问题有：1.双向流拦截，指定流固定到中间设备；2.动态状态管理；3.中间设务错误恢复。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:0:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#transparent-middlebox-invocation"},{"categories":["科研学习"],"content":"Dynamic Traffic Interception 当前存在的方法无法满足我们的需要。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#dynamic-traffic-interception"},{"categories":["科研学习"],"content":"Inbound traffic interception 通过使用iBGP和隧道技术来拦截inbound流量，iBGP在本在AS发路由表到所有的S，这样所有的目标主机的流量都被定位到一个固定的（dFence Middle box）M上。具体步骤: 见图2a 找M。在a中，IGP找的M是M1,但它不是HM。（home middle box,即该M是否是处理某流的M） 不是HM，而由M找HM，图a中由M1找M3,M3为HM。（某个特定的目标主机需要由一个M处理。）用流的hash来确认是不是HM。 3.HM通过隧道技术将包发给出口路由Rn，这里这们做是避免环。隧道技术声明：（ACLs-to-S和ACLs-from-S） ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:1","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#inbound-traffic-interception"},{"categories":["科研学习"],"content":"Outbound traffic interception 为达到这样的目的，hash函灵敏定义为：更换sIP和dIP计算得到的Hash值不变。 $h_{1}\\left(\\operatorname{src} a d d r, \\operatorname{src}{-} p o r t\\right) \\oplus h{2}\\left(d s t_{-} a d d r, d s t_{-} p o r t\\right)$ 使用PBR交付所有目的主机流量到M。如图2b 若满足ACL-from-S而交付到一个M上，这里是M4 M找HM，这里是M3 处理后正常交付即可。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:2","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#outbound-traffic-interception"},{"categories":["科研学习"],"content":"Dynamic State Management 当M介入或移除时，分别引入启动时间$T_b$和移除时间$T_r$。 state bootstrapping:在$T_b$内，所有已有的双向连接都视为合理。 state removal:在$T_r$内，对新来的连接不应用策略。 经过分析，启动时间设为5或10秒较合理，移除时间稍长以处理完连接。移除决策只能由M自己作出。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:2:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#dynamic-state-management"},{"categories":["科研学习"],"content":"Falure Recovery and load balancing 可能的出错原因有：power outage,hardware malfunciton,software errors,network outages,..。 解决办法：优雅地流转移。即通过转移处理流的HM来解决出错和负载平衡。 所有的M都维护一个全局home Hash表，对于某个流识别f，计算hash:h(f)，再通过HM（h(f)）找到它的HM。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:3:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#falure-recovery-and-load-balancing"},{"categories":["科研学习"],"content":"Failure rcovery 所有的dF设备连成一个逻辑环，可通过R.next(Mi)递归找到每一个设备。当Mi失效时，则R.next(Mi)接替Mi的工作。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:3:1","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#failure-rcovery"},{"categories":["科研学习"],"content":"Load balancing 与上面相似，假如M1过载，而通过 HM（e）=M2将e从M1转到M2. ","date":"2019-09-07","objectID":"/posts/24_dfence/:3:2","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#load-balancing"},{"categories":["科研学习"],"content":"Middlebox Disign. M维护的TCP连接主要分两类：M引进前和M引进后。 M主要维护连接的一个Connection Hash表，表项由FlowID(sIP,dIP,sP,dP)作键，表项组成： flow definition offset:C和S的序列号差值，后面会讲到。 Timestamp:连接最近一次的包到达时间 service bits： inboundPacketRate:每个时间间隔到达的包数。 另个还有个Src-Dest表，记录同样sIP-dIP的连接数，超过阈值就禁止建立新的连接。 再另外，对于目的主机S主动发送的连接使用Bloom filter来维护。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:0:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#middlebox-disign"},{"categories":["科研学习"],"content":"Mitigation Policies 本文要实现的目标是透明实现DoS防御，攻击形式：SYN flood,Smurf-type,reflection attacks。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#mitigation-policies"},{"categories":["科研学习"],"content":"Mitigation spoofed attacks network-based SYN cookie generation 过程图见图4 当C发送SYN，M通过计算SYN cookies，并以此作为SYN-ACK序列号。此时为无状态。M与C连接阶段通过设置window=0来chock防止C发数据，这很重要，若C未完成连接即可丢弃。 M与C握后完成，创建Connection和Src-Dest表项，此时，M与S握手，序列号为C的SYN序列号。 当M与S完成shake，就不再chock，此时要维扩展护一个序列号偏移offset。 当要中继时，可通过offset来进行序列号转换，该如何处理可以通过service bit来决定。 Spoofed data floods and reflector attacks 也可用上面的机制解决。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:1","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#mitigation-spoofed-attacks"},{"categories":["科研学习"],"content":"Mitigation unspoofed attacks Unspoofed data floods:过于占用带宽，M拦截S的ACK，使C减速，项不减速则弃包。 Too many unspoofed connection:控制Zombie完成握手，控制src-dst连接数在一个合理的范围。 NAPTHA attacks:攻击都关闭TCP并不发送FIN，M通过时间，是就RST Botnet attack:黑客控制上些机器对victim进行HTTP或其他请求轰炸，通过流量统计或ISP的/24前缀白名单优化。因为zombie 机器通常sparsely distributed，因此有效。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:2","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#mitigation-unspoofed-attacks"},{"categories":["科研学习"],"content":"Evasions and Attacks on Middlebos exhausting the connection state。即填满Connection表。限制单主机连接数量，只保留未欺骗源的状态。 Adaptive traffic variation:你on 我off,你off 我on。避免快速加入或退出M。 werewolf attack:先正常连接，连上后再攻击你。定期检查流发送率和白名单。 Multiple attacks：增加MiddleBox数据 policy desion tree见图5,这个和Avant-guard有点像。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:2:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#evasions-and-attacks-on-middlebos"},{"categories":["科研学习"],"content":"implementation 控制平面流量截取XOPR，数据平面攻击缓解IXP（这个并不是SDN里的那个。）完整设计可见图6a，控制平面利用BGP和IGP来进行路由决策并更新交付表。 Control plane interception: 当有攻击时，M拦截，利用iBGP使所有的victim的流量通向M，并设定隧道和ACL规则来配置egress以防止环路。 Data plane mitigation:使用Shangri-La framework 实现IXP,将攻击缓解实现成一个包处理函数映射。如图6b。 Control-data planes interaction: XORP和IXP之间使用ioctl()和系统调用来交流。XORP运行BGP/IGP并在数据平面上映射MAC/IP下一跳IP，PORT等信息。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:0:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#implementation"},{"categories":["科研学习"],"content":"评估 ","date":"2019-09-07","objectID":"/posts/24_dfence/:0:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#评估"},{"categories":["科研学习"],"content":"Micro benchmarks lantency：各个功能的处理时间见到表1. 吞吐量：见表2,单位为：Kpps （kilo packets per second）。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:1:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#micro-benchmarks"},{"categories":["科研学习"],"content":"end-to-end benchmarks 服务器：1GHz Intel P-3 processor 256MB RAM,256KB cache,Apache Web Server Linux 2.4.20 kernel。评估：连接时间和最大TCP吞吐量。结果见图7 Lantency:7a，x轴为攻击率，y轴为连接时间。 吞吐量：10s时加入M，可见加入M后吞吐量随之恢复正常。 ","date":"2019-09-07","objectID":"/posts/24_dfence/:2:0","series":null,"tags":["论文阅读"],"title":"dFence: Transparent Network-based Denial of Service Mitigation","uri":"/posts/24_dfence/#end-to-end-benchmarks"},{"categories":["科研学习"],"content":" Kazemian P, Varghese G, McKeown N. Header space analysis: Static checking for networks[C]//Presented as part of the 9th {USENIX} Symposium on Networked Systems Design and Implementation ({NSDI} 12). 2012: 113-126. 看本文原因：好多文章中的参考文献，且作者Nick是OF提出者。本文提出Header Space Analysis来分析错误类别如：Reachability Failure,Forwarding Loops,Traffic Isolation,Leakage problems。我们装将包头视作一系列位的连接,每个都是一个${0,1}^L$点，L是包头最大长度，而网络box的转换视作将点空间中的一个点转换为另一个（或一些）。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#"},{"categories":["科研学习"],"content":"Introduction 我们的目标是：1.帮助风络管理员静态分析网络；2.保证不同集的主机，用户，流量的隔离；3.使用更通用的方式对网络切片进行静态分析。我们的关键是使用几何应用进行包分类。 首先：每个包都可以用${0,1}^L$空间中的点进行表示。 其次：将中间设备模型化为进行L维空间与子空间转换的box transfer function。如图1中的$T_A()和T_B()$。 最后：使用$\\Psi$作为T的总和，$\\Gamma$作为topology transfer function，至此网络行为可以用$\\Psi$和$\\Gamma$表示。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#introduction"},{"categories":["科研学习"],"content":"几何模型基本介绍 header space $\\mathcal{H}$:将包头视作为0和1组成的平坦序列，而其可视为${0,1}^L$中的一个点，L为包头长度上限，将该空间称作header space $\\mathcal{H}$。 $\\mathcal{H}$不包括数据，因为假高数据不影响包的处理(如果是一个入侵检测的box，那么L就是整个包的长度)，注意：不同的协议对相同的包头位具有不同的解读。 Network Space $\\mathcal{N}$:表示为：${0,1}^{L} \\times{1, \\ldots, P}$，这里${1, \\dots, P}$指的是网络端口，这种所有可能的头空间对应上所有可能的端口称为网络空间$\\mathcal{N}$ Network Transfer Function $\\Psi()$:当包在网络中传输时，它将包从一个point转换到另一个point(s)。所有的网络boxes可以视作为Transfer Function T，而T作用是将从端口p到达的头h映射：$T(h, p) : \\quad(h, p) \\rightarrow\\left{\\left(h_{1}, p_{1}\\right),\\left(h_{2}, p_{2}\\right), \\ldots\\right}$，而$\\Psi(.)$就是所有T组成的一个组合函数，表示为： $\\Psi(h, p)=\\left{\\begin{array}{ll}{T_{1}(h, p)} \u0026 {\\text { if } p \\in \\text { switch }{1}} \\ {\\cdots} \u0026 {\\cdots} \\ {T{n}(h, p)} \u0026 {\\text { if } p \\in \\text { switch }_{n}}\\end{array}\\right.$ Topology Transfer Function $\\Gamma()$:它就是一表示网络连接的函数，在一端接收包并将其发送到另一端（不作修改），这里的连接是单向的，定义为： $\\Gamma(h, p)=\\left{\\begin{array}{ll}{\\left{\\left(h, p^{}\\right)\\right}} \u0026 {\\text { if } p \\text { connected to } p^{}} \\ {{ }} \u0026 {\\text { if } p \\text { is not connected }}\\end{array}\\right.$ Multihop Packet Traversal:使用$\\Phi(.)=\\Psi(\\Gamma(.))$表示,k跳可以被表示为：$\\Psi(\\Gamma(\\ldots(\\Gamma(h, p) \\dots)$或$\\Phi^{k}(h, p)$,，意为$\\Gamma$往链路上交付包，每个$\\Psi$在box里对包进行传递。 Slice:可分为对网络空间，权限，转换函 数的切片。例如：将目的子网为192.168.1.0/24的包限制为port:1,2,3，可被表示为：$((ip_dist(h)=192.168.1.x,p\\in{1,2,3}),rw,\\Psi_s)$ ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#几何模型基本介绍"},{"categories":["科研学习"],"content":"modeling Networking Boxes 本部分是对转换函数的一个说明。例：$ip_src(h)$指的是对源IP，$\\mathcal{R}(h,fields,values)$指将h的fields字段重写为values。在IPv4 router中处理包分为四步：1.重写源和目的MAC。2.减TTL。3.更新校验值。4.交付到出端口。 可表示为：$T_{I P v 4}( .)=T_{f w d}\\left(T_{c h k s u m}\\left(T_{t t l}\\left(T_{m a c}( .)\\right)\\right)\\right)$。一个一个解释：$T_{fwd}(h,p)$表示寻找$ip_dst(h)$并返回output port，类似的，$T_{mac}(.)$表示寻找next hop MAC，更新源MAC和目的MAC。$T_{ttl}(.)$对ttl的处理，为0丢弃，否则减一。也可以简化模型表示如：$T_{I P v 4}( .)=T_{f w d}\\left(T_{t t l}( .)\\right)$ or even $T_{I P v 4}( .)=T_{f w d}( )$，例如一个简化转换函数将子网S1,S2,S3的包分别交付到端口P1,P2，P3表示为： $T_{r}(h, p)=\\left{\\begin{array}{ll}{\\left{\\left(h, p_{1}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{1}} \\ {\\left{\\left(h, p_{2}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{2}} \\ {\\left{\\left(h, p_{3}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{3}} \\ {{ }} \u0026 {\\text { otherwise. }}\\end{array}\\right.$ firewall可模型化为：抽取IP和TCP头，匹配通配符并依匹配规则进行丢弃和交付。 NAT可模型化为：一个重写操作。 模型的详细程度取决于应用需要，可以使用工具对路由配置和交付表进行自动模型建立。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#modeling-networking-boxes"},{"categories":["科研学习"],"content":"Header Space Algebra 对头空间定义集合操作：intersection,union,coplementation,defference，对转换函数定义：Domaain,Range,Range Inverse。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#header-space-algebra"},{"categories":["科研学习"],"content":"$\\mathcal{H}操作$ intersection 可表解为交 如上图，z表示空，如果有任一位为空，则结果为$\\phi$。例：$1100\\mathrm{xxxx} \\cap \\mathrm{xx}00010\\mathrm{x}=1100010\\mathrm{x} $,$1100\\mathrm{xxxx}\\cap 111001\\mathrm{xx}=11\\mathrm{z}001\\mathrm{xx}=\\phi$。这里，对每一位进行编码：0：01,1：10,x:11,z:00，这就可以用集合操作AND对头空间进行操作了。 union 正常的并操用 complementation:补或非，不知道该翻译为哪一个，具体操作规则为： 例：$(100\\mathrm{xxxxx})’=0\\mathrm{xxxxxxx} \\cup \\mathrm{x}1\\mathrm{xxxxxx} \\cup \\mathrm{xx}1\\mathrm{xxxxx}$ Difference:差，$A-B=A\\cap B’$ 例： ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#mathcalh操作"},{"categories":["科研学习"],"content":"Domain,Range,Range Inverse Domain:是转换函数可接收的所有的(header,port)对的集合，even output is empty Range:所有转换函数可能输出的(header,port)对的集合。 Range Inverse:给定一个对S:(header,port)，找到所有可能产生该对的对集合X:{（header,port）}$_n$,即：T（X）=S,X=T$^{-1}$S,可称为逆 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#domainrangerange-inverse"},{"categories":["科研学习"],"content":"使用 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#使用"},{"categories":["科研学习"],"content":"Reachability Analysis 假设a到b，考虑所有可能离开a的包，跟踪它到b的所有路径并转换，到达b后看是否还有,若有，则根据路径求逆找可能的包，否则认为不可达。 用一个例子来说明：定义a到b的可达函数： $R_{a \\rightarrow b}=\\bigcup_{a \\rightarrow b \\text { paths }}\\left{T_{n}\\left(\\Gamma\\left(T_{n-1}\\left(\\ldots \\ldots .\\left(\\Gamma\\left(T_{1}(h, p) \\ldots\\right)\\right)\\right}\\right.\\right.\\right.$所有可能的路径可表示为：$a \\rightarrow S_{1} \\rightarrow \\ldots \\rightarrow S_{n-1} \\rightarrow S_{n} \\rightarrow b$ 该可达函数的range即可从a到b的所有可能的包，可通过求逆函数来根据到达的包求从a出发的原始包：$h_{a}=T_{1}^{-1}\\left(\\Gamma\\left(\\ldots\\left(T_{n-1}^{-1}\\left(\\Gamma\\left(T_{n}^{-1}((h, b)) \\dots\\right)\\right)\\right.\\right.\\right.$ 这里的$\\Gamma=\\Gamma^{-1}$ 图2是一个可达性测试例子。 最后获得的结果为：10010x10 ∪ 01011x10 复杂度分析：$O(dR^2)$,d为包需要经历的最多路由个数，R为交付规则最多的路由的规则数。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#reachability-analysis"},{"categories":["科研学习"],"content":"Loop Detection 普能循环：对于一个给定的网络转换函数，通过往每个端口中注入all-x测试包并跟踪以达到测试环路目的。以下情况停止跟踪：1.包离开网络。2.包到达了之前到达过的端口。3.包到达了注入端口。仅3报告有环。图3为注入测试包示例图，图4为包跟踪图。 图4中，Hdr为当前包头，Port为当前端口，Visits:已访端口，按序。当Port中的值到Visits中每一个值相同则找到loop。 复杂度：$O(dPR^2)$，P是需要注入包的端口数。 finding single infinete loops:在图3中的环：A-C-B-D-A，假设$h_{ret}$表示返回$A_1$的部分头部，$h_{orig}$定义为：$h_{\\text {orig}}=\\Phi^{-1}\\left(\\Phi^{-1}\\left(\\Phi^{-1}\\left(\\Phi^{-1}\\left(h_{\\text {ret}}, A_{1}\\right)\\right)\\right)\\right)$。则，它两有三种相关：1.$h_{r e t} \\cap h_{o r i g}=\\phi$，该环是有尽环。2.$h_{r e t} \\subseteq h_{o r i g} :$该环是无尽环。3.不在以上两种：让包继续包，直到以上两种之一发生。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#loop-detection"},{"categories":["科研学习"],"content":"Slice Isolation 本文方法可以：1.创建新切片并保证隔离性。2.当切片流量泄露时可检测。 创建新切片。两个切片的例子：a和b为网络空间的域：$N_a,N_b \\in \\mathcal{N}$,其中：$N_{a}=\\left{\\left(\\alpha_{i}, p_{i}\\right)\\right]{p{i} \\in \\mathcal{S}} } \\quad, \\quad N_{b}=\\left{\\left(\\beta_{i}, p_{i}\\right)\\right]{p{i} \\in \\mathcal{S}} }$，$\\alpha,\\beta$为headers. 当两个切片无重叠时，$\\alpha_i \\cap \\beta_i = \\phi$。当有重叠时，可以通过$N_{a} \\cap N_{b}=\\left{\\left(\\alpha_{i} \\cap \\beta_{i}, p_{i}\\right)\\right]{p{i} \\in N_{a} \u0026 p_{i} \\in N_{b}} }$找到。 Data leakage:即使两个切片无重叠，也有可能发生数据泄露，因为包在任何端口都有可能被重写。因此在每一个端口使用网络转换函数计算切片a头空间的逆，记为：output header set。如果这个集在任何端口与其他切片重叠，则有可能会发生数据泄露。图5为检测的图形表示。 复杂度：$O(W^2N)$,W是描述切片的通配符最大表达式，N是切片网络个数。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:3:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#slice-isolation"},{"categories":["科研学习"],"content":"实现 本文有源码（找了，没找到），使用python2.6编写实现称为：Hassel。图6为Hassel的block diagram。表1为5个关键优化及其影响。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#实现"},{"categories":["科研学习"],"content":"评估 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#评估"},{"categories":["科研学习"],"content":"Verfication of an enterprise Network 拓扑图如图7。这个图之前见过，好多论文都出现过，原来是斯坦福大学的网络拓扑。 运行Hassel,测量性能。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#verfication-of-an-enterprise-network"},{"categories":["科研学习"],"content":"测试环路 在图7中共找到12个环路，性能总结在表中。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:1:1","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#测试环路"},{"categories":["科研学习"],"content":"测试可能的配置错误 Stnaford 拥有IP：171.64.0.0/14,斯坦福丢弃所有无规则匹配的包，假设这条配置手误出错配成：171.64.0.0/16,那么就有可能在斯坦福和ISP之间来回循环包，在表2中可见这样的错误可以在10分钏之内测出。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:1:2","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#测试可能的配置错误"},{"categories":["科研学习"],"content":"checking slice isolation 本节创建新节片需要验证：1.不能与已存在的切片重叠；2.不能有数据泄露。图8可见切片隔离性测试结果。 图9为切片数据泄露性能测试结果 性能测试结果与复杂性分析类似，程线性，并且性能优。 结语：除此之处，该方法还适用于对新协议的测试但也有不足之处：1.可以测试出路由表不一致，但无法告诉我们原因；2.可以定位到导致问题的具体流，但无法告诉我们how or why；3.只能测试也持续时间很长的问题。 ","date":"2019-09-06","objectID":"/posts/23_header-space-analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header-space-analysis/#checking-slice-isolation"},{"categories":["科研学习"],"content":" Kazemian P, Varghese G, McKeown N. Header space analysis: Static checking for networks[C]//Presented as part of the 9th {USENIX} Symposium on Networked Systems Design and Implementation ({NSDI} 12). 2012: 113-126. 看本文原因：好多文章中的参考文献，且作者Nick是OF提出者。本文提出Header Space Analysis来分析错误类别如：Reachability Failure,Forwarding Loops,Traffic Isolation,Leakage problems。我们装将包头视作一系列位的连接,每个都是一个${0,1}^L$点，L是包头最大长度，而网络box的转换视作将点空间中的一个点转换为另一个（或一些）。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#"},{"categories":["科研学习"],"content":"Introduction 我们的目标是：1.帮助风络管理员静态分析网络；2.保证不同集的主机，用户，流量的隔离；3.使用更通用的方式对网络切片进行静态分析。我们的关键是使用几何应用进行包分类。 首先：每个包都可以用${0,1}^L$空间中的点进行表示。 其次：将中间设备模型化为进行L维空间与子空间转换的box transfer function。如图1中的$T_A()和T_B()$。 最后：使用$\\Psi$作为T的总和，$\\Gamma$作为topology transfer function，至此网络行为可以用$\\Psi$和$\\Gamma$表示。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#introduction"},{"categories":["科研学习"],"content":"几何模型基本介绍 header space $\\mathcal{H}$:将包头视作为0和1组成的平坦序列，而其可视为${0,1}^L$中的一个点，L为包头长度上限，将该空间称作header space $\\mathcal{H}$。 $\\mathcal{H}$不包括数据，因为假高数据不影响包的处理(如果是一个入侵检测的box，那么L就是整个包的长度)，注意：不同的协议对相同的包头位具有不同的解读。 Network Space $\\mathcal{N}$:表示为：${0,1}^{L} \\times{1, \\ldots, P}$，这里${1, \\dots, P}$指的是网络端口，这种所有可能的头空间对应上所有可能的端口称为网络空间$\\mathcal{N}$ Network Transfer Function $\\Psi()$:当包在网络中传输时，它将包从一个point转换到另一个point(s)。所有的网络boxes可以视作为Transfer Function T，而T作用是将从端口p到达的头h映射：$T(h, p) : \\quad(h, p) \\rightarrow\\left{\\left(h_{1}, p_{1}\\right),\\left(h_{2}, p_{2}\\right), \\ldots\\right}$，而$\\Psi(.)$就是所有T组成的一个组合函数，表示为： $\\Psi(h, p)=\\left{\\begin{array}{ll}{T_{1}(h, p)} \u0026 {\\text { if } p \\in \\text { switch }{1}} \\ {\\cdots} \u0026 {\\cdots} \\ {T{n}(h, p)} \u0026 {\\text { if } p \\in \\text { switch }_{n}}\\end{array}\\right.$ Topology Transfer Function $\\Gamma()$:它就是一表示网络连接的函数，在一端接收包并将其发送到另一端（不作修改），这里的连接是单向的，定义为： $\\Gamma(h, p)=\\left{\\begin{array}{ll}{\\left{\\left(h, p^{}\\right)\\right}} \u0026 {\\text { if } p \\text { connected to } p^{}} \\ {{ }} \u0026 {\\text { if } p \\text { is not connected }}\\end{array}\\right.$ Multihop Packet Traversal:使用$\\Phi(.)=\\Psi(\\Gamma(.))$表示,k跳可以被表示为：$\\Psi(\\Gamma(\\ldots(\\Gamma(h, p) \\dots)$或$\\Phi^{k}(h, p)$,，意为$\\Gamma$往链路上交付包，每个$\\Psi$在box里对包进行传递。 Slice:可分为对网络空间，权限，转换函 数的切片。例如：将目的子网为192.168.1.0/24的包限制为port:1,2,3，可被表示为：$((ip_dist(h)=192.168.1.x,p\\in{1,2,3}),rw,\\Psi_s)$ ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#几何模型基本介绍"},{"categories":["科研学习"],"content":"modeling Networking Boxes 本部分是对转换函数的一个说明。例：$ip_src(h)$指的是对源IP，$\\mathcal{R}(h,fields,values)$指将h的fields字段重写为values。在IPv4 router中处理包分为四步：1.重写源和目的MAC。2.减TTL。3.更新校验值。4.交付到出端口。 可表示为：$T_{I P v 4}( .)=T_{f w d}\\left(T_{c h k s u m}\\left(T_{t t l}\\left(T_{m a c}( .)\\right)\\right)\\right)$。一个一个解释：$T_{fwd}(h,p)$表示寻找$ip_dst(h)$并返回output port，类似的，$T_{mac}(.)$表示寻找next hop MAC，更新源MAC和目的MAC。$T_{ttl}(.)$对ttl的处理，为0丢弃，否则减一。也可以简化模型表示如：$T_{I P v 4}( .)=T_{f w d}\\left(T_{t t l}( .)\\right)$ or even $T_{I P v 4}( .)=T_{f w d}( )$，例如一个简化转换函数将子网S1,S2,S3的包分别交付到端口P1,P2，P3表示为： $T_{r}(h, p)=\\left{\\begin{array}{ll}{\\left{\\left(h, p_{1}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{1}} \\ {\\left{\\left(h, p_{2}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{2}} \\ {\\left{\\left(h, p_{3}\\right)\\right}} \u0026 {\\text { if } i p_{-} d s t(h) \\in S_{3}} \\ {{ }} \u0026 {\\text { otherwise. }}\\end{array}\\right.$ firewall可模型化为：抽取IP和TCP头，匹配通配符并依匹配规则进行丢弃和交付。 NAT可模型化为：一个重写操作。 模型的详细程度取决于应用需要，可以使用工具对路由配置和交付表进行自动模型建立。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#modeling-networking-boxes"},{"categories":["科研学习"],"content":"Header Space Algebra 对头空间定义集合操作：intersection,union,coplementation,defference，对转换函数定义：Domaain,Range,Range Inverse。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#header-space-algebra"},{"categories":["科研学习"],"content":"$\\mathcal{H}操作$ intersection 可表解为交 如上图，z表示空，如果有任一位为空，则结果为$\\phi$。例：$1100\\mathrm{xxxx} \\cap \\mathrm{xx}00010\\mathrm{x}=1100010\\mathrm{x} $,$1100\\mathrm{xxxx}\\cap 111001\\mathrm{xx}=11\\mathrm{z}001\\mathrm{xx}=\\phi$。这里，对每一位进行编码：0：01,1：10,x:11,z:00，这就可以用集合操作AND对头空间进行操作了。 union 正常的并操用 complementation:补或非，不知道该翻译为哪一个，具体操作规则为： 例：$(100\\mathrm{xxxxx})’=0\\mathrm{xxxxxxx} \\cup \\mathrm{x}1\\mathrm{xxxxxx} \\cup \\mathrm{xx}1\\mathrm{xxxxx}$ Difference:差，$A-B=A\\cap B’$ 例： ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#mathcalh操作"},{"categories":["科研学习"],"content":"Domain,Range,Range Inverse Domain:是转换函数可接收的所有的(header,port)对的集合，even output is empty Range:所有转换函数可能输出的(header,port)对的集合。 Range Inverse:给定一个对S:(header,port)，找到所有可能产生该对的对集合X:{（header,port）}$_n$,即：T（X）=S,X=T$^{-1}$S,可称为逆 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#domainrangerange-inverse"},{"categories":["科研学习"],"content":"使用 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#使用"},{"categories":["科研学习"],"content":"Reachability Analysis 假设a到b，考虑所有可能离开a的包，跟踪它到b的所有路径并转换，到达b后看是否还有,若有，则根据路径求逆找可能的包，否则认为不可达。 用一个例子来说明：定义a到b的可达函数： $R_{a \\rightarrow b}=\\bigcup_{a \\rightarrow b \\text { paths }}\\left{T_{n}\\left(\\Gamma\\left(T_{n-1}\\left(\\ldots \\ldots .\\left(\\Gamma\\left(T_{1}(h, p) \\ldots\\right)\\right)\\right}\\right.\\right.\\right.$所有可能的路径可表示为：$a \\rightarrow S_{1} \\rightarrow \\ldots \\rightarrow S_{n-1} \\rightarrow S_{n} \\rightarrow b$ 该可达函数的range即可从a到b的所有可能的包，可通过求逆函数来根据到达的包求从a出发的原始包：$h_{a}=T_{1}^{-1}\\left(\\Gamma\\left(\\ldots\\left(T_{n-1}^{-1}\\left(\\Gamma\\left(T_{n}^{-1}((h, b)) \\dots\\right)\\right)\\right.\\right.\\right.$ 这里的$\\Gamma=\\Gamma^{-1}$ 图2是一个可达性测试例子。 最后获得的结果为：10010x10 ∪ 01011x10 复杂度分析：$O(dR^2)$,d为包需要经历的最多路由个数，R为交付规则最多的路由的规则数。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#reachability-analysis"},{"categories":["科研学习"],"content":"Loop Detection 普能循环：对于一个给定的网络转换函数，通过往每个端口中注入all-x测试包并跟踪以达到测试环路目的。以下情况停止跟踪：1.包离开网络。2.包到达了之前到达过的端口。3.包到达了注入端口。仅3报告有环。图3为注入测试包示例图，图4为包跟踪图。 图4中，Hdr为当前包头，Port为当前端口，Visits:已访端口，按序。当Port中的值到Visits中每一个值相同则找到loop。 复杂度：$O(dPR^2)$，P是需要注入包的端口数。 finding single infinete loops:在图3中的环：A-C-B-D-A，假设$h_{ret}$表示返回$A_1$的部分头部，$h_{orig}$定义为：$h_{\\text {orig}}=\\Phi^{-1}\\left(\\Phi^{-1}\\left(\\Phi^{-1}\\left(\\Phi^{-1}\\left(h_{\\text {ret}}, A_{1}\\right)\\right)\\right)\\right)$。则，它两有三种相关：1.$h_{r e t} \\cap h_{o r i g}=\\phi$，该环是有尽环。2.$h_{r e t} \\subseteq h_{o r i g} :$该环是无尽环。3.不在以上两种：让包继续包，直到以上两种之一发生。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#loop-detection"},{"categories":["科研学习"],"content":"Slice Isolation 本文方法可以：1.创建新切片并保证隔离性。2.当切片流量泄露时可检测。 创建新切片。两个切片的例子：a和b为网络空间的域：$N_a,N_b \\in \\mathcal{N}$,其中：$N_{a}=\\left{\\left(\\alpha_{i}, p_{i}\\right)\\right]{p{i} \\in \\mathcal{S}} } \\quad, \\quad N_{b}=\\left{\\left(\\beta_{i}, p_{i}\\right)\\right]{p{i} \\in \\mathcal{S}} }$，$\\alpha,\\beta$为headers. 当两个切片无重叠时，$\\alpha_i \\cap \\beta_i = \\phi$。当有重叠时，可以通过$N_{a} \\cap N_{b}=\\left{\\left(\\alpha_{i} \\cap \\beta_{i}, p_{i}\\right)\\right]{p{i} \\in N_{a} \u0026 p_{i} \\in N_{b}} }$找到。 Data leakage:即使两个切片无重叠，也有可能发生数据泄露，因为包在任何端口都有可能被重写。因此在每一个端口使用网络转换函数计算切片a头空间的逆，记为：output header set。如果这个集在任何端口与其他切片重叠，则有可能会发生数据泄露。图5为检测的图形表示。 复杂度：$O(W^2N)$,W是描述切片的通配符最大表达式，N是切片网络个数。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:3:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#slice-isolation"},{"categories":["科研学习"],"content":"实现 本文有源码（找了，没找到），使用python2.6编写实现称为：Hassel。图6为Hassel的block diagram。表1为5个关键优化及其影响。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#实现"},{"categories":["科研学习"],"content":"评估 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:0:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#评估"},{"categories":["科研学习"],"content":"Verfication of an enterprise Network 拓扑图如图7。这个图之前见过，好多论文都出现过，原来是斯坦福大学的网络拓扑。 运行Hassel,测量性能。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:1:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#verfication-of-an-enterprise-network"},{"categories":["科研学习"],"content":"测试环路 在图7中共找到12个环路，性能总结在表中。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:1:1","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#测试环路"},{"categories":["科研学习"],"content":"测试可能的配置错误 Stnaford 拥有IP：171.64.0.0/14,斯坦福丢弃所有无规则匹配的包，假设这条配置手误出错配成：171.64.0.0/16,那么就有可能在斯坦福和ISP之间来回循环包，在表2中可见这样的错误可以在10分钏之内测出。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:1:2","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#测试可能的配置错误"},{"categories":["科研学习"],"content":"checking slice isolation 本节创建新节片需要验证：1.不能与已存在的切片重叠；2.不能有数据泄露。图8可见切片隔离性测试结果。 图9为切片数据泄露性能测试结果 性能测试结果与复杂性分析类似，程线性，并且性能优。 结语：除此之处，该方法还适用于对新协议的测试但也有不足之处：1.可以测试出路由表不一致，但无法告诉我们原因；2.可以定位到导致问题的具体流，但无法告诉我们how or why；3.只能测试也持续时间很长的问题。 ","date":"2019-09-06","objectID":"/posts/23_header_space_analysis/:2:0","series":null,"tags":["论文阅读"],"title":"Header Space Analysis: Static Checking For Networks","uri":"/posts/23_header_space_analysis/#checking-slice-isolation"},{"categories":["科研学习"],"content":"An Overview of Misuse/Attack Cases in SDN 标签（空格分隔）： security A-01-A:大量packet_in会导致SDN controller不可预期状态，例如，恶意主机生成大量packet_in使用controller资源消耗完。 A-02-M：应用的链式执行会导致：控制信息丢失（恶意应用may加入服务链，并在其他应用等到控制信息前丢弃它）；无限循环（恶意应用会进行无限循环从而阻止链运行） A-03-MA：controller的内部存为所有的application共享，因此不严格的授权会导致内部数据库的拓扑更改。 A-04-MA 控制信息被操控会导致：1.路由表洪泛：一直发假路由表；2.switch标识字段被造假；3.畸形控制信息控制平面发生故障 A-05-M： SDN随机发出控制信息导致：1.流表修改；2.流表清除。 A-06-M：SDN应用可能会通过滥用poorly designed API来影响其他的API应用。如：1.流表修改；2.流表清除。 A-07-MA：SDN应用会排他地使用系统资源从而影响Controller或其他应用的性能如：1.内存耗尽；2.CPU耗尽。 A-08-MA：系统状态变量被修改可能会导致出错，如恶意修改Controller系统时间导致其与其他switches断连。 A-09-A：SDN应用可能会执行系统退出命令来终结Controller实例。 A-10-A：敌人可能通过Controller的 主机跟踪服务或链接发现来修改网络拓扑。1.Host Location Hijacking:通过精心制作的包来随机劫持其他主机的位置。2.Link Fabrication:通过伪造或中继LLDP包给控制器来控制网络拓扑。 B-01-A：敌人可以监听控制信道来偷敏感信息，如：通过窃取控制信道的输出控制信息获得网络拓扑。 B-02-A：敌人可以干涉控制信道，如：修改传输中的流规则信息，使网络行为崩坏。 C-01-MA： 大量的流规则会导致数据平面状态被破坏，如：敌人修改流规则信息并往指定switch插入大量规则使流表溢出。 C-02-M： 某些路由模式的特性可能会被不良使用，如：敌人可能会插入手工流表，而这些流表在某些特征路由模式下不能被固件表处理。 C-03-M： 畸形控制信息会破坏数据平面状态。敌人可能会向数据平面注入畸形控制信息来中断控制平面与数据平面的连接。 原文链接 原文图片 ","date":"2019-09-04","objectID":"/posts/22_misuse_attack/:0:0","series":null,"tags":["论文阅读"],"title":"An Overview of Misuse/Attack Cases in SDN","uri":"/posts/22_misuse_attack/#an-overview-of-misuseattack-cases-in-sdn"},{"categories":["科研学习"],"content":" S. Lee, J. Kim, S. Shin, P. Porras and V. Yegneswaran, “Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks,” 2017 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), Denver, CO, 2017, pp. 249-260. 本文相当于一个框架手册，该框架作用为：一个分布式SDN弹性异常检测应用，它提供高抽象的API，可以使管理员以最小的编程代价布署异常检测应用。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#"},{"categories":["科研学习"],"content":"challenges 大多数威胁检测器未对分布式数据平面进行数据抽取和管理 大多数研究只侧重于具体的某一个异常检测 目前对网络异常特征和异常检测算法的研究很有限 传统的网络异常检测应用如图1 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#challenges"},{"categories":["科研学习"],"content":"Athena Design 设计目标： 提供可扩展特征抽取架构；抽象数据获得过程并简化异常检测服务实现；布署检测服务不需要修改SDN基础设施。 图2为Athena的一个实例，其他布式l地布署在3个Controller上。 其中，Feature Generator通过收集本地控制器和数据平面的控制信息来生成特征并放入DB cluster，Attack Detector通过指定算法进行网络检测，Attack Reactor 通过下发缓解行为到data plane来对检测到的威胁进行响应。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-design"},{"categories":["科研学习"],"content":"Athena System Design Athena由：southbound element,distributed DB,computing cluster,northbound element组成。Southbound element负责对网络进行监控，从SDN控制信息中提取特征，实现检测算法，触发缓解行为。Northbound element负责提供API给应用，从而编写异常检测任务。DB cluster提供特征授权，Computing cluster提供分布式Athena 应用实例的运行。框架图如图3. ","date":"2019-09-03","objectID":"/posts/21_athena/:1:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-system-design"},{"categories":["科研学习"],"content":"Southbound(SB) Element 该部分目标为隔离控制信息，抽取特征来驱动分析算法，并缓解检测到的问题。它由以下四部分组成： SB interface 检测由数据平面和控制平面发出的控制信息，并通过Athena proxy传递由Attack Reactor发出的管理命令。当Athena Proxy发流表规则到date plane时，controller也自动更新它的状状。 Feature Generator 根据进入控制信息抽取特征和根据控制平面状态抽取行为特征特征类别可见表1 Attack Detector 根据Athena NB的要求生成检测模型，根据Feature Generator的特征进行分析，使用检测算法来发现潜在威胁，可以是在线或者批处理模式。当其收到tasks时，将其转成functions和jobs,并根据情况single或分布式方式处理。 Attack Reactor 当其从Detector Manager收到缓解策略时，将其转成messages并通过Athena Proxy发送到数据平面。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:1","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#southboundsb-element"},{"categories":["科研学习"],"content":"Southbound(SB) Element 该部分目标为隔离控制信息，抽取特征来驱动分析算法，并缓解检测到的问题。它由以下四部分组成： SB interface 检测由数据平面和控制平面发出的控制信息，并通过Athena proxy传递由Attack Reactor发出的管理命令。当Athena Proxy发流表规则到date plane时，controller也自动更新它的状状。 Feature Generator 根据进入控制信息抽取特征和根据控制平面状态抽取行为特征特征类别可见表1 Attack Detector 根据Athena NB的要求生成检测模型，根据Feature Generator的特征进行分析，使用检测算法来发现潜在威胁，可以是在线或者批处理模式。当其收到tasks时，将其转成functions和jobs,并根据情况single或分布式方式处理。 Attack Reactor 当其从Detector Manager收到缓解策略时，将其转成messages并通过Athena Proxy发送到数据平面。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:1","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#sb-interface"},{"categories":["科研学习"],"content":"Southbound(SB) Element 该部分目标为隔离控制信息，抽取特征来驱动分析算法，并缓解检测到的问题。它由以下四部分组成： SB interface 检测由数据平面和控制平面发出的控制信息，并通过Athena proxy传递由Attack Reactor发出的管理命令。当Athena Proxy发流表规则到date plane时，controller也自动更新它的状状。 Feature Generator 根据进入控制信息抽取特征和根据控制平面状态抽取行为特征特征类别可见表1 Attack Detector 根据Athena NB的要求生成检测模型，根据Feature Generator的特征进行分析，使用检测算法来发现潜在威胁，可以是在线或者批处理模式。当其收到tasks时，将其转成functions和jobs,并根据情况single或分布式方式处理。 Attack Reactor 当其从Detector Manager收到缓解策略时，将其转成messages并通过Athena Proxy发送到数据平面。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:1","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#feature-generator"},{"categories":["科研学习"],"content":"Southbound(SB) Element 该部分目标为隔离控制信息，抽取特征来驱动分析算法，并缓解检测到的问题。它由以下四部分组成： SB interface 检测由数据平面和控制平面发出的控制信息，并通过Athena proxy传递由Attack Reactor发出的管理命令。当Athena Proxy发流表规则到date plane时，controller也自动更新它的状状。 Feature Generator 根据进入控制信息抽取特征和根据控制平面状态抽取行为特征特征类别可见表1 Attack Detector 根据Athena NB的要求生成检测模型，根据Feature Generator的特征进行分析，使用检测算法来发现潜在威胁，可以是在线或者批处理模式。当其收到tasks时，将其转成functions和jobs,并根据情况single或分布式方式处理。 Attack Reactor 当其从Detector Manager收到缓解策略时，将其转成messages并通过Athena Proxy发送到数据平面。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:1","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#attack-detector"},{"categories":["科研学习"],"content":"Southbound(SB) Element 该部分目标为隔离控制信息，抽取特征来驱动分析算法，并缓解检测到的问题。它由以下四部分组成： SB interface 检测由数据平面和控制平面发出的控制信息，并通过Athena proxy传递由Attack Reactor发出的管理命令。当Athena Proxy发流表规则到date plane时，controller也自动更新它的状状。 Feature Generator 根据进入控制信息抽取特征和根据控制平面状态抽取行为特征特征类别可见表1 Attack Detector 根据Athena NB的要求生成检测模型，根据Feature Generator的特征进行分析，使用检测算法来发现潜在威胁，可以是在线或者批处理模式。当其收到tasks时，将其转成functions和jobs,并根据情况single或分布式方式处理。 Attack Reactor 当其从Detector Manager收到缓解策略时，将其转成messages并通过Athena Proxy发送到数据平面。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:1","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#attack-reactor"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#the-athena-northboundnb-element"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#feature-management-manager"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#detector-manager"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#reaction-manager"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#resource-manager"},{"categories":["科研学习"],"content":"The Athena Northbound(NB) element 提供API，以便开发人员实现功能。 Feature Management Manager 提供一个让应用根据用户限制索取或接收网络特征的机制（它维护一个event deliver table，并以此维护应用限制）。它从应用接收特征请求并将其转为queries，通过DB cluster查询，并将从DB cluster获得的结果传给由Detector Manager管理的compute cluster Detector Manager 提供ML算法生成模型，并与Feature Manager一起动态验证进入的网络特征。它提供统一API使具体算法对operator透明，自动配置算法参数(如使用k-means或DT在表2中是使用想同的API的)。 Reaction Manager 提供缓解策略，使用应用发布策略请求到SB Attack Reactor，而Attack Reactor会自动将其转成flow rules Resource Manager 导出函数以便于管理与特征收集有关的资源。它可以动态调整监控的网络实体数并根据应用的请求生成网络特征。 UI Manager 展示Athena 应用结果并提供交互机制。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:2","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#ui-manager"},{"categories":["科研学习"],"content":"Athena Off-The-Shelf Strategioes Athena Features 特征类型可见表1,Athena有超过100个网络监控特征。特征格式见图4. 分为index fields和feature fields，index fields分为index和meta data，index是特征来源信息如：switch ID,port ID，OF match field.meta data 表示额外信息如时间戳等。feature fields就是网络的具体行为。 Athena Detection Algorithms 见表4 Athena Reactions 根据网络状态改变管理数据平面，方法有两种：block和quarantine。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:3","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-off-the-shelf-strategioes"},{"categories":["科研学习"],"content":"Athena Off-The-Shelf Strategioes Athena Features 特征类型可见表1,Athena有超过100个网络监控特征。特征格式见图4. 分为index fields和feature fields，index fields分为index和meta data，index是特征来源信息如：switch ID,port ID，OF match field.meta data 表示额外信息如时间戳等。feature fields就是网络的具体行为。 Athena Detection Algorithms 见表4 Athena Reactions 根据网络状态改变管理数据平面，方法有两种：block和quarantine。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:3","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-features"},{"categories":["科研学习"],"content":"Athena Off-The-Shelf Strategioes Athena Features 特征类型可见表1,Athena有超过100个网络监控特征。特征格式见图4. 分为index fields和feature fields，index fields分为index和meta data，index是特征来源信息如：switch ID,port ID，OF match field.meta data 表示额外信息如时间戳等。feature fields就是网络的具体行为。 Athena Detection Algorithms 见表4 Athena Reactions 根据网络状态改变管理数据平面，方法有两种：block和quarantine。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:3","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-detection-algorithms"},{"categories":["科研学习"],"content":"Athena Off-The-Shelf Strategioes Athena Features 特征类型可见表1,Athena有超过100个网络监控特征。特征格式见图4. 分为index fields和feature fields，index fields分为index和meta data，index是特征来源信息如：switch ID,port ID，OF match field.meta data 表示额外信息如时间戳等。feature fields就是网络的具体行为。 Athena Detection Algorithms 见表4 Athena Reactions 根据网络状态改变管理数据平面，方法有两种：block和quarantine。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:3","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-reactions"},{"categories":["科研学习"],"content":"The Athena Development Enviroment(DE) DE提供允许使operator以抽象的方式设计和定义检测器。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#the-athena-development-enviromentde"},{"categories":["科研学习"],"content":"Athena Northbound API 可以通过以下步骤生成一个检测模型： 1.定义检测参数 2.定义特征 3.选择想要的算法 表2提供核心函数，表3提供NB API 参数，表4列出每个参数支持的功能。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-northbound-api"},{"categories":["科研学习"],"content":"Athena Application 图5给出实现一个异常检测器步骤的说明 开发人员选择off-the-shelf策略并使用NB API构建异常检测器，Athena自动进行检测任务执行并报告结果给application，application根据结果再配置新的任务。Athena提供GUI接口进行警告和管理Athena application。 ","date":"2019-09-03","objectID":"/posts/21_athena/:2:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-application"},{"categories":["科研学习"],"content":"Athena USE CASE 以DDoS为例。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#athena-use-case"},{"categories":["科研学习"],"content":"情景1：A Large-scale DDoS attack Detector 表5为DDoS发生时可能的特征 1.创建DDoS检测模型：定义特征，设定参数来归一化表5中的特征。 2.DDoS特征验证 3.DDoS测试环境和结果 可见算法1伪代码 与[10]比较见表6,测试结果见图6 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#情景1a-large-scale-ddos-attack-detector"},{"categories":["科研学习"],"content":"情景2：Link Flooding Attacks(LFA) Mitigation 值得注意的一点：Athena布署检测应用而不需要更改网络基础设施，而Spiffy就不能满足。 LFA Mitigation Service using Athena: 需求：链接阻寒检测，识别per-flow rate changes，实现flow alteration LFA Event Handler Registration: 检测器通过link usage计算link utilization和per-flow changes来区分攻击者。Athena支持多个基于流体积的特征，可以当作候选特征。最后，调用AddEventHandler API 来检测和缓解事件。 LFA Detection Logic: 开发人员在Event_handler实现自定义检测逻辑，缓解逻辑通过基于检测结果激发Reactor来阻塞可疑主机。使用Athena，这些只要25行java代码即可实现。 Comparing Athena-based LFA mitigaiton with Spiffy: spiffy需要配置SNMP-based 网络switch,需要布署OpenSketch-enable switch，Athena而很简单，不需要更改基础设施。 ","date":"2019-09-03","objectID":"/posts/21_athena/:2:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#情景2link-flooding-attackslfa-mitigation"},{"categories":["科研学习"],"content":"实现 Controller:ONOS,MongoDB,Spark,JfreeChart，15000行java code。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#实现"},{"categories":["科研学习"],"content":"评估 评价 usability，network scalablity,overhead。 环境：5 servers（64GB RAM,Inter I5 quad-core I5-4690）,7个物理交换机。 ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#评估"},{"categories":["科研学习"],"content":"usability 这里就比实现同一功能所花的代码量，见图8 Athena所花代码量最小。 ","date":"2019-09-03","objectID":"/posts/21_athena/:1:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#usability"},{"categories":["科研学习"],"content":"Scalability 见图10 从图可见，基本跟spark应用差不多 ","date":"2019-09-03","objectID":"/posts/21_athena/:2:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#scalability"},{"categories":["科研学习"],"content":"overhead Cbench（controller benchmarker）是一款OpenFlow控制器性能测试工具，通过模拟一定数量的交换机连接到控制器，发送packet-in消息，并等待控制器下发flow-mods消息来衡量控制器的性能。 Cbench测试见表9 可见Athena将吞吐量降低了50% CPU usage 见图11 Athena的CPU消耗较高，原因可能是Mongo-DB使用的。 ","date":"2019-09-03","objectID":"/posts/21_athena/:3:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#overhead"},{"categories":["科研学习"],"content":"相关工作 表10 本篇有源码！ ","date":"2019-09-03","objectID":"/posts/21_athena/:0:0","series":null,"tags":["论文阅读"],"title":"Athena: A Framework for Scalable Anomaly Detection in Software-Defined Networks ","uri":"/posts/21_athena/#相关工作"},{"categories":["科研学习"],"content":" Silva A S D, Wickboldt J A, Schaefferfilho A, et al. Tool support for the evaluation of anomaly traffic classification for network resilience[C]// Computers \u0026 Communication. 2015. ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:0:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#"},{"categories":["科研学习"],"content":"Tool support for the evaluation of anomaly traffic classification for network resilience ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:0:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#tool-support-for-the-evaluation-of-anomaly-traffic-classification-for-network-resilience"},{"categories":["科研学习"],"content":"标签（空格分隔）： security Silva A S D, Wickboldt J A, Schaefferfilho A, et al. Tool support for the evaluation of anomaly traffic classification for network resilience[C]// Computers \u0026 Communication. 2015. 觉得本文一般，作者对PReSET这篇论文提出的工具进行修改。PReSET是一个对网络可恢复力评估的一个工具，本文利用它来进行流量分类算法的评估。 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:1:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#silva-a-s-d-wickboldt-j-a-schaefferfilho-a-et-al-tool-support-for-the-evaluation-of-anomaly-traffic-classification-for-network-resiliencec-computers--communication-2015"},{"categories":["科研学习"],"content":"Introduction PReSET是一个可以离线评估的工具，网络管理员可以据此对网络配置进行优化，本文对PReSET进行拓展，将其作为工具，并使其可以分析多个异常分类的算法。（意思就是他对别人的东西稍稍加了点东本。） ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:0:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#introduction"},{"categories":["科研学习"],"content":"PRESET:A network resilience simulator PRESET是基于OMNeT++网络模拟器和Ponder2策略框架的一个整合，支持网络攻击的模拟和对相应恢复策略的评估。PReSET可以找到最优策略并找出最优配置参数。在OMNeT++中运行的策略程序产生事件，这些事件指的是一个观测条件，如检测到一个异常。事件可触发条事件行为，这个行为决定哪个策力应该被重新配置和如何配置，XML-RPL 服务器对每个策力提供管理接口。Ponder2使用这些接口进行管理以及适应当前网络，如：调整参数。本文使用K-means和NaiveBayes进行测试。 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:0:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#preseta-network-resilience-simulator"},{"categories":["科研学习"],"content":"实现和实验结果 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:0:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#实现和实验结果"},{"categories":["科研学习"],"content":"Prototype implementation and evaluation set-up 图1是分类器和PReSET整合的整体视图，Classifier与FlowExporter共同运作，Classifier(可以是多个)定期从FlowExporter抽取流特征的统计并进行分类，当有恶意流出现时，一个事件就会发送给Ponder2,ECA policies就会决定如何修改网络配置，这里XMLRPC就是交互接口。本实验中模拟的DDoS，其基本信息在表1中。模拟实验中有912个主机和82个网络服务器，188个routers，流量参数见表2。 843个流中有32个恶意流，已被标记每个都是单向的。 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:1:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#prototype-implementation-and-evaluation-set-up"},{"categories":["科研学习"],"content":"Preliminary analysis and feature selection 每个流都由5元组表示（dIP,sIP,dPORT,sPORT,prot），收集特征为：packet count,byte count,flow duration,mean packet inter-arrival-time。每个特征的二组分布图见图2. 由图可见，packet count和 byte count可以更好地区分流。 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:2:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#preliminary-analysis-and-feature-selection"},{"categories":["科研学习"],"content":"K-means分析 当设置k=2时结果如图3,恶意流都被区分，但也有部分良性流被区分为恶意流。当k=3时，之前被误分的流现在被分为一个新类，结果见图4,这就很好地将流区分开了。图6是分类结果评估， 该算法的缺点是确定中心点个数比较困 难，如图5中k=5，这时恶性流被强行分为了两类，也就是过拟合。 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:3:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#k-means分析"},{"categories":["科研学习"],"content":"Naive Bayes analysis 该方法作为一个补充方法，单独提供训练集，上一节的流作为测试集，结果见图7,当结果为0时这里将其处理为良性流。 结果评估见图8 ","date":"2019-09-02","objectID":"/posts/20_ad_classification/:4:0","series":null,"tags":["论文阅读"],"title":"Tool support for the evaluation of anomaly traffic classification for network resilience","uri":"/posts/20_ad_classification/#naive-bayes-analysis"},{"categories":["科研学习"],"content":" Dhawan M, Poddar R, Mahajan K, et al. SPHINX: Detecting Security Attacks in Software-Defined Networks[C]//NDSS. 2015, 15: 8-11. 本文很不错，写得十分详细，很贴近实用，作者是精通OF协议的。 本文目的提出一种检测已知和未知网络攻击并可实时发出警告，自动学习新的网络行为。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#"},{"categories":["科研学习"],"content":"介绍部分 OF无法阻止switch发包给Controller,且传统攻击手段对SDN也有作用，而防御手段却不管用，OvS也更容易受到攻击，某一个主机或switch可以恶意地使整个网络变慢 网络拓扑攻击 ARP，IGMP，LLDP攻击，例如，恶意switch可以发送随机LLDP信息从而欺骗网络的链路连接性。 数据交付攻击 DDoS攻击，TCAM是存放流表的内存，DDoS攻击可以使流表溢出 传统网攻击手段 传统网中LLDP攻击可通过加密解决，ARP攻击可通过主机运行arpwatch，DAI,或静态映射来解决，然而这些方法在SDN中都不能用。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#介绍部分"},{"categories":["科研学习"],"content":"SPHINX:Overview ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#sphinxoverview"},{"categories":["科研学习"],"content":"Threat Model 目标是为了：找到攻击，验证policies 两个假设：Controller可信，大多数Switch可信，即：$C \\rightarrow S 可信，S \\rightarrow C不可信$ ","date":"2019-09-01","objectID":"/posts/19_sphinx/:1:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#threat-model"},{"categories":["科研学习"],"content":"Flow Graphs SPHINX利用流图模拟拓扑和数据层，利用控制信息进行流图构造。流图的建立是利用FLOW_MOD信息进行的，因为Controller可信。流图例子可见图1,流图时刻与最新拓扑一致。 缺陷：如果大多数的信息被篡改，那么就会使将这些信息视为可信而不发出警报；如果拓扑经常变动，会出现更高的误报。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:2:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#flow-graphs"},{"categories":["科研学习"],"content":"High-level approach SP利用从Controller收集到的控制信息增量建流图。 如图2是SP工作流程 SP拦截flow_mod,stats_reply,packet_in,features_reply消息提取网络拓扑信息，路由交付状态来构建网络视图并维护该流图，然后利用该流图对网络流进行监控，主要通过：自学习信息和管理员的policies进行监控。当有不信任的实体触发改变流行为或当前流违返policies时发出警告。 检测假拓扑例子：SP利用抽取的信息时刻观察网络拓扑状态和连接状态以及switch端口状态，如果packet_in信息中有LLDP，就抽取元数据进行检测：每个端口只能有一个neighbor；连接应该是双向的。 但多个恶意switch可以构建假双向连接接，SP则通过流在switch的字节统计从而确定流是否连续。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:3:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#high-level-approach"},{"categories":["科研学习"],"content":"Why SPHINX works? Easy of anaysis Actrion attribution Domain knowledge #SPHINX:DESIGN 架构如图3,首先：监控所有的控制信息，再验证这些信息，最后验证处理后的网络更新。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:4:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#why-sphinx-works"},{"categories":["科研学习"],"content":"Intercept OpenFlow packets 在图3中的架构可以看到，SP垫在Controller中，以便抽取所有的：PACKET_IN,STATS_REPLY,FEATURE_REPLY,FLOW_MOD消息 ##Build incremental flow graphs 网络中有三类实体：host,switch,flow。SP抽取并记录实体相关的元数据以填充表1中的特征集。 IP/MAC 标记主机，MAC/port标记流，in/out和flow match标记流的waypoint，statistics统计流的字节，包统计。同时，SP还记录具体流的主机，拓扑信息，交付状态以检测潜在的威胁。 packet_in:决定流或拓扑的开始信息 flow_mod:流路径 stats_reply:流级统计 features_reply:收集swithc配置 SP就是收集这些信息来构建拓扑。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:5:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#intercept-openflow-packets"},{"categories":["科研学习"],"content":"Validate netwrok behavior 通过穿过流图来验证网络更新对流的影响和检测相关元数据是否与应用和管理员设定的安全属性一致进行验计，为了加快速度，SP通过缓存当前路径的waypoints来决定这个更新是否满足限制，如果更新修改了path的waypionts，SP缓存也作相应修改。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:6:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#validate-netwrok-behavior"},{"categories":["科研学习"],"content":"SPHINX POLICY ENGIN ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#sphinx-policy-engin"},{"categories":["科研学习"],"content":"Constraint specification 限制分两类：管理员声明的和SP对具体某个流学习的。管理员限制声明使用的是SP的policy language进行的，如表2,这里假设policies都是逻辑正确的。 subject:流标志 object:traffic 属性 opearation：关系，给定流如何到达object trigger:when to check SP把policy给verifier，verifier抽取流的相关特征进行check。图4是一个例子。 当SP发现有异常时就发出alarm，如：从路由来的流统计信息与流当前路径不符。同时，Controller利用本地算法确保计算出的路径可达，无环，无黑洞等。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:1:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#constraint-specification"},{"categories":["科研学习"],"content":"Constraint verification Algorithm1说明了验证步骤： 验证 有三种：packet level,path level,flow level。 packet-level的元数据在具体的pcket_in包里，path-level元数据指网络的交付状态，packet-level和path-level信息在packet_in中获得时是分开的；flow-level指量化具体的数据层交付，定期从stats_reply中获得。表3列出三个元数据类的一些不变量，表4是SP的默认policies。 Topological state constraint verification: 拓扑限制可以使用packet_in中的元数据验证，不变量被验证后，就将元数据与应用policies进行比较，偏移的行为会被标记。 Forwarding state constraint verification 交付状态验证需要验证包和流级元数据，因为假设大多数switch是良性的，因此通过对流的包统计来确认是否出错，这里提出Similarity Index $\\sum$，在t时刻的$\\sum$为：$\\Sigma_{t}=\\Sigma_{t-1}+\\left(\\Delta_{n}-\\Delta_{n-p}\\right) / p$,这里的$\\Delta_{n}=s_{n}-s_{n-1}$,$s_n$是第s个交换机在时刻t的统计结果，当有坏s时它的$\\sum$会不一样，但也会造假$\\sum$，但其下游的s的$\\sum$又会异常。当坏s注入且移走相同的包时会检测不出来，这可以使用加密机制来解决.algorithm2是流的一致性检测算法。 算法解释：输入流和流图，计算该流的路径并找到所有该path上的switch,并计算$\\sum$,如果结果与平均值相差较大，就报告异常。同时也监视其它不活动的switch，以保证不会有流量被注入或吸走。$\\tau$为阈值，当$\\tau=x$时，计算结果要在$\\sum/x和\\sum *x$之间就算正常。太小会误报，太大会不报。例如：当一个链路丢包率为$\\rho,$$s_n$的平均值为$\\sum_{avg}$时，$s_{n+1}$的情况为：$\\Sigma_{n+1} \\propto \\Sigma_{a v g} *(1-\\rho)$，这时如果$\\Sigma_{n+1}$不在$1 / \\tau\u003c\\left(\\Sigma_{n+1} / \\Sigma_{a v g}\\right)\u003c\\tau$时就会出警告，而以上可解出：$\\tau \\le k/(1-\\rho)$。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:2:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#constraint-verification"},{"categories":["科研学习"],"content":"handing alarms 如果出现alarm就让管理员进行数据核对，对于确定性验证SP就给出相应的包，链路，waypoint，对于可能性验证，SP给出switch/out-port和流。正常就将其并入SP的元数据库存起来，可疑就将相应的包丢弃。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:3:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#handing-alarms"},{"categories":["科研学习"],"content":"脆弱的Controller 表5列出和各Controller的不足 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#脆弱的controller"},{"categories":["科研学习"],"content":"Attacks on network topology ARP poisoning SP使用MAC-IP绑定，或有不一样的ARP出现就发出警告，图5给出和该绑定的policy Fake topology switchs:X,Y,Z，Servers:A，B。x-A,z-B,A发送坏LLDP包说这是来自Z的，这就产生了一个Z到X的单向连接，这样从B PING A就得不到回应。SP会使用流图检测拓扑图阻止单向连接的产生，也可用policy，如图6 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:1:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#attacks-on-network-topology"},{"categories":["科研学习"],"content":"attacks on data plane Forwarding controller DoS，给controller发送大量的packet_in，使其忙不过来，这会弄慢整个网的速度 SP会计算packet_in的发送率，越过指定阈值发出警告，图7是pocicy netword DoS switch间的流量环会卡网速 SP通过flow_mod定其更新流图和验证统计字节的一致性。policy见图8 TCAM exhaustion 即插入大量规则使流表溢出 SP检测流插入率，如果超过一定的值并持续就会发出 警告，图9为一个例子policy switch blackhole SP检查字节一致性来找该错误，如果发生了，那它的下一个S的流统计为0 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:2:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#attacks-on-data-plane-forwarding"},{"categories":["科研学习"],"content":"Evaluation 10 servers(IBM x3650 M3 ,2 Intel Xeon x5675 CPU 6 cores at 3.07GHz,128GB RAM)64bit ubuntu v12.04,14 switches(IBM Rack switch G8264) 土豪 host用mininet模拟出来。 这里根据经验设置k=1.034,$\\tau=1.045$ ","date":"2019-09-01","objectID":"/posts/19_sphinx/:0:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#evaluation"},{"categories":["科研学习"],"content":"Accuracy Attack detection:检测时间，结果 sencitiviuty of $\\tau$ 太大太小都不好，不是误报就是不报，合适的值很重要。 ","date":"2019-09-01","objectID":"/posts/19_sphinx/:1:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#accuracy"},{"categories":["科研学习"],"content":"Performance end user latencies：对延迟影响很小 FLOW_MOD throughput:SP可高吞吐量处理且不影响Controller。不过当flow \u003e 2k时处理时间会长。 PACKET_IN process:越多越慢。 policy verification:很快 Resource utilization:基本不占资源，约2%，最高不超过12.8%(你这个是物理机啊。。。。) #Future work 无法处理ingress 或 egress switch的$\\Sigma_s$，缺少现实网络大范围实验，无法检测包的完整性。 HotSDN这个会议怎么样？ ","date":"2019-09-01","objectID":"/posts/19_sphinx/:2:0","series":null,"tags":["论文阅读"],"title":"SPHINX: Detecting Security Attacks in Software-Defined Networks","uri":"/posts/19_sphinx/#performance"},{"categories":["科研学习"],"content":" Shin S , Yegneswaran V , Porras P , et al. AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks[C]// Acm Sigsac Conference on Computer \u0026 Communications Security. ACM, 2013. 本文对of作两个改进：1,利用Connection Migration对TCP连接进行中继，使其可以在data plane过虑掉未完成的TCP连接；2,actuating trigger改进OF协议，使其支持条件流表，即在某一特定条件下激活流表规则以达到网络监控的目的。 整体架构见图1 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:0:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#"},{"categories":["科研学习"],"content":"系统设计 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:0:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#系统设计"},{"categories":["科研学习"],"content":"Connection Migration 利用date plane代理TCP 三次握手，只把完成的对上层进行暴露，实现步骤： 1收到SYN,分类：三次握手完成 2报告：得到控制器允许并插入规则 3转移：找目的host，并成功shake 4报告：通知控制器 5中继，源和目的host建立TCP session 可见图2 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#connection-migration"},{"categories":["科研学习"],"content":"分类（classification stage） 流程见图3 收到TCP：查flow Table,在？交付 不在？是不是SYN？是：ACK 否：RST或丢弃 收到TCP ACK处理流程 收到TCP ACK，查flow table，在？交付 不在？查SYN缓存，有：report 无：RST或丢弃 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:1","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#分类classification-stage"},{"categories":["科研学习"],"content":"Report stage 将flow header信息抽取出来发给Controller，由controller决定是否允许migration，是：Migration 否：未说 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:2","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#report-stage"},{"categories":["科研学习"],"content":"Migration Stage CM与目的主机shake，将shake结果报告给controller ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:3","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#migration-stage"},{"categories":["科研学习"],"content":"Relay Stage 正常中继TCP 举个例子：如图5 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:4","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#relay-stage"},{"categories":["科研学习"],"content":"CM的好处 可降低与TCP握手有关洪泛攻击的影响。 可收集到所有尝试连接数和连接成功数，并以此分析是否有洪泛攻击或探针攻击进行。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:5","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#cm的好处"},{"categories":["科研学习"],"content":"延迟CM 当收到一个TCP连接请求时，收到第一个数据包时才开始report，避免真实TCP连接的攻击。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:6","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#延迟cm"},{"categories":["科研学习"],"content":"Actuating Triggers 它的作用是异步报告信息给Controller，帮助Controller快速管理。它由四步组成： 定义触发条件 condition 注册到date plane date plane 检测包是否满足当前条件 满足：告诉Controller;插入指定规则 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#actuating-triggers"},{"categories":["科研学习"],"content":"Defining a Condition: 本文支三个条件：payload-based,traffic-rate-based,rule-activation 条件格式为：${type:\\qquad condition:\\qquad pointer}$，并对条件的bit位数，以及每一位表示何种意义进行了解释。 数据平面发现条件满足，并有pointer，就添加pointer所指向的rule到flowtable中，图7是一个事件触发场景图解。即当数据平面发现流满足某个条件时就触发条件流表中规定好的行为 。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:1","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#defining-a-condition"},{"categories":["科研学习"],"content":"Condition Registration 条件流表下发到date plane即可 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:2","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#condition-registration"},{"categories":["科研学习"],"content":"Traffic Rate Monitoring 监测流率，将触发条件并入date plane的计数管理逻辑中。 ###Event Notification 当date plane监测到符合条件的信号时就通知Controller。 ###例 payload-based条件中，当条件满足时将标志位置1,就可将相应包传到Controller,图8中，Controller想要10.0.0.1的所有包，告诉date plane匹配条件，若相匹配就将其交给Controller即可。 对于condition Flow Rule Activation，当某些条满足时自动在date plane激活rule，可用来自动处理DDoS这类攻击而不用通知Controller,这样的条件规则需要在date plane实现两个组件：存放规则的内存，用于发现规则的指针。图10说明如何插入并激活一个流规则。 1-3下发安装规则，检测包，4满足条件通知，5插入流规则。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:3","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#traffic-rate-monitoring"},{"categories":["科研学习"],"content":"系统实现 见图11 a是正常的数据平面实现结构，b是实现了我们协议的数据平面，在b中，header parser被修改以抽取TCP flags，arbiter被修改以强制packet editor来进行连接转移并应答TCP SYN/ACK，并为packet editor添加连接处理模块。 添加两个数据结构以支持中继，ACK/SEQ。可选添加Option以处理TCP Option。 实现Actuating Triggers时，利用已有的TCAM和SRAM. 图c是利用switch的CUP和DRAM简化实现。 在A-G中，Controller和switch中都要添加表1中的命令。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:0:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#系统实现"},{"categories":["科研学习"],"content":"评估 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:0:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#评估"},{"categories":["科研学习"],"content":"AG用例 两个场景：AG,传统OF应用预防 三个攻击：网络饱和攻击，网络扫描攻击，网络入侵攻击。 Controller使用POX，switch运行在i5CPU和8G memory。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#ag用例"},{"categories":["科研学习"],"content":"网络饱和攻击 拓扑如图12 测试情景分别在有，无A-G，有，无DDoS四种情况下进行，请求网络所需要平均时间如表2 攻击强度为0-800个包，10个良性客户端请求率如图13 结果一顿夸 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:1","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#网络饱和攻击"},{"categories":["科研学习"],"content":"络扫描攻击 该攻击传统OF也可容易检测出来，但使用AG更加简单，只需要定期收个TCP会话信息即可。图16,17表示使用和不使用AG的区别，16中未使用，attacker最终找到了那个打开的端口，17中使用了AG，他扫到所有的端口都是开着的。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:2","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#络扫描攻击"},{"categories":["科研学习"],"content":"网络入侵检测 使用的攻击是RPC buffer overflow 比较：OF只会发送无法匹配的包头到Controller，因此无法检测到该类攻击，AG可以定义指定特征包并将其发送到Controller Application进行分析. ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:1:3","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#网络入侵检测"},{"categories":["科研学习"],"content":"Overhead Measurement ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#overhead-measurement"},{"categories":["科研学习"],"content":"CM 分析使用AG和OF中建立一个新连接的时间，理论分析见图像20,21 理论一顿解释 后通过实验说明AG花费时间开销特别小。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:2:1","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#cm"},{"categories":["科研学习"],"content":"Actuating Triggers 检测检查条件时所消费的时间，表3给出平均时间 所花时间极少。 本文不足：无法预防应用层攻击，UDP,ICMP攻击。 ","date":"2019-08-31","objectID":"/posts/18_avant-guard/:3:0","series":null,"tags":["论文阅读"],"title":"AVANT-GUARD: scalable and vigilant switch flow management in software-defined networks","uri":"/posts/18_avant-guard/#actuating-triggers-1"},{"categories":["科研学习"],"content":" Zhou H , Wu C , Yang C , et al. SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices[J]. IEEE/ACM Transactions on Networking, 2018, PP(99). 本文目标是通过一个审计器检测被挟持的SDN设备，实验结果并未与其他进行比较，因为他声称自己的正确率有100,但是并没有提供检测具体哪个设备被挟持。 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:0:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#"},{"categories":["科研学习"],"content":"背景介绍 目前的检测方法都是在假设Controller正常的情况下进行的，本文方法是在Controller和Switch均不可信的情况下进行，主要思想是利用备份控制器对当前设备进行检测，进行检测的设备称为审计器（我是这么翻译的），选自slave Controller，使用分布式控制器的场景如图1所示：每个switch被一个master controller管理和几个backup controller管理，当master失效后，会从backup里选一个当master。 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:0:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#背景介绍"},{"categories":["科研学习"],"content":"本文算法 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:0:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#本文算法"},{"categories":["科研学习"],"content":"假设 攻击者所劫持的controller数和switch数不知道，且都有root权限，这里需要假设至少一个switch被劫持且至少一个与其相关的审计器未被劫持。 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:1:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#假设"},{"categories":["科研学习"],"content":"原则 审计器中每条记录需要收集的信息：网络更新请求request，master对该request执行结果，switch收到的更新指令，switch更新后的状态。审计器的每个记录会创建一个审计ID，审计器会计算结果（与master所做的工作相同），并与master比较，如果不一样，就发出警告，说明master被黑，异构控制器作为审计器会更加适合。具体过程为：master会mirror每个收到的update request给auditor,auditor依ID创建审计记录，并重新执行，最后将从master那收到的结果和自己的结果作比较；同时，switch mirror所有的PACKET_IN,instruction,state给它所有的auditor。每条审计记录包含的内容有：网络更新请求request,master的执行结果 $R_{M}$,审计器执行结果$R_A$,switch收到的更新指令$I_S$，相关switch的更新状态$R_S$，可见图2解（这里的request本质上是一个PACKET_IN消息，是switch收到不知如何处理的包时发送给Controller的一个消息）： 审计结果如下： $R_M=I_S=R_S=R_A$正常 $R_M=I_S=R_S \\neq R_A$ master被挟持。 $R_M=I_S \\neq R_S$ switch被挟持。 $R_M \\neq I_S$中间人攻击 switch没接到指令自己更新了， 审计器如果收到一个request就创建一个审计记录，如果是其他的审记消息就把他加入到相应审计ID的记录里，如图3 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:2:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#原则"},{"categories":["科研学习"],"content":"SDN-RDCD algorithm for controllers 本部分是对algorithm1中使用参数进行了相关解释，算法说明跟叙述相同。 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:3:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#sdn-rdcd-algorithm-for-controllers"},{"categories":["科研学习"],"content":"Effectiveness Analysis 如果所有的审计器都被挟持或所有的master和switch都被hacker，这就测不出来，否则只要有一个审计器可用，则可以发出警告并通过日志找到原因。 证明算法有效：$P’$指有SDN-RDCD时被hijack的概率，$P$指没有SDN-RDCD时被hijack的概率，M指master被挟持，S指所有相关的switch被挟持，A指每一个auditor都被挟持。则： $$P=P(M\\cup S)=P(M)+P(S)-P(M\\cap S) \\tag{1}$$ $$P’=P((M\\cap A)\\cup(M\\cap S)\\cup S)=P((M\\cap A)\\cup S)=P(M\\cap A)+P(S)-P(M\\cap A\\cap S)\\tag{2}$$ $P要小于P’$，同时，攻击者很可能未察觉RDCD在运行从而关闭它，因此RDCD更安全，安全加强程度计算公式如下： $$\\Delta P=P-P’=P(M)-P(M\\cap S)-P(M\\cap A)+P(M \\cap A \\cap S) \\tag{3}$$ 图4是相应图解。 如果M与S和A独立，则式3可简化为： $$\\Delta P=P-P’=P(M)(1-P(S \\cup A)) \\tag{4}$$ 令能被检测出来的概率为$P_S$，则可计算出： $$\\begin{aligned}P_S\u0026=1-P(A\\cup(M\\cap S)\\cup S)\\\u0026=1-P(A\\cup S)\\\u0026=1-P(A)-P(S)+P(A\\cap S)\\end{aligned} \\tag{5}$$ ##系统实现 controller利用分布式技术同步信息 switch状态更新通过在OF协议中添加ID字段从而方便审计器处理 switch发送消息给审计器通过添加与FLOW_REMOVED（交换机发送消息给controller的一种方式）相同机制，并且只发送给审计器。 路由状态更新时需要将更新内容和ID发给审计器。 ##overhead analysis 作者总结为可乎略不计 #评估 两个部分：评估监测率、监测时间，评估CUP和内存 其本拓扑如图5 switch环境：quad-core CPU（Intel Xeon 2.5GHz）,16G　memory Master:quad-core CPU（Intel Xeon 2.5GHz）,16G memory Auditor:Master:quad-core CPU(Intel Xeon 2.4GHz),16G memory host1发送PACKET_IN以查host9的位置，每秒5个，300s共1500个，每个都使用不同的源和目的端口 如果控制器被挟持，则控制器安排的路径为蓝色(攻击者安排的路径)而不是最优的红色，switch也是如此。 ##有效性和性能 图6,7 有效性为100%，对被挟持的master测试时间为1.926ms,对被挟持的switch测试时间为7.486ms。 ##overhead evaluation 在有RDCF和无RDCF两种情况下比较，图8,9,10分概率分布，表达结果为：RDCD占用资源很少。 图11,12,13为这三种设备的内存使用性况概率分布 结果也是占用资源很少 图14,15,16是这三种设图带宽占用概率分布，结论也是占用资源很少。 ","date":"2019-08-30","objectID":"/posts/17_sdn-rdcd_ton/:4:0","series":null,"tags":["论文阅读"],"title":"SDN-RDCD: A Real-Time and Reliable Method for Detecting Compromised SDN Devices","uri":"/posts/17_sdn-rdcd_ton/#effectiveness-analysis"},{"categories":["科研学习"],"content":" Kalkan K , Gur G , Alagoz F . SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment[C]// 2017 IEEE Symposium on Computers and Communications (ISCC). IEEE, 2017. 本文是JESS那篇对应的会议文章，记一下主要思想。 ","date":"2019-08-29","objectID":"/posts/16_sdnscore/:0:0","series":null,"tags":["论文阅读"],"title":"SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment","uri":"/posts/16_sdnscore/#"},{"categories":["科研学习"],"content":"SDNScore Mechanism 本机制由switch中的profiler,actuator,comparator,scorer和controller中的PairProfiler组成，用于检测DDoS及其缓解。整个机制图解见图1. ","date":"2019-08-29","objectID":"/posts/16_sdnscore/:0:0","series":null,"tags":["论文阅读"],"title":"SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment","uri":"/posts/16_sdnscore/#sdnscore-mechanism"},{"categories":["科研学习"],"content":"Switch中的机制 Profiler 在无攻击期间switch会有一个统计period,作为正常阶段一个时间间隔的特征统计参考值，本文中switch中的profile存储8个特征的统计：source IP,destination IP,source port,destination port,proto-col type,packet size,TTL valueand，TCP flag.与此同时，该期间Profiler会将收到的所有包头发给controller,controller会根据收到的headers形成pairProfile，如以上8个特征，controller会存储$\\left( \\begin{aligned} 8\\2 \\end{aligned}\\right)=28$个表，而每个switch而要存储8个表。Profiler会在整个阶段都要运行，如acturator阶段会用来形成当前的profile。PariProfile用来进行流量分析和被其他模块使用，profile用来进行选择最适合的属性。 Acturator:监控网络带宽，当带宽超过一个阈值时，即激活comparator和profiler，profiler形成当前的profile.当流量强度回归正常时，它便让其他模块进入备用状态，系统停在基于流的监控状态。 Comparator:当发生拥塞时，acturator激活这个模块，它通过比较nominal profile和current profile来决定可疑属性对：与nominal profile偏移地最远的那个，记为SuspiciousPair。然后向controller请求这个属性对的nominal profile（controller中是以属性对的形式存储的），然后scorer进行面向包的检察和选择性攻击。 Scorer: 本部分由三个小模块组成：计算打分，计算阈值，选择性丢弃包。、 **计算打分：**假设SuspiciousPair属性对$A=a_p,B=b_p$，而打分$S_p$计算为： $$S_p=\\frac{PNP_{(A=a_p,B=b_p)}/TPNP}{PCP_{(A=a_p,B=b_p,\\dots)}/TPCP} \\tag{1}$$ **计算阈值：**本部分利用load shedding algorithm算法计算。阈值Th，使$CDF(Th)=\\Phi$,$\\Phi$是被丢弃的比例，$\\phi$是需要接受的流量，$\\varphi$是当前进入的流量，可通过 流量可表示成：$1-\\Phi=\\frac{\\phi}{\\varphi}$ **选择性丢弃：**如果打分超过阈值，则丢弃。 符号对应讲解： ","date":"2019-08-29","objectID":"/posts/16_sdnscore/:1:0","series":null,"tags":["论文阅读"],"title":"SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment","uri":"/posts/16_sdnscore/#switch中的机制"},{"categories":["科研学习"],"content":"Controller中的机制：PairProfiler 计算PairProfile会使Controller有额外负担，但只在nominal period这样，当comparator请求 某个SuspiciousPair时，再将相应的信息发给他。 ","date":"2019-08-29","objectID":"/posts/16_sdnscore/:2:0","series":null,"tags":["论文阅读"],"title":"SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment","uri":"/posts/16_sdnscore/#controller中的机制pairprofiler"},{"categories":["科研学习"],"content":"开销计算 在假设通信协议为IPv6，在TPNP=5000时经计算总开销为：920KB，可以忽略不计。 #实现 网络拓扑如图2，数据集MAWI，与JESS里用的一样。 结果对比见表2： PN：precision RL:Recall AY:Accuracy FM:F1值 对未知攻击的预测结果比较： 这个表讲的是假设攻击者将包的某些字段设成正常流量字段的结果比较，2个，3个，4个，发现2个时本算法交果较差，但也和当前算法差不多，3个和4个时本算法都能很好地检测出来。 JESS与本文的不同：添加了发生攻击时的补救策略，添加了多个period以增加准确率，算法的过程以公式的方式和图（f4）的方式显示，有对算法的时间，空间，通信复杂度的分析，对整个架构以流程图的方式表达出来，在讲算法时举了例子加以说明，对字段以表的方式展示，是本算法的一个拓展与完善。 ","date":"2019-08-29","objectID":"/posts/16_sdnscore/:0:0","series":null,"tags":["论文阅读"],"title":"SDNScore: A statistical defense mechanism against DDoS attacks in SDN environment","uri":"/posts/16_sdnscore/#开销计算"},{"categories":["科研学习"],"content":" Silva A S D . Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN[C]// Network Operations \u0026 Management Symposium. IEEE, 2016. 本文提出一个架构用于在SDN中的异常检测与缓解，架构分为两个阶段：检测异常（利用Entropy），分类流（Machine Learning）,并提供了实现的源码。源码下载，这个人的github里只有这一个代码项目….下面详细记录这篇文章。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:0:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#"},{"categories":["科研学习"],"content":"framework 本架构由lightweighted 和 heavyweight 两部分组成 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:0:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#framework"},{"categories":["科研学习"],"content":"A. Framework requirements 本段讲解一个架构需要哪些特性、 检索网络信息 网络管理员可干预该框架 可灵活地对网络进行配置 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:1:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#a-framework-requirements"},{"categories":["科研学习"],"content":"Lightweight and Heavyweight Process 基本架构图如图1 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:2:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#lightweight-and-heavyweight-process"},{"categories":["科研学习"],"content":"Lightweight Processing Phase 使用控制平面获得当前流的一个快照（箭头1），并通过计算熵计算得到可疑流（箭头2）移交到下一步（箭头3）。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:2:1","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#lightweight-processing-phase"},{"categories":["科研学习"],"content":"Heavyweight Processing phase 利用ML方式对流进行分类：benign,malicious,unknow，对malicious:mitigation操作，unknow:收集信息便于以后处理，最后要返回监督阶段。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:2:2","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#heavyweight-processing-phase"},{"categories":["科研学习"],"content":"Anomaly Traffic Classification 分类架构如图2所示 由两层构成：statistical layer和classification Layer 统计层由：statcitics Manager,Features Selector,Network Driver 组成，分类层由:Anomaly Monitor,Flow Classifier,Flow Manager组成。 Network Driver:获取流信息，并以流ID为标记，flow id 定义为：（srcip,dstip,srcport,dstport,protocol） Feature Selector：抽取特征：这些特征最好是可以区分流，且计算代价又小的特征 Statistics Manager:总结由Feature Selector和Network Driver收集到数据的特征，如：mean,standard deviation,coefficient of variance,minimun value,maxmum,value。 Anomaly Monitor:计算熵(根据IP或端口号，因为这些对找到DDoS攻击很有效)并找到异常流。假设计算的熵是E，平均熵中M，标准差是S，则正常流判定的根据是：[M-S，M+S] Flow Classifier:对统计到的流特征进行分类，使用K-means进行聚类分类，再使用SVM对每个类进行类别判别，这两个方法的结果可以互补。 Flow Manager:对鉴别的恶意流作进一步处理：丢弃或交给其他组件。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:3:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#anomaly-traffic-classification"},{"categories":["科研学习"],"content":"Framewrok Evaluation 使用校园网络拓扑，基本设备情误解见表1,要评估的问题有：lightweight价段性能，heavyweight 阶段性能，分类准确率。模拟攻击的工具为scapy tool。模拟的攻击有： Port scanning:被打开的端口可以用来传播儒虫。 DDoS attack。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:0:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#framewrok-evaluation"},{"categories":["科研学习"],"content":"lightweight Anomaly Detection Evalutation 评估内存和处理时间，启动框架并监控所需要的内存和处理时间，如图3a和3b所示，大概在180间隔时启动DDoS。 图4为计算熵所需的时间随流数增加的情况： 图5a，5b为异常发生时熵变化情况 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:1:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#lightweight-anomaly-detection-evalutation"},{"categories":["科研学习"],"content":"heavyweight Anomaly classification evaluation 当熵产生变化超过一定值，即进入本阶段，首先是根据当前流量进行流分类，利用K-means聚类，并使用SVM分类，图6展示在攻击发生时活越流数和被阻塞流数 图7为SVM分类评估指标柱状图 当找到异常流时就得用Flow Manager进行阻断 图8为heavyweight阶段所花时间随流数变化的情况。 ","date":"2019-08-28","objectID":"/posts/15_atlantic/:2:0","series":null,"tags":["论文阅读"],"title":"Atlantic : a framework for anomaly traffic detection, classification, and mitigation in SDN","uri":"/posts/15_atlantic/#heavyweight-anomaly-classification-evaluation"},{"categories":["科研学习"],"content":" Niyaz Q , Sun W , Javaid A Y . A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)[J]. Security \u0026 Safety, 2016, 4(12). 没有看的价值，跟深度学习完全扯不上关系，被标题和页码骗了。。 ","date":"2019-08-27","objectID":"/posts/14_dl_ddos_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)","uri":"/posts/14_dl_ddos_sdn/#"},{"categories":["科研学习"],"content":"DDoS Detection System的实现 分为三个部分：信息收集，特征提取，流量收集，结构图如下： ##信息收集方法命名为TCFI，具体算法流程如Algorithm1: 意思是：抽取所有的包头放到packets_list里，将新产生的流存入flow_list里。 被抽取的特征有如表1 ##特征提取和流量分类 特征提取设置时间间隔进行，特征提取模块从TCFI中获得统计信息，并计算特征，按流分类，TCFI的特征被提取后重设特征集。 可抽取的特征总结如下： TCP： UDP： ICMP： 对9-12,43-46,63-67计算字节数和每个流包数的中位数，对8,14,16,18,20,42,48,50,54,62,68计算熵。 算法部分就没有了，也没讲怎么分类。 #实验部分 从公网中抓正常流量，利用hping3构造异常流量，在构造的SDN中进行实验，计算：Accuracy,Precision,RecallF值，ROC 本文：主要了解了一些可用于特征提取的特征集，还有一个用于攻模拟攻击的工具：hping3 ","date":"2019-08-27","objectID":"/posts/14_dl_ddos_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Based DDoS Detection System in Software-Defined Networking (SDN)","uri":"/posts/14_dl_ddos_sdn/#ddos-detection-system的实现"},{"categories":["科研学习"],"content":" Alvarez Cid-Fuentes J , Szabo C , Falkner K . Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs[J]. IEEE Transactions on Dependable and Secure Computing, 2018:1-1. 本文提出框架，通过周期地收集系统矩阵来提取特征，并采用在线SVM法训练和对特征进行分类从而识别异常行为：deadlock,livelock,unwanted synchronization,memory leaks。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:0:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#"},{"categories":["科研学习"],"content":"BARCA 框架 BARCA由Behavior Extractor,Behavior Identifier,Feedback Provider组成。 Behavior Extractor:定期收集Behavior Instance(BI) Behavior Identifier:将BI分类为nomal或abnomal,并使用统计模型调用Behavioral Model(BM).当分为abnomal时，Behavior Indentifier提醒Feedback Provider，由它决定是否通知管理员。 ##行为抽取(Behavior Extractor) 定期收集系统状态矩阵生成BI。假设系统状态矩阵$M={m_i|1 \\le i \\le n}$,定义$r_{ij}$为在时刻j读取系统矩阵i，$s_{ij}=r_{ij},r_{i(j+1)},\\dots,r_{i,(j+z)}$,z为slide window size，$B_j={s_{ij}|1 \\le i\\le n}$。Behavior会再一次从BI中提取特征，而对异常行为的检测可转换为对这些特征偏移的检测。转换过程如下： ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:0:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#barca-框架"},{"categories":["科研学习"],"content":"行为识别（Behavior Identifier） ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#行为识别behavior-identifier"},{"categories":["科研学习"],"content":"SVM 支持向量机简介 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:1","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#svm"},{"categories":["科研学习"],"content":"Gradient Descent 参数更新 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:2","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#gradient-descent"},{"categories":["科研学习"],"content":"Data Normalization(数据归一化) 对待分类的向量进行归一化 $$x_i’=\\frac{1}{1+e^{\\frac{x_i-u_i}{\\sigma_i}}}\\ for\\ 1 \\le i \\le n,$$ u被始化为最先接收到的向量，$\\sigma$初始化为$\\sigma=[1,1,\\cdots,1]$ 后续更新为： $$u_i’=(1-\\frac{1}{t})u_i+\\frac{1}{t}x_i$$ $$\\sigma_i’=(1-\\frac{1}{t})\\sigma_i+\\frac{1}{t}(x_i’-u_i’)^2$$ 这里的x是最样接收到的向量，t为目前已处理的向量个数。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:3","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#data-normalization数据归一化"},{"categories":["科研学习"],"content":"Two-setp Classification 利用单类分类器进行未知异常的检测，利用双类分类器进行识别已知异常。 单类分类器算法伪代码： 单类分类器分为两个部分，CLASSIFY和UPDATE_MODEL。 CLASSIFY用于分类，即正常的分类器，UPDATE_MODEL用于更新，即对分类模型进行训练用的，这里采用online-classify即分类和训练放在一起，没有单独的训练过程。 在UPDATE_MODEL中，假设刚开始的一个时间段进来的所有数据都是正例，则这个时间段是用来训练单类分类器的，对进来的每一个向量利用核函数计算结果，若小于$\\rho$则误分，反向更新$\\rho$,否则正向更新。 双类分类器算法伪代码 与单类分类器原理相似，只是这里的更新过程中的数据是有标签的，利用标签对分类器进行训练和参数更新。 平衡更新过程伪代码 伪代码意思就是：利用正例更新一次模型就要利用负例更新一次，因为因为分类器会偏向实例多的那个类别。 multi-class classifier(MC) 多类分类器是由多个双类分类器组成的，它的作用是用来区分检测到的异常的类别，是由多个单类分类器组成的一个类似有向无环图（DAG）。 两步分类：由单分类器OC确定是否是异常，由双分类器BC加强结果，再由MC确定异常种类，如下图描述了这个过程： 图中，OC用来检测未知异常，BC用来加强已探测到的异常，OC和BC产生的最终结果是第一步的结果，利用权重或其他方法来控制结果占比例，如果第一步的结果是异常，则移到第二步：MC，识别异常。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:4","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#two-setp-classification"},{"categories":["科研学习"],"content":"模型更新 在两步分类结果结交给Feedback Provider，而FP则会通知管理员，Behavior Identifier则会根据结果更新 Behavioral Model，如果是正常就更新OC,异常就更新MC，BC在两种情况下都要更新，且每个分类器的归一化函数独立。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:5","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#模型更新"},{"categories":["科研学习"],"content":"Feedback Provider FB的行为用以下的状态机来描述 在该状态机中，pred表示两步分类中的结果，fb则表示管理员那返回的结果，norm和anom表示连续的正常和异常数，负值表示正常，正值表示异常，FP在train阶段开始，这个阶段可选。Tr控制训练阶段的时常，如果Tr=0则表示没有训练阶段，训练结束FP移到Nomal状态，只要接收到的是正常的预测值，就一直待在这个阶段，如果接到异常，而移到Warning状态，接到异常预测状态会一直持续直到异常数量大于Gr,这里的Gr可以帮助控制误报率。当anom\u003eGr时，FP产生一个alert给管理员，update()将管理员的反馈传给Behavior Identifier，这个反馈可以用来更新BM。FP移到Alert状态，只要预测任是异常，FP就一直保持在Alert，在这个状态如果收到正常预测则返回到cooling，如果正常预测norm\u003eGr而返回Normal状态。如果管理员确认了异常，则移到Clean状态，FP待在这个状态进行z次（滑动窗口大小）观察，如果没有异常发生则返回正常状态。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:2:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#feedback-provider"},{"categories":["科研学习"],"content":"Experiment 测试集中有四种异常：deadlock,livelock,unwanted synchronization,memory leak，每种异常系统的状态矩阵变化如下： ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:0:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#experiment"},{"categories":["科研学习"],"content":"Features 本实难中由Behavior Extractor从矩阵中抽取，以下是在实验中抽取的特征： ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:1:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#features"},{"categories":["科研学习"],"content":"异常检测 本部分主要分析以哪个作为特征用以捕获异常效果更好，以精确率和召回率为和指标作直方图(Gr=20,Tr=400,Windowsize=32,64,128,256) 在分析图后，采用混合特征来进行识别异常，$S_1={CO,ME,B0,S1}$,以ME作为比较(Gr=20,Tr=400,window size=128)，结果如表2 以损失少数准确性为代价，大幅提高整体准确性。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:2:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#异常检测"},{"categories":["科研学习"],"content":"Anomaly Identification Gr=20,Tr=6000,z=128,作各特征比较直方图如下： 根据分析，LH特征效果最好，再选择$S_2={LH,IN},S_3={LH,IN,EP}$进行比较，结果如下表： 以S2作为分类集作混淆矩阵 可见效果还是很好的。 ","date":"2019-08-27","objectID":"/posts/13_ad_svm_tdsc/:3:0","series":null,"tags":["论文阅读"],"title":"Adaptive Performance Anomaly Detection in Distributed Systems Using Online SVMs","uri":"/posts/13_ad_svm_tdsc/#anomaly-identification"},{"categories":["科研学习"],"content":" Shone N , Ngoc T N , Phai V D , et al. A Deep Learning Approach to Network Intrusion Detection[J]. IEEE Transactions on Emerging Topics in Computational Intelligence, 2018, 2(1):41-50. 本文提出用stacked Non-Symmetric deep Auto-encoders 方法进行特征抽取，并将提取的特征传给随机森林进行分类的一种入侵检测方法。 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#"},{"categories":["科研学习"],"content":"基本知识介绍 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#基本知识介绍"},{"categories":["科研学习"],"content":"当前网络安全的主要挑战 网络流量的激增 更深入和更细粒度监控的需求 协议的多种多样和数据的多元化 本文提出一种深度和浅度学习结合的方法：NDAE+RF，使用的测试数据集为KDD Cup'99和NSL-KDD。 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:1:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#当前网络安全的主要挑战"},{"categories":["科研学习"],"content":"Auto-Encoder算法 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#auto-encoder算法"},{"categories":["科研学习"],"content":"原算法 该算法有两个过程：Encoder和Decoder，Encoder过程为了让高维数据在低维中表示出来，Decoder过程将低维数据重新在高维中表示出来。 即它尝试去学习： $$h_{W,b} \\approx x \\tag{1}$$ h是非线性假设，W和b是权重和偏置。它的学习过程就是最小化损失函数： $$L(x,d(f(x))) \\tag{2}$$ 其中，L是损失函数，d是解码函数，f是编码函数 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:1:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#原算法"},{"categories":["科研学习"],"content":"本文的Non-Symmetric Deep Auto-Envoder 多个隐藏层，且只有编码，没有解码 假设输入向量$x\\in R^d$,它将一步一步匹配隐藏层$h_i \\in R^{d_i}$，使用确定性函数表示如下： $$h_i=\\sigma(W_ih_{i-1}+b_i);i=1,\\dots,n \\tag{3}$$ 这里$h_0=x,\\sigma$是挤压函数，n是隐藏层数目。 NDAE没有decoder,它的输出向量类似于如下函数， $$y=\\sigma(W_{n+1}h_n+b_n+1) \\tag{4}$$ 模型可通过最小重构误差获得： $$E(\\theta)=\\sum_{i=1}^{m}(x^{(i)}-y^{(i)})^2 \\tag{5}$$ 这里有个东西它没讲请楚隐藏层的结点数与输入层不一样就没法算误差，如果一样就失去降维意义了 本文件所使用的stack-NDAE,结构如下，它是将两个NDAE接起来，并将结果传给RF进行分类。 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:2:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#本文的non-symmetric-deep-auto-envoder"},{"categories":["科研学习"],"content":"评估和结果 实现：GPU Tensorflow,64-bit Ubuntu 16.04,Intel Xeon 3.60GH,16GB RAM,NVIDIA GTX 750 GPU ##数据集 KDD Cup'99和NSL-KDD,数据集组成情况如下表 高亮表示训练样例小于20个，在实验中被省略。 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:0:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#评估和结果"},{"categories":["科研学习"],"content":"KDD CUP'99测试 评估5类分类性能，结果在表2中展示，可见我们的算法比DBN要好的多。 在我们的方法中，整体准确率为85.42%，优于DBN。对于R2L和U2R，由于测试集太少，因此准确率低。 性能比较在表3中： 我们的方法比DBN节省了78.19%的时间。 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:1:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#kdd-cup99测试"},{"categories":["科研学习"],"content":"NSL-KDD测试 5类分类，结果比较在表4中，ROC曲线比较在图5中 13类分类结果比较见表5，训练时间比较见表6 ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:2:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#nsl-kdd测试"},{"categories":["科研学习"],"content":"未来工作：处理zero-day attack ","date":"2019-08-26","objectID":"/posts/12_dl_ids/:3:0","series":null,"tags":["论文阅读"],"title":"A Deep Learning Approach to Network Intrusion Detection","uri":"/posts/12_dl_ids/#未来工作处理zero-day-attack"},{"categories":["科研学习"],"content":" Garg S , Kaur K , Kumar N , et al. Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective[J]. IEEE Transactions on Multimedia, 2019, 21(3):566-578. 本文利用受限波尔兹曼机进行异常检测。 ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#"},{"categories":["科研学习"],"content":"异常检测模型 controller请求流统计信息，流收集模型收集并抽取特征，基于抽取的物征，利用改进的Restricted Boltzmann Machines进行降维，将结果交给本文提出的SVM算法中进行特征和行为分类，异常检测架构进行报告并通过安全通道发送给controller,controller根据报告进行更改流表和配置。 下图是本框架的方法论： ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#异常检测模型"},{"categories":["科研学习"],"content":"A 降维：受限玻尔兹曼机（RBM） 设RBM有m个可见单元$v_i:[v_1,\\dots,v_m]$和n个隐藏单元$h_j:h=[h_1,\\dots,h_n]$。RBM的标准概率分布可表示为： $$P(h,v:\\theta)=\\frac{1}{Z(\\theta)}exp(a^Th+b^Tv+v^TWh) \\tag{1}$$ W表示权重，a,b表示偏置值，Z区分函数（也叫归一化因子）$\\theta=(W,a,b)$为模型参数。 改进：随机进行Dropout,实现方法：向量$r \\in {0,1}^n$p概率将其置1,将$r_j$关联到隐藏层的$h_j$,这时的联合概念分布为： $$P(r,h,v:p,\\theta)=P(r;p)\\mathcal{P}(h,v|r;\\theta) \\tag{2}$$ where. $$P(r;p)=\\sum_{j=1}^{n}p^{rj}(1-p)^{1-r_j} \\tag{3}$$ $$\\mathcal{P}=\\frac{1}{Z’(\\theta,r)}exp(a^Th+b^Tv+v^TWh) \\times \\sum_{j=1}^{n}g(h_j,r_j) \\tag{4}$$ 其中 $$f(x)=\\left{ \\begin{aligned} h_j=1;if\\ r_j = 1\\ h_j = 0;if\\ r_j=0 \\end{aligned} \\right. \\tag{5} $$ Z是归一化函数。经过Dropout后的RBM中h的激活概率： $$P(h|r,v)=\\sum_{j=1}^{n}P(h_j|r,v) \\tag{6}$$ $$P(h_j=1|r,v)=\\sigma(b_j+\\sum_{i=1}^{m}w_{i,j}v_i);if\\ r_j = 1 \\tag{7}$$ v的激活概率： $$P(v|h)=\\sum_{i=1}^{m}P(v_i|h) \\tag{8}$$ $$P(v_i=1|h)=\\sigma(a_i+\\sum_{j=1}^{n}w_{i,j}h_j) \\tag{9}$$ 当RBM训练完成后，它将输入向量转换为结果向量并传给SVM来进行更进一步的分类。 使用RBM进行降维算法： ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:1:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#a-降维受限玻尔兹曼机rbm"},{"categories":["科研学习"],"content":"B. 分类：SVM 本SVM算法采用的核函数： $$k(x_j,x_k’)=w_1exp[\\frac{-||x_j-x’_k||^2}{2\\sigma ^2}]+w_2(1+x_j^Tx_k’)^d \\tag{10}$$ 该核函数结合了高斯核的局部性能和多项式核的合局性能。 随机梯度下降算法：利用该算法最小化损失函数$C(\\omega)$ $$\\omega_{t+1} \\leftarrow \\eta_t\\Delta_{\\omega}C(\\omega_t) \\tag{11}$$ 模型参数 使用Chaotic Differential Evolution处罚参数$C$,核函数中的$\\sigma$,权重系数$w_1,w_2$进行优化。 ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:2:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#b-分类svm"},{"categories":["科研学习"],"content":"数据传送模型 分四个步骤： 数据提取 分类 报告 中继 控制平面利用异常检测模型将流量分为良性和恶性，将结果报告到控制平面，对恶性流量进行丢弃，良性流量进行继续中继。 ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#数据传送模型"},{"categories":["科研学习"],"content":"多对象流路由框架（MoFR) MoFR提供了一个资源分布的最优化权衡 延迟最小化目标函数 $$\\mathbb{L}(\\delta_{k,v}(t))=\\left{ \\begin{aligned} \u0026(\\sum_j \\frac{d_{vi,vl}\\times \\delta_{k,vi}(t)\\times \\delta_{k,vl}(t)\\times a_{i,l}}{\\mathbb{P}r(t)})\\ \u0026+(\\sum_{i \\in w}\\sum_{j\\in|P(i)|}\\frac{\\mathcal{P}{i,j}(t)}{B{i,j}\\times O_{i,j}(t)})\\ \u0026+(\\sum_{i \\in w}\\sum_{j \\in |P(i)|}\\frac{|\\mathbb{Q}{ready}(t)|}{B{i,j} \\times O_{i,j}(t)})\\ \u0026+(\\sum_{i \\in w}\\mathbb{P}i(t)\\times \\sum_k(t_k^{end-t_k^{start}})\\times \\delta{k,vi(t)}) \\end{aligned} \\right.$$ $\\delta_{k,v}(t)$是一个二元值，表示switch v是否在第$l$个流中被使用，是则值为1,否则为0。 式中第一部分为传输时延，$d_{vi,vl}$表示第i和第l个switch距离(这里没讲清楚距离怎么计算),$\\mathbb{P}r(t)$表示传输时延中位数。 式中第二部分表示转换时延，$\\mathcal{P}{i,j}(t)$表示包大小，$O{i,j}(t)$表示占有率 式中第三部分表示查询时延，$|\\mathbb{Q}_{ready}(t)|$表示队列中的流数量 式中第四部分表示处理时延，$\\mathbb{P}_i(t)$表示由第i个节点的处理时延，$t_k^{start}$表示开始时间 2）带宽最大化函数 $$\\mathbb{B}(\\delta_{k,v}(t))=(\\sum_{i \\in w}\\sum_{j \\in |P(i)|}\\sum_k B_{i,j} \\times (t_k^{end} - t_k^{start})\\times \\delta_{k,vi}(t) \\times \\delta_{k,vl}(t)\\times a_{i,l})$$ 耗能最小化目标标函数 $$\\mathbb{E}(\\delta_{k,v}(t))=(F\\times \\sum_k(t_k^{end}-t_k^{start})\\times \\delta_{k,vi}(t))+(D\\times \\sum_k(t_k^{end}-t_k^{start})\\times \\delta_{k,vi}(t)\\times\\delta_{k,vl}(t)\\times a_{i,l})$$ 能耗由固定部分（风扇等）和动态部分组成（活动的端口数）F和D表示固定部分和静态部分所占的比例。 MoFR $$min\\mathbb{F}(\\delta_{k,v}(t))=f(-\\mathbb{B}(\\delta_{k,i}(t)),\\mathbb{L}(\\delta_{k,i}(t)),\\mathbb{E}(\\delta_{k,i}(t)))$$ ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:1:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#多对象流路由框架mofr"},{"categories":["科研学习"],"content":"实现 （这里它并没有说是怎么实现的，只是说这么做，然后就给了个图） 1）实时数据集 该数据集是从Thapar Insitute of Engineering \u0026 Technology处获得。 观察异常流量所占比例图4a，比较RBM在使用Dropout和不使用的错误率图4b。 比较本文提出的方法，DRBM+GDSVM，RBM+GDSVM，RBM+SVM的侦测率图4c，正确率图4d，AUC图4e 比较SDN和传统网中延迟图4f，带宽图4g，能耗图4h 2）标准数据集KDD'99 比较我们的方法和其他人的方法的侦测率(DR),FPR,准确率，精确率，F值。 本文中方法对各种攻击的侦测率图5a，误判率图5b,准确率图5c，精确率图5d，F值图5e CMU insider threat dataset 对三个场景下与Deep Autoencoder进行性能比较 场景1：uncharacteristic behavior 场景2：steals confidential data 场景3:install keylogger to obtain the password ","date":"2019-08-25","objectID":"/posts/11_dl_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Hybrid Deep-Learning-Based Anomaly Detection Scheme for Suspicious Flow Detection in SDN: A Social Multimedia Perspective","uri":"/posts/11_dl_ad/#实现"},{"categories":["科研学习"],"content":" Zeng H , Kazemian P , Varghese G , et al. Automatic test packet generation[C]// International Conference on Emerging Networking Experiments \u0026 Technologies. IEEE, 2012. ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#"},{"categories":["科研学习"],"content":"背景分析 当前特别需要自动化的网络测试工具 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#背景分析"},{"categories":["科研学习"],"content":"概念 packets Switch Rules：defines how header space at ingress is transformed into regions of header space of egress. Rule Historyt:包被传送过程中记录自己所经历过的规则。 Topology:拓扑结构 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#概念"},{"categories":["科研学习"],"content":"测试包生成算法过程 step1:生成一个all-pairs reachability table 举个例子： 图6所示，如果在$P_A$处注入all-x test packets,包会通过A传递，它会将10.0/16发送到B，将10.1/16发送到C，B再将10.0/16,tcp=80发送到$P_A$,C发送10.1/16到$P_C$，在表4第一行可见。 step2:抽样，抽取测试包，使每一个rule都会被至少一个包测试到。 step3:压缩，找到一个最小的测试包集，它们的rule history可以覆盖所有的rule(经典的最小集覆盖问题，可由贪心算法求得。) ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#测试包生成算法过程"},{"categories":["科研学习"],"content":"错误定位算法 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#错误定位算法"},{"categories":["科研学习"],"content":"基本定义 定义：R(r,pk) = 1,(包pk在规则r下成功验证) 否则 R(r,pk)=0 包在规则下验证失败有两种情况：行为错误，包头匹配错误，这里只考虑行为错误（包被错误地处理）。我们只能在边缘观察到包，所以重新定义： $R(pk)=\\left{ \\begin{aligned} 0 \u0026\u0026 if\\ pk\\ fails\\ 1 \u0026\u0026 if\\ pk\\ succeeds \\end{aligned} \\right.$ ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:1:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#基本定义"},{"categories":["科研学习"],"content":"算法过程 假设1（错误传递）：R(pk) = 1 if and only if $\\forall r \\in pk.history,R(r,pk)=1$. 问题2（错误定位）：对于一个给定的元组列表：$(pk_0,R(pk_0),(pk_1,R(pk_1),\\dots$，找到所有的r，满足$\\exists pk_i,R(pk_i,r)=0$。 step1:找到可疑规则：所有通过的规则集P，失败包的规则集F，F-P即为可疑规则。 step2:缩小可疑规则集：重新发送所有包含可疑规则的测试（该包不在上述的测试包中）包，若通过，则将该规则移出可疑规则集。 step3:获得更小的可疑集后，报告可疑集。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:2:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#算法过程"},{"categories":["科研学习"],"content":"测试用例 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#测试用例"},{"categories":["科研学习"],"content":"功能测试 交付规则：包通过该规则，并从正确的端口离开 链路规则：包正确地通过链路，并且包头未被修改 丢弃规则：将这种测试包进行广播，若在接收终端接收到，则失败。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:1:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#功能测试"},{"categories":["科研学习"],"content":"性能测试 阻塞：对每一对终端进行延迟测量，若延迟大于某个阈值，则定位延迟链路。 可用带宽：对每一个链路，队列，或服务类构造测试包进行测试（iperf/netperf或其他测试方法），可用带宽不应低于某一阈值。 严格的优先级：利用测试包阻塞低优先级类，再测试高优先级类，其带宽不应变化。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:2:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#性能测试"},{"categories":["科研学习"],"content":"实现 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#实现"},{"categories":["科研学习"],"content":"测试包生成 使用python编写测试包生成器生成All-pairs reachability包，并用Min-Set-Cover算法获得包含所有测试规则的最小测试包。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:1:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#测试包生成"},{"categories":["科研学习"],"content":"网络监控器 假设前提是网络上有测试代理，网络监控器构造测试包，并指导代理发送测试包，代理通过IP proto域或TCP/UDP端口号区分测试包。如果测试失败，则从保留包集中选择其他测试包来定位错误。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:2:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#网络监控器"},{"categories":["科研学习"],"content":"可选实现 Cooperative routers:利用路由器发送测试包。 SDN-based testing:controller可以控制路由器发送测试包。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:3:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#可选实现"},{"categories":["科研学习"],"content":"evaluation 在i7,3.2GHz,6G memory，8线程运行ATPG工具，在stanford 和Internet2两个网络中进行测试。 规则重复率的累积分布函数： ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:0:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#evaluation"},{"categories":["科研学习"],"content":"在模拟网络中测试 使用mininet模拟网络，并使用仿真主机发送和接收由ATPG生成的测试包。 交付错误：手动替换交付规则观察结果 阻塞：限制链路30M/s，创建两个20M/s的UDP flow观察吞吐量，如图9左下，延迟如图9右下。 可用带宽：使用之前的链路，把UDP流降低至20M/s,并使用Pathload监控链路带宽，可以找到该链路瓶颈：bbra-yoza。 优先级：重复阻塞实验，当低优先级阻塞时，高优先级测试不受影响，高优先级阻塞时，均阻塞。 ","date":"2019-08-24","objectID":"/posts/10_packet_generation/:1:0","series":null,"tags":["论文阅读"],"title":"Automatic test packet generation","uri":"/posts/10_packet_generation/#在模拟网络中测试"},{"categories":["科研学习"],"content":" Peng Z, Xu S, Yang Z, et al. FOCES: Detecting Forwarding Anomalies in Software Defined Networks[C]// IEEE International Conference on Distributed Computing Systems. 2018. B类。本文提供一种在SDN中进行forwarding anomaly 检测方法，（只提供检测，并未提供定位与解决办法） ","date":"2019-08-23","objectID":"/posts/09_foces/:0:0","series":null,"tags":["论文阅读"],"title":"FOCES: Detecting Forwarding Anomalies in Software Defined Networks","uri":"/posts/09_foces/#"},{"categories":["科研学习"],"content":"基本思想 通过switch统计计数与controller推理计数相比较，判断是否有switch恶意转发包。 ","date":"2019-08-23","objectID":"/posts/09_foces/:0:0","series":null,"tags":["论文阅读"],"title":"FOCES: Detecting Forwarding Anomalies in Software Defined Networks","uri":"/posts/09_foces/#基本思想"},{"categories":["科研学习"],"content":"算法概念 假没有n个flows($f_1,f_2,\\cdots,f_n$)和m个rules($r_1,r_2,\\cdots,r_n$),定义流计数矩阵（FCM）$H_{m \\times n}$,其中，如果流满足规则，则对应矩阵值为1 $$ H_{i,j}=\\left{ \\begin{aligned} 1 \u0026\u0026 if\\ f_{i}\\ matches\\ r_i\\ 0 \u0026\u0026 otherwise \\end{aligned} \\right. \\tag{1} $$ rule计数向量$Y=(y_1,y_2,\\cdots,y_m)^T$,flow计数向量$X=(x_1,x_2,\\cdots,x_n)$ 由此可得FOCES: $$HX=Y \\tag{2}$$ 这是FOCES的基本依据，即：从switch处统计到的流计数与流容量和controller中计算获得的流计数相等。 假设流容量矩阵是$X_0$当switch出现交付异常时，FCM变成了$H’$,这时观察到的计数矩阵变成了$Y’=H’X_0 \\neq Y_0$。由于controller并不知道$H’$，所以当需要恢复$X_0$时就要利用 $$HX=Y’ \\tag{3}$$ 可以解得对$X_0$的估计 $$\\hat{X} = (H^TH)^{-1}H^TY’ \\tag{4}$$ 从而计算$\\hat{Y} = H\\hat{X}$,再计算绝对值差 $$\\Delta=|Y’-\\hat{Y}| \\tag{5}$$ 理想情况下，当绝对值差不为0时，则认为发生了交付异常。 有的情况下交付异常无法测出，如： $X_0=(3,4,5)^T$, , 可算得$\\hat{X}=(3,1,8)^T$,这时计算出的$\\Delta=0$，可以看到，这是一个反例，出现了交付异常却无法检测出来。这里我要把原文贴上了，因为我看不懂它说什么样的情况测不出来。 阈值计算方法： ","date":"2019-08-23","objectID":"/posts/09_foces/:0:0","series":null,"tags":["论文阅读"],"title":"FOCES: Detecting Forwarding Anomalies in Software Defined Networks","uri":"/posts/09_foces/#算法概念"},{"categories":["科研学习"],"content":"算法流程： 矩阵切片： 对于一个特定的switch Si,构造矩阵时只找与Si有关的规则，同样，也只计算流经Si的flow 切片算法流程： ","date":"2019-08-23","objectID":"/posts/09_foces/:0:0","series":null,"tags":["论文阅读"],"title":"FOCES: Detecting Forwarding Anomalies in Software Defined Networks","uri":"/posts/09_foces/#算法流程"},{"categories":["科研学习"],"content":"缺点 只能检测出有异常，而无法定位异常发生在哪个switch ","date":"2019-08-23","objectID":"/posts/09_foces/:0:0","series":null,"tags":["论文阅读"],"title":"FOCES: Detecting Forwarding Anomalies in Software Defined Networks","uri":"/posts/09_foces/#缺点"},{"categories":["科研学习"],"content":" Carvalho L F , Fernandes G , Rodrigues J J P C , et al. A novel anomaly detection system to assist network management in SDN environment[C]// IEEE International Conference on Communications. IEEE, 2017. C类。本文提出一种辅助网络管理的异常检测系统，算法运行在controller，分为四个模块： ","date":"2019-08-22","objectID":"/posts/08_ad_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment","uri":"/posts/08_ad_sdn/#"},{"categories":["科研学习"],"content":"statistic collection module controller定期向switch发送收集信息请求，并以统计的形式将特征（如源/目的IP,源/目的port等）存入profile中$X={n_1,\\cdots,n_i,\\cdots,n_N}$，其中$n_i$表示特征i发生次数，这样便可获得熵的信息：$H(X)=-\\sum_(i=1)^N(\\frac{n_i}{S})log_2(\\frac{n_i}{S})$,其中，$S=\\sum_{i=1}^{N}n_i$ ","date":"2019-08-22","objectID":"/posts/08_ad_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment","uri":"/posts/08_ad_sdn/#statistic-collection-module"},{"categories":["科研学习"],"content":"Anomaly Detection Module 本模块目的是找到异常流。首先，从profile里获得正常流信息，信息存放在$P_{n \\times a}$矩阵中，n是收集信息次数，a是信息维度，因此$p_{ij}$代表了第i个时间段的第j个特征。如果一个事件偏离profile太远，即被定义为异常，如果异常库没有该异常相关信息而将其存储并之后再检测。（这里并没有讲它是怎么计算偏移的，应该是通过熵）.有的常规流量也会有异常特征，这通过添加白名单来解决。 ","date":"2019-08-22","objectID":"/posts/08_ad_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment","uri":"/posts/08_ad_sdn/#anomaly-detection-module"},{"categories":["科研学习"],"content":"Mitigation Module 检测到异常就将异常流信息发送至缓解模块，缓解模块将信息插入流表以禁止恶意流量交付。 ","date":"2019-08-22","objectID":"/posts/08_ad_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment","uri":"/posts/08_ad_sdn/#mitigation-module"},{"categories":["科研学习"],"content":"Reporting Module 向管理员提供一些有用的信息，如未知异常。 本篇感觉总体感觉价值不大。 ","date":"2019-08-22","objectID":"/posts/08_ad_sdn/:0:0","series":null,"tags":["论文阅读"],"title":"A Novel Anomaly Detection System to Asist Network Management in SDN Enviroment","uri":"/posts/08_ad_sdn/#reporting-module"},{"categories":["科研学习"],"content":" Huijun P , Zhe S , Xuejian Z , et al. [J]. IEEE Access, 2018:1-1. 本文件基于knn的一个改进算法提出了一个异常检测算法。 ","date":"2019-08-21","objectID":"/posts/06_ad_sdn_acess/:0:0","series":null,"tags":["论文阅读"],"title":"A detection method for anomaly flow in software defined network","uri":"/posts/06_ad_sdn_acess/#"},{"categories":["科研学习"],"content":"一些概念： 欧几里德距离：$D_{ij}^y = \\sqrt{\\sum_{a=1}^{t}({X_{ia} - X_{ja}})^2}$ strangeness(陌生度)：$\\alpha_{iy}=\\frac{\\sum_{j=1}^kD_{ij}^y}{\\sum_{j=1}^kD_{ij}^{-y}}$ i与正例和反例的距离之比，越小越倾向与正例。 independence(独立度)：$\\theta_{iy}=\\sum_{j=1}^kD_{ij}^y $ i在正例中的距离之和，越小越倾向正例。 double p value:$p_1(\\alpha_i)=\\frac{\\#{j=(1,\\cdots,n):\\alpha_j \\ge \\alpha_i}}{n+1} $ 越大，则越正常 $p_2(\\theta_i) = \\frac{\\#{j=(1,\\cdots,n):\\theta_j \\ge\\theta_i}}{n+1} $ 越大，则越正常 ","date":"2019-08-21","objectID":"/posts/06_ad_sdn_acess/:0:0","series":null,"tags":["论文阅读"],"title":"A detection method for anomaly flow in software defined network","uri":"/posts/06_ad_sdn_acess/#一些概念"},{"categories":["科研学习"],"content":"算法步骤 step1 在训练集样例中进行欧几里德距离计算 step2 在训练集样例中进行陌生度和独立度计算 step3 计算检测点的陌生度和独立度 step4 计算检测点的double p value step5 识别异常点：结点为正常用结点条件为 $p_1(\\alpha_i) \\ge \\tau_1 \\quad and \\quad p_2(\\theta_i) \\ge \\tau_2$,$\\tau$由controller控制。 ","date":"2019-08-21","objectID":"/posts/06_ad_sdn_acess/:0:0","series":null,"tags":["论文阅读"],"title":"A detection method for anomaly flow in software defined network","uri":"/posts/06_ad_sdn_acess/#算法步骤"},{"categories":["科研学习"],"content":" Paxson, Vern. An analysis of using reflectors for distributed denial-of-service attacks[J]. ACM SIGCOMM Computer Communication Review, 2001, 31(3):38. 本文先讲解了DDoS攻击，再讲解基于reflector的DDoS攻击，最后基于各种网络协议的字段进行挨个分析，讲解哪些字段容易受到attacker的利用从而进行攻击。 DDoS攻击结构： 使用反射器的DDoS攻击 各协议可能被攻击的字段分析 ip ：Type of Service TCP:If the reflector’s stack has guessable TCP sequence numbers ICMP: reflectors generating ICMP messages can likely be filtered out. UDP:port number can be filtered. DNS:递归查询，欺骗查询 http: would be a significant threat were it not for the likely quick traceback due to the non-spoofed connection from the slave to the proxy. Definitely a significant threat if servers running on stacks with predictable sequence numbers are widely deployed. Other TCP application: would be a significant threat were it not for the likely quick traceback due to the non-spoofed connection from the slave to the proxy. Definitely a significant threat if servers running on stacks with predictable sequence numbers are widely deployed. 原文值得细看，不错的文章，就是语法太难了。 ","date":"2019-08-20","objectID":"/posts/07_reflector_sigcomm/:0:0","series":null,"tags":["论文阅读"],"title":"An Analysis of Using Reflectors for Distributed Denial-of-Service Attacks","uri":"/posts/07_reflector_sigcomm/#"},{"categories":["科研学习"],"content":" Kalkan K , Altay L , Gur G , et al. JESS: Joint Entropy Based DDoS Defense Scheme in SDN[J]. IEEE Journal on Selected Areas in Communications, 2018:1-1. 该文提出了一种基于熵的DDoS攻击的检测与缓解办法。 ","date":"2019-08-19","objectID":"/posts/04_jess/:0:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#"},{"categories":["科研学习"],"content":"introduction SDN存在安全问题，如DDoS攻击，解决办法有: 内在：structural attributes of SDN enviroment on the properties of traffic flows 外在：statistical and ml Entropy shows randomness,DDoS decraese randomness. ","date":"2019-08-19","objectID":"/posts/04_jess/:0:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#introduction"},{"categories":["科研学习"],"content":"related work 网络虚拟化及其安全 SDN安全相关研究 ","date":"2019-08-19","objectID":"/posts/04_jess/:0:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#related-work"},{"categories":["科研学习"],"content":"Join Entropy Based DDoS Defense Scheme In SDN(JESS) 分为三个小步： nominal stage:switch sends headers of all packets to controller,controller calculates joint entropies of each pair preparatory stage:controller generate current pair profiles and calculates joint entropies,difference exceeds $\\theta_j$,DDoS attack is detected,maximum difference is SuspiciousPair and send to switch active mitigation stage:switch creates SC of SuspiciousPair and send to controller,controller calculates correspoinding score and generates scoretable ST,rule table $RT_C$ with a designated $\\theta_s$,if score of entry under $\\theta_s$ forward, otherwise drop. 剩下的是算法的细则，太多了建议看原文 ","date":"2019-08-19","objectID":"/posts/04_jess/:0:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#join-entropy-based-ddos-defense-scheme-in-sdnjess"},{"categories":["科研学习"],"content":"Nominal Stage Nominal Profile Generation 收集一些重要的参数，表示成：$\\mathbb{P}={IP_{src},IP_{dst},P_{src},P_{dst},PROT,PKT_{size},TTC,TCP_{flag}}$,记$\\left(\\begin{aligned}\\mathbb{P}\\k\\end{aligned}\\right)$k个元组组成的集合，如$\\left(\\begin{aligned}\\mathbb{P}\\2\\end{aligned}\\right)={{IP_{src},IP_{dst}},\\dots,{TTL,TCP_{flag}}}$记$\\mathbb{A}i$是$\\left(\\begin{aligned}\\mathbb{P}\\2\\end{aligned}\\right)$的第i个元组，例$\\mathbb{A}1={IP{src},IP{dst}}$,它有$2^{32}*2^{32}$个可能。$\\mathbb{A}2={IP{src},P_{src}}$有$2^{32}*2^{16}$个可能。switch收集包头并发送给controller，收集到指定个数即可停。在指定包数被处理后假设有$\\alpha$个包对，则组成$\\alpha * k$矩阵，记为$E^{\\mathbb{A}_i}$,$E^{\\mathbb{A}_i}_j$表示为第j个元组，它的值为$E^{\\mathbb{A}_i}_j=（a_j,b_j）$。$E^{\\mathbb{A}_i}$可表示为： 基于$E^{\\mathbb{A}_i}$创建$N^{\\mathbb{A}_i}$，记为： 这里的$m_i$取决于这个阶段收集到不同属性的个数，这是一个$m \\times (k+1)$的矩阵。这里的建$N^{\\mathbb{A}_i}$就是Pair Nominal Profile，由controller形成。这里的$PAC^{\\mathbb{A}_i}$指的是${\\mathbb{A}_i}$的产生个数。 Nominal Profile of Order p 即p个历史阶段的Nominal Profile 第p个记为: 分阶段时，生成的profile为不同段的并集。用图表示如图4： Joint Entropy Calculation for Nominal Profiles 在生成profile阶段计算出该阶段的熵，并存入profile中，当检测时，将当时的流量计算出来的熵与profile中的熵比较，超出$\\theta_j$即可认定有DDoS发生，选相差最大的那个对作为主导对(determinant pair)。熵计算公式为： $$JN_{N^{A_i}}=-\\sum_{n=1}^{m_i}(\\frac{PAC^{A_i^n}}{\\alpha})\\log{(\\frac{PAC^{A_i^n}}{\\alpha})} \\tag{4}$$ 简记： $$PN_{A_i^n}=PAC^{A_i^n}/\\alpha \\tag{5}$$ 而式（4）变为： $$JN_{N^{A_i}}=-\\sum_{n=1}^{m_i}PN_{A_i^n}\\log{(PN_{A_i^n})} \\tag{6}$$ 归一化后最终得到的公式为： $$\\bar{JN}{N^{A_i}}=JN{N^{A_i}}/\\log[\\alpha] \\tag{7}$$ 使用时均用归一化的熵 ","date":"2019-08-19","objectID":"/posts/04_jess/:1:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#nominal-stage"},{"categories":["科研学习"],"content":"Preparatory Stage 本阶段检测攻击，并决定最适合的pair(这个对即用来识别异常的对)，分为三个阶段： Current Profile Generation 第i个当前的profile表示为： Joint Entropy Calculation for current profile 对当前profile而言， $$PC_{A_i^n}=PAC^{A_i^n}/\\alpha \\tag{9}$$ 则当前的熵JC表示为： $$JC_{N^{A_i}}=-\\sum_{n=1}^{m_i}PC_{A^n_i}\\log{(PC_{A_i^n})} \\tag{10}$$ Comparison $$\\Delta J_{N^{A_i}}=JC_{N^{A_i}}-JN_{N^{A_i}} \\tag{11}$$ 当这个值超过一个$\\theta_j$，则认为检测到了DDoS攻击， 对所有的差值，JESS找到差值最大的对，将其标为SuspiciousPair。 如：对$\\arrowvert\\mathbb{P}\\arrowvert = 8，k=2$时，$\\Delta J_{MAX}=\\max{\\Delta J_{N^{A_1}},\\Delta J_{N^{A_2}},\\cdots,\\Delta J_{N^{A_28}}}$,假设$\\Delta J_{N^{A_2}}$是最大的，就将其标为suspiciousPair，Controller便将这个SuspiciousPair发送给switch。 ","date":"2019-08-19","objectID":"/posts/04_jess/:2:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#preparatory-stage"},{"categories":["科研学习"],"content":"Active Mitigation Stage 这个过程有五个步骤 SuspiciousPair Profile Generation switch已知SuspiciousPair，则在本地生成Profile SC，并将其发送到controller Score Calculation: 对每个流计算$\\beta$: $$\\beta = \\frac{PC_{A_i^n}}{PN_{A_i^n}} \\tag{12}$$ 将计算所得的$\\beta$存于表ST中。 决定阈值 利用load shedding alporithm来决定，阈值$\\theta_S$由当前阈值$\\theta_C$和之前阈值$\\theta_P$共同决定 $$\\theta_S=\\frac{\\theta_C+\\theta_P}{2} \\tag{13}$$ Rule Generation 对每个SC中的entry进行计算，若打分超过阈值，drop it! otherwise,forwarded to the destination! Differing Rules($\\Delta - Rules$) determination 更新规则时，将当前规则与之前规则作对比，只发送不一样的那部分。 ","date":"2019-08-19","objectID":"/posts/04_jess/:3:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#active-mitigation-stage"},{"categories":["科研学习"],"content":"模拟与性能评估 数据集：MAWI 环境：RYU，8G RAM，Core i7-3610QM 2.3GHz CPU,Ubuntu 14.04 OS。 拓扑结构（图5）： （这个拓扑也太简单了点吧。。。） packet analysis in Mininet 利用mininet统计各种头信息，如表5 攻击种类 Performance Metrics 即评价标准：$FPR=\\frac{FP}{FP+TN}$ $ACC=\\frac{TP+TN}{TP+TN+FP+FN}$ Exprimental Results 结果分析 分析：误报率有时候会提高，原因是许多包有和攻击包一样的特征。为了提高效果，引入滑动窗口。 引入滑动窗口 网络拓扑为如图8 使用previous periods,也即意味着要存储这么多periods的所有的头值，如TCP滑动窗口般。（作 者经过计算，发现浪费不多 ）结果如图10,结论为：效果确实提高了不少！在不同攻击强度下效果对比 结果如图11所示： 结论：当攻击包与正常包数量相同时，难以区分。 算法分析 结论：时间复杂度：$O(n^2)$，处理加载过程不需要额外缓存；所需空间少，对controller负担小，通信代价几乎可勿略不计。 问题：为什么先择两个特征而不是更多个，没有做对比！ ","date":"2019-08-19","objectID":"/posts/04_jess/:0:0","series":null,"tags":["论文阅读"],"title":"JESS: Joint Entropy-Based DDoS Defense Scheme in SDN","uri":"/posts/04_jess/#模拟与性能评估"},{"categories":["科研学习"],"content":" Giotis K , Androulidakis G , Maglaris V . Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks[C]// Third European Workshop on Software Defined Networks. IEEE Computer Society, 2014. 本文主要提出一种架构：利用SDN中的Controller改进现有的网络体系中进行Anomaly Detection(AD) ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#"},{"categories":["科研学习"],"content":"Introduction DDoS的危害，以前的解决办法（文献较老）会使受害主要的良性流和恶性流量均不通过，本文的架构可改善这种状况。 ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#introduction"},{"categories":["科研学习"],"content":"Motivation and related word 讲述相关工作，但并未提及本文与之不同之处。（估记就是找几个不好的讲了一讲） ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#motivation-and-related-word"},{"categories":["科研学习"],"content":"Design Principles and Overall Architecture 本文提出的架构如图： ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#design-principles-and-overall-architecture"},{"categories":["科研学习"],"content":"A. Design pricinple 以流为粒度 data gathering,AD,mitigation function decoupling Dynamic triggering of the RTBH mechanism,remote and automatic configuation trigger device scalable traffic statistics collection using packet sampling techniques,achived by sFlow ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:1:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#a-design-pricinple"},{"categories":["科研学习"],"content":"B. overflow Architecture 见图1 有三个功能： Anomaly Detection/Identification two modules: first,statistics Collection,monitoring harvesting from the edge router,export them to the next module inline second,AD ,detect potential attck,identifies the victim,intructs the RTBH trigger device propagate static route RTBH Component match victim IP and redirect to OF switch propagate route to entir network Anomaly Mitigation identification malicious,segregate malicious and benign traffic,drop malicious traffic,fowarding benign traffic to inport. ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:2:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#b-overflow-architecture"},{"categories":["科研学习"],"content":"RTBH and anomaly detection empowered by the openflow protocol and sFlow capabilities ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:0:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#rtbh-and-anomaly-detection-empowered-by-the-openflow-protocol-and-sflow-capabilities"},{"categories":["科研学习"],"content":"A. Victim Identification Mechanism compute the average counter value and corresponding deviation,compare the value with particular IP ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:1:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#a-victim-identification-mechanism"},{"categories":["科研学习"],"content":"B. Using RTBH to redirect and filter network tarffic. (1) 以前的RTBH,会导致victim的benign traffic也不c通 (2) forward packets to OF-enable switch,drop only malicious traffic,enpowered the ADI with remotely configuring the RTBH trigger device ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:2:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#b-using-rtbh-to-redirect-and-filter-network-tarffic"},{"categories":["科研学习"],"content":"C. Anomaly Mitigation forward packets back inport of the OF,Drop malicious traffic. ","date":"2019-08-18","objectID":"/posts/03_sdn_ad/:3:0","series":null,"tags":["论文阅读"],"title":"Leveraging SDN for Efficient Anomaly Detection and Mitigation on Legacy Networks","uri":"/posts/03_sdn_ad/#c-anomaly-mitigation"},{"categories":["科研学习"],"content":"A distributed filtering mechanism against DDoS attacks: ScoreForCore Kalkan K, Alagöz F. A distributed filtering mechanism against DDoS attacks: ScoreForCore[J]. Computer Networks, 2016, 108: 199-209. 本文提出ScoreForCore基于主动和协作过滤的防御机制，特点为：在当前的攻击流中选择最合适的属性。本文由PackerScore[2]启发，由于[2]中的实时检测没有属性筛选，因此性能较差。 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:0:0","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#a-distributed-filtering-mechanism-against-ddos-attacks-scoreforcore"},{"categories":["科研学习"],"content":"ScoreForCore 本文术语见表1 当前基于过滤的出防御方式有(individual,cooperative)X(reactive,proactive)，基中cooperative proactive为本文研究。 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:0:0","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#scoreforcore"},{"categories":["科研学习"],"content":"Design issues 本文在[2]的基础上改进，使用[2]的打分方法。本文使用当前攻击最具代表性的属性创建profile。需要考虑如下： ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:0","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#design-issues"},{"categories":["科研学习"],"content":"profiling 分别在正常阶段和攻击阶段生成nominal 和current profile，要利用的属性有：（IP，Port,protocol type,packet size,TL,TCP flag。 nominal阶段本文采用路由随机选属性对来统计信息。因此每个路由存储每个属性的single profile和一个随机对属性：OwnPairs Nomial Profile(OPNP).攻击发生而本路由器没有最佳属性对时可从别的路由那获取。属性对profile示例如表2. 攻击阶段（阻塞发生时），对每个属性进行统计生成 single current profile(SingleCPs) ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:1","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#profiling"},{"categories":["科研学习"],"content":"comparison 将nominal profile与current profile相比较，如T3,T4,对每个属性找属性值统计中差最大的，如表3中的TCP和表4中的83，会找到6个属性值及其最大差值，再在这六个中找最大的前两个当作suspicious pair。对于当前路由器随机属性对中没有suspicious pair时，可从别的路由中获取。 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:2","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#comparison"},{"categories":["科研学习"],"content":"collaboration 当前router没有，则向邻居请求可疑对的OPNP，并作为自己的SPNP。如果三跳邻居都没有，而使用自己的OPNP作为SPNP。 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:3","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#collaboration"},{"categories":["科研学习"],"content":"score calculation 在前一步，每个router都有了SPCP和SPNP，对新包计算打分公式为： $S_{p}=\\frac{S \\operatorname{corePC} P_{(A=a_{p}, B=b_{p}\\right)} / T P C P}{\\text {ScorePNP}{\\left(A=a{p}, B=b_{p}, \\ldots)} / T P N P}$ ，TPCP为当前profile的总包数，TPNP为nomial profile的总包数 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:4","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#score-calculation"},{"categories":["科研学习"],"content":"threshold calculation 阈值计算，作者的老套路，$CDF(Th)=\\Phi$ ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:5","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#threshold-calculation"},{"categories":["科研学习"],"content":"selective discarding 计算打分与阈值比，大的就丢，小的就交付，整个过程可见图2. （作者搞这么大个图显然就是在凑页数） ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:6","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#selective-discarding"},{"categories":["科研学习"],"content":"实验与评估 数据集：MAWI[17] 作者的老套路。 实验环境：C++编写，inter i5 3.3GHz,4G memory 拓扑：真实拓扑，如图3.有18个node，每个node平均有3个邻居 模型的攻击：还是老套路，见截图： ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:0:0","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#实验与评估"},{"categories":["科研学习"],"content":"性能评估 Metrics 结果见表5,6,7；表5中SFC的F值显然普遍高于PS，表6中SFC的TN值高于PS，表7中的SFC的准确率高于PS。 内存，通信代价，过滤效率的关系见表8 表中的APE为：attack prevention efficitncy,AY:accuracy 存储分析 理论主存储profile所要的最大的空间为300M，实际实验检测得只要几百K即可。 ","date":"2019-08-17","objectID":"/posts/01_scoreforcore/:1:0","series":null,"tags":["论文阅读"],"title":"A distributed filtering mechanism against DDoS attacks: ScoreForCore","uri":"/posts/01_scoreforcore/#性能评估"},{"categories":["科研学习"],"content":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks Jansen K, Schäfer M, Moser D, et al. Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks[C] IEEE Symposium on Security and\u003e Privacy (S\u0026P). 2018. ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:0:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#crowd-gps-sec-leveraging-crowdsourcing-to-detect-and-localize-gps-spoofing-attacks"},{"categories":["科研学习"],"content":"Introduction ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:0:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#introduction"},{"categories":["科研学习"],"content":"GPS ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:0:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#gps"},{"categories":["科研学习"],"content":"A. GPS Usage in avaition 非常广泛 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:1:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#a-gps-usage-in-avaition"},{"categories":["科研学习"],"content":"B. GPS Spoofing Attacks 依赖GPS的航空工具都是攻击者倾向的目标 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#b-gps-spoofing-attacks"},{"categories":["科研学习"],"content":"1） Threat Model Spoffer is emulating a moving track such as a straight line or a curve with some potential acceleation ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:1","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#1-threat-model"},{"categories":["科研学习"],"content":"2) Validation of assumptions first,position advertisements contain the spoofed GPS positions Second,spoofed signals will affect neighboring aircraft and UAVs GPS Spoofing Expriments The gole of these expriments is to demonstrate that existing transponders do not perform any checks on the derived GPS position and that spoffers can precisely control the positino and speed of victim receivers 实验表明欺骗很容易实现 GPS Spoofing Coverage Estimation 根据假设作出自由空间路径损失 $$L_{fs} = 32.45 + 20log_{10}(d_{km}) + 20 log_{10}(f_{MHz}) \\tag{1}$$ $L_{$fs}$自由空间路径损耗，$d_{km}$信号源与接收器距离，$f_{MHz}$信号频率 根据（1）得 $$Power -L_{fs}d - Attenuation \\geq -160[dBW]$$ 由该公式知所有离被攻击目标内34km的UAVs都会收到至少-160dBW的信号 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:2","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#2-validation-of-assumptions"},{"categories":["科研学习"],"content":"2) Validation of assumptions first,position advertisements contain the spoofed GPS positions Second,spoofed signals will affect neighboring aircraft and UAVs GPS Spoofing Expriments The gole of these expriments is to demonstrate that existing transponders do not perform any checks on the derived GPS position and that spoffers can precisely control the positino and speed of victim receivers 实验表明欺骗很容易实现 GPS Spoofing Coverage Estimation 根据假设作出自由空间路径损失 $$L_{fs} = 32.45 + 20log_{10}(d_{km}) + 20 log_{10}(f_{MHz}) \\tag{1}$$ $L_{$fs}$自由空间路径损耗，$d_{km}$信号源与接收器距离，$f_{MHz}$信号频率 根据（1）得 $$Power -L_{fs}d - Attenuation \\geq -160[dBW]$$ 由该公式知所有离被攻击目标内34km的UAVs都会收到至少-160dBW的信号 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:2","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#gps-spoofing-expriments"},{"categories":["科研学习"],"content":"2) Validation of assumptions first,position advertisements contain the spoofed GPS positions Second,spoofed signals will affect neighboring aircraft and UAVs GPS Spoofing Expriments The gole of these expriments is to demonstrate that existing transponders do not perform any checks on the derived GPS position and that spoffers can precisely control the positino and speed of victim receivers 实验表明欺骗很容易实现 GPS Spoofing Coverage Estimation 根据假设作出自由空间路径损失 $$L_{fs} = 32.45 + 20log_{10}(d_{km}) + 20 log_{10}(f_{MHz}) \\tag{1}$$ $L_{$fs}$自由空间路径损耗，$d_{km}$信号源与接收器距离，$f_{MHz}$信号频率 根据（1）得 $$Power -L_{fs}d - Attenuation \\geq -160[dBW]$$ 由该公式知所有离被攻击目标内34km的UAVs都会收到至少-160dBW的信号 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:2","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#gps-spoofing-coverage-estimation"},{"categories":["科研学习"],"content":"CROWD-GPS-SEC 所调查，传感器主要分布在美欧，我们的系统由三个模型组成 multilateration(MLAT) module estimates the location of airrcraft based on the time defference of Arrival(TDoA) between different sensors spoofing detection module check inconsistencies between multilaterated positions and GPS-derived positions in consistencies between position advertisements from different aircraft spoofer localization module has tetected a GPS spoofer estimates the position fo the spoffer. ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:0:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#crowd-gps-sec"},{"categories":["科研学习"],"content":"A. Multilateration(MLAT) 每个被收到的信息可被表示成元组 $$ADS-B/Flarm Report :(\\hat a_i,t_s) \\tag{2}$$ 传播距离和TDoA的关系： $$dist(s_i,A) - dist(s_j,A) = \\Delta t_{i,j} \\tag{3} \\cdot c$$ $s_i$是i传感器的位置，A是发射信号的UAVs，$\\Delta t_{i,j}$为i,j的时间差,c光速。传感器距离交点即为UAVs的位置。 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:1:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#a-multilaterationmlat"},{"categories":["科研学习"],"content":"B. GPS Spoofing Detection 1) Time Alignment of Transmissions: 算出传递时间 $$t_{TX} = t_s - \\frac{dist(s,a)}{c} \\tag{4}$$ 利用相对时间计算UAVs的相对位置 $$ a_{REF} = \\left{ \\begin{aligned} \\frac{a_{TX} \\cdot(t_{TX+1} - t_{REF})+a_{TX+1} \\cdot (t_{REF} - t{TX})}{t_{TX+1} - t_{TX}}\u0026\u0026\u0026\u0026 t_{TX} \u003c t_{REF} \u0026 \\ a_{TX} \u0026\u0026\u0026\u0026 t_{TX} = t_{REF}\\ \\frac{a_{TX} \\cdot (t_{REF} - t_{TX-1}) + a_{TX-1} \\cdot (t_{TX} -t_{REF})}{t_{TX} - t_{TX-1}} \u0026\u0026\u0026\u0026 t_{TX} \u003e t_{REF} \\end{aligned} \\right. $$ (2) test1 (Cross-checks with MLAT) 测试位置差是否大于阈值 $$dist(a_i,\\hat a_i) \\overset{?}{\u003c} \\tau_i \\tag{5}$$ $a_i$是real position determined by MLAT,$\\hat a$ position reported by UAVs i using ADS-B/Flarm $\\tau$太大检测的成功率会减小，太小会提高出错率 复杂度：O(n) (3) test2 (Multiple Aircraft Comparison) UAVs间的距离比较是否小于阈值 $$dist(\\hat a_i,\\hat a_j) = d_{i,j} \\overset{?}{\u003e} \\tau _2 \\tag{6}$$ 复杂度：两两比较为$O(n^2)$，但通过最近邻算法可降到$n \\cdot Olog(n)$前面的n代表有n个UAVs。 （4）检测的时候两个test一起用 ##C. GPS Spoofer Localization ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:0","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#b-gps-spoofing-detection"},{"categories":["科研学习"],"content":"1) localization Model 每个被欺骗的UAVs报告相同的位置，反射追踪这些位置找到欺骗者的位置。检测模块找到被 欺骗的UAVs，定位模块进行定位 ，将得到的变量代入公式。 $$dist(a_i,SP) - dist(a_j,SP) = d_{i,j} \\cdot \\frac{c}{v_{track}} \\tag{7}$$ 几何断点：三个双曲面有两个点，4个或更多就只有一个交叉点 要求：两个被欺骗的UAVs在不同位置即可得到4组乖式，进而得到解。 $$\\begin{equation} \\left ( \\begin{array}{ccc} m\\ 2 \\end{array} \\right ) \\end{equation} \\cdot t_s \\ge 4 \\tag{8}$$ Comparison with MLAT. 我们的方法更好，MLAT不行 ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:1","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#1-localization-model"},{"categories":["科研学习"],"content":"2） Error Minimization: 用双曲面交叉来标记一个点而不是一个区域，错误函数为： $$E_t(SP,i,j) = dist(a_i,SP) - dist(a_j,SP) - d_{i,j} \\cdot \\frac{c}{v_{track}} \\tag{9}$$ root mean square error(RMSE)是 : $$\\begin{equation} \\mathop{\\arg\\min}{SP} \\sqrt{\\frac{\\sum{t = 1}^{\\infty}\\sum_{i = 1}^{m}\\sum_{j = 1}^{i - 1}E_t(SP,i,j)^2}{t \\cdot (\\frac{m^2}{2} - m)}} \\end{equation} \\tag{10}$$ 最小化损失函数即可最大准确率，被欺骗的UAVs越多结果越准确， ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:2","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#2-error-minimization"},{"categories":["科研学习"],"content":"3） improved Filtering 对得到的位置进行正交化过滤 $$\\hat a_i - \\hat a_{j}^{’} \\bot tarck \\tag{11}$$ ","date":"2019-08-16","objectID":"/posts/02_crowd-gps-sec/:2:3","series":null,"tags":["论文阅读"],"title":"Crowd-GPS-Sec: Leveraging Crowdsourcing to Detect and Localize GPS Spoofing Attacks","uri":"/posts/02_crowd-gps-sec/#3-improved-filtering"},{"categories":null,"content":"  DoIt is a clean, elegant but advanced blog theme for Hugo developed by HEIGE-PCloud. It is based on the LoveIt Theme, LeaveIt Theme and KeepIt Theme. ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"About DoIt","uri":"/about/#"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  PJAX loading supported  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Baidu Analytics supported  Umami Analytics supported  Plausible Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Waline comment system supported by Waline  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances  Twikoo comment system supported by Twikoo  Vssue comment system supported by Vssue  Remark42 comment system supported by Remark42  giscus comment system supported by giscus Extended Features  Search supported by Lunr.js or algolia or Fuse.js  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About DoIt","uri":"/about/#features"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  PJAX loading supported  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Baidu Analytics supported  Umami Analytics supported  Plausible Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Waline comment system supported by Waline  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances  Twikoo comment system supported by Twikoo  Vssue comment system supported by Vssue  Remark42 comment system supported by Remark42  giscus comment system supported by giscus Extended Features  Search supported by Lunr.js or algolia or Fuse.js  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About DoIt","uri":"/about/#performance-and-seo"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  PJAX loading supported  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Baidu Analytics supported  Umami Analytics supported  Plausible Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Waline comment system supported by Waline  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances  Twikoo comment system supported by Twikoo  Vssue comment system supported by Vssue  Remark42 comment system supported by Remark42  giscus comment system supported by giscus Extended Features  Search supported by Lunr.js or algolia or Fuse.js  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About DoIt","uri":"/about/#appearance-and-layout"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  PJAX loading supported  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Baidu Analytics supported  Umami Analytics supported  Plausible Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Waline comment system supported by Waline  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances  Twikoo comment system supported by Twikoo  Vssue comment system supported by Vssue  Remark42 comment system supported by Remark42  giscus comment system supported by giscus Extended Features  Search supported by Lunr.js or algolia or Fuse.js  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About DoIt","uri":"/about/#social-and-comment-systems"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  PJAX loading supported  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Baidu Analytics supported  Umami Analytics supported  Plausible Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Waline comment system supported by Waline  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances  Twikoo comment system supported by Twikoo  Vssue comment system supported by Vssue  Remark42 comment system supported by Remark42  giscus comment system supported by giscus Extended Features  Search supported by Lunr.js or algolia or Fuse.js  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"About DoIt","uri":"/about/#extended-features"},{"categories":null,"content":"License DoIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css autocomplete.js Lunr.js algoliasearch Fuse.js lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine Waline Twikoo Vssue cookieconsent Pjax Topbar Remark42 ","date":"2019-08-02","objectID":"/about/:0:2","series":null,"tags":null,"title":"About DoIt","uri":"/about/#license"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]